#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''The omegaUp i18n linter.'''

import collections
import json
import re
import sys

from hook_tools import linters
from hook_tools import git_tools


class I18nLinter(linters.Linter):
    '''Runs i18n'''
    # pylint: disable=R0903

    # Paths
    _JS_TEMPLATES_PATH = 'frontend/www/js/omegaup'
    _TEMPLATES_PATH = 'frontend/templates'

    # Colours
    _OKGREEN = git_tools.COLORS.OKGREEN
    _FAIL = git_tools.COLORS.FAIL
    _NORMAL = git_tools.COLORS.NORMAL
    _HEADER = git_tools.COLORS.HEADER
    _LANGS = ['en', 'es', 'pt', 'pseudo']

    def __init__(self, options=None):
        super().__init__()
        self.__options = options or {}

    @staticmethod
    def _generate_javascript(lang, strings):
        '''Generates the JavaScript version of the i18n file.'''

        result = []
        result.append('// generated by stuff/i18n.py. DO NOT EDIT.')
        result.append("var omegaup = require('../dist/omegaup.js');\n")
        result.append('omegaup.OmegaUp.loadTranslations({')
        for key in sorted(strings.keys()):
            result.append('\t%s: %s,' % (key, json.dumps(strings[key][lang])))
        result.append('});\n')
        return '\n'.join(result)

    @staticmethod
    def _generate_json(lang, strings):
        '''Generates the JSON version of the i18n file.'''

        json_map = {}
        for key in sorted(strings.keys()):
            json_map[key] = strings[key][lang]
        return json.dumps(json_map, sort_keys=True, indent='\t')

    @staticmethod
    def _generate_pseudo(lang, strings):
        '''Generates pseudoloc file'''

        result = []
        for key in sorted(strings.keys()):
            result.append('%s = "%s"\n' %
                          (key, strings[key][lang].replace('"', r'\"')))
        return ''.join(result)

    @staticmethod
    def _pseudoloc(original):
        '''Converts the pseudoloc version of s.'''
        table = str.maketrans('elsot', '31507')
        tokens = re.split(r'(%\([a-zA-Z0-9_-]+\))', original)
        for i, token in enumerate(tokens):
            if token.startswith('%(') and token.endswith(')'):
                continue
            tokens[i] = token.translate(table)

        return '(%s)' % ''.join(tokens)

    def _get_translated_strings(self, contents_callback, not_sorted):
        strings = {}
        languages = set()
        for lang in self._LANGS:
            filename = '%s/%s.lang' % (self._TEMPLATES_PATH, lang)
            languages.add(lang)
            last_key = ''
            for lineno, line in enumerate(contents_callback(
                    filename).split(b'\n')[:-1]):
                try:
                    row = line.decode('utf-8')
                    key, value = re.compile(r'\s+=\s+').split(row.strip(), 1)
                    if last_key >= key:
                        not_sorted.add(lang)
                    last_key = key
                    if key not in strings:
                        strings[key] = collections.defaultdict(str)
                    match = re.compile(r'^"((?:[^"]|\\")*)"$').match(value)
                    if match is None:
                        raise Exception("Invalid value")
                    strings[key][lang] = match.group(1).replace(r'\"', '"')
                except:  # pylint: disable=bare-except
                    raise linters.LinterException(
                        'Invalid i18n line "%s" in %s:%d' %
                        (row.strip(), filename, lineno + 1),
                        fixable=False)

        if not_sorted:
            raise linters.LinterException(
                'Entries in %s are not sorted.' % ', '.join(
                    sorted(not_sorted)),
                fixable=False)

        self._check_missing_entries(strings, languages)
        return strings

    def _check_missing_entries(self, strings, languages):
        missing_items_lang = set()
        for key, values in strings.items():
            missing_languages = languages.difference(list(values.keys()))
            if 'pseudo' in missing_languages:
                missing_languages.remove('pseudo')

            if missing_languages:
                print('%s%s%s' % (self._HEADER, key, self._NORMAL),
                      file=sys.stderr)

                for lang in sorted(languages):
                    if lang in values:
                        print('\t%s%-10s%s %s' %
                              (self._OKGREEN, lang, self._NORMAL,
                               values[lang]), file=sys.stderr)
                    else:
                        print('\t%s%-10s%s missing%s' %
                              (self._OKGREEN, lang, self._FAIL, self._NORMAL),
                              file=sys.stderr)
                        missing_items_lang.add(lang)

                raise linters.LinterException(
                    'There are missing items in the %s.lang'
                    ' file' % missing_items_lang,
                    fixable=False)

            if key == 'locale':
                values['pseudo'] = 'pseudo'
            else:
                values['pseudo'] = self._pseudoloc(values['en'])

    @staticmethod
    def _generate_content_entry(new_contents, original_contents, path,
                                new_content, contents_callback):
        original_content = contents_callback(path)
        if original_content.decode('utf-8') != new_content:
            print('Entries in %s do not match the .lang file.' % path,
                  file=sys.stderr)
            new_contents[path] = new_content.encode('utf-8')
            original_contents[path] = original_content

    def _generate_new_contents(self, strings, contents_callback):
        new_contents = {}
        original_contents = {}
        for language in self._LANGS:
            self._generate_content_entry(new_contents, original_contents,
                                         path='%s/lang.%s.js' % (
                                             self._JS_TEMPLATES_PATH,
                                             language),
                                         new_content=self._generate_javascript(
                                             language, strings),
                                         contents_callback=contents_callback)

            self._generate_content_entry(new_contents, original_contents,
                                         path='%s/lang.%s.json' % (
                                             self._JS_TEMPLATES_PATH,
                                             language),
                                         new_content=self._generate_json(
                                             language, strings),
                                         contents_callback=contents_callback)

        self._generate_content_entry(new_contents, original_contents,
                                     path='%s/pseudo.lang' % (
                                         self._TEMPLATES_PATH),
                                     new_content=self._generate_pseudo(
                                         'pseudo', strings),
                                     contents_callback=contents_callback)

        return new_contents, original_contents

    def run_one(self, filename, contents):
        '''Runs the linter against |contents|.'''
        # pylint: disable=no-self-use, unused-argument
        return contents, []

    def run_all(self, file_contents, contents_callback):
        '''Runs the linter against a subset of files.'''
        # pylint: disable=no-self-use, unused-argument
        not_sorted = set()
        strings = self._get_translated_strings(contents_callback, not_sorted)

        new_contents, original_contents = self._generate_new_contents(
            strings, contents_callback)

        return new_contents, original_contents, ['i18n']

    @property
    def name(self):
        '''Gets the name of the linter.'''
        return 'i18n'


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
