#!/usr/bin/python3
# -*- coding: utf-8 -*-
# type: ignore

'''The omegaUp i18n linter.'''

import collections
import json
import os
import re
import sys

from hook_tools import linters
from hook_tools import git_tools


def _unescape(s: str) -> str:
    '''Returns a version of the string without escaped entities.'''
    return s.replace('\\"', '"').replace('\\n', '\n')


class I18nLinter(linters.Linter):
    '''Runs i18n'''
    # pylint: disable=R0903

    # Paths
    _JS_TEMPLATES_PATH = 'frontend/www/js/omegaup'
    _TEMPLATES_PATH = 'frontend/templates'
    _BADGES_PATH = 'frontend/badges'

    # Colours
    _OKGREEN = git_tools.COLORS.OKGREEN
    _FAIL = git_tools.COLORS.FAIL
    _NORMAL = git_tools.COLORS.NORMAL
    _HEADER = git_tools.COLORS.HEADER
    _LANGS = ['en', 'es', 'pt']

    def __init__(self, options=None):
        super().__init__()
        self.__options = options or {}

    @staticmethod
    def _generate_javascript(lang, strings):
        '''Generates the JavaScript version of the i18n file.'''

        result = []
        result.append('// generated by stuff/i18n.py. DO NOT EDIT.')
        result.append('const translations = {')
        for key in sorted(strings.keys()):
            result.append(
                '\t%s: %s,' % (key,
                               json.dumps(_unescape(strings[key][lang]))))
        result.append('};\n')
        result.append('export {translations as default};')
        return '\n'.join(result)

    @staticmethod
    def _generate_json(lang, strings):
        '''Generates the JSON version of the i18n file.'''

        json_map = {}
        for key in sorted(strings.keys()):
            json_map[key] = _unescape(strings[key][lang])
        return json.dumps(json_map, sort_keys=True, indent='\t')

    @staticmethod
    def _generate_sorted(lang, strings):
        '''Generate the sorted version of the i18n file.'''

        result = []
        for key in sorted(strings.keys()):
            result.append('%s = "%s"\n' %
                          (key, strings[key][lang].replace('"', r'\"')))
        return ''.join(result)

    @staticmethod
    def _pseudoloc(original):
        '''Converts the pseudoloc version of s.'''
        table = str.maketrans('elsot', '31507')
        tokens = re.split(r'(%\([a-zA-Z0-9_-]+\))', original)
        for i, token in enumerate(tokens):
            if token.startswith('%(') and token.endswith(')'):
                continue
            tokens[i] = token.translate(table)

        return '(%s)' % ''.join(tokens)

    def _add_badges_entries(self, contents_callback):
        '''Adds badges name and description entries to .lang files'''
        aliases = [f.name for f in os.scandir(self._BADGES_PATH)
                   if f.is_dir()]
        strings = collections.defaultdict(lambda: collections.defaultdict(str))
        for alias in aliases:
            key_name = 'badge_%s_name' % alias
            key_desc = 'badge_%s_description' % alias
            filename = os.path.join(self._BADGES_PATH, alias,
                                    'localizations.json')
            contents = json.loads(contents_callback(filename).decode('utf-8'))
            for lang in self._LANGS:
                strings[key_name][lang] = contents[lang]['name']
                strings[key_desc][lang] = contents[lang]['description']
        return strings

    def _get_translated_strings(self, contents_callback):
        strings = {}
        languages = set()
        for lang in self._LANGS:
            filename = '%s/%s.lang' % (self._TEMPLATES_PATH, lang)
            languages.add(lang)
            for lineno, line in enumerate(contents_callback(
                    filename).split(b'\n')[:-1]):
                try:
                    row = line.decode('utf-8')
                    key, value = re.compile(r'\s+=\s+').split(row.strip(), 1)
                    if key not in strings:
                        strings[key] = collections.defaultdict(str)
                    match = re.compile(r'^"((?:[^"]|\\")*)"$').match(value)
                    if match is None:
                        raise Exception("Invalid value")
                    strings[key][lang] = match.group(1).replace(r'\"', '"')
                except:  # noqa: bare-except
                    raise linters.LinterException(
                        'Invalid i18n line "%s" in %s:%d' %
                        (row.strip(), filename, lineno + 1),
                        fixable=False)

        # Removing badges entries
        return {
            k: v for k, v in strings.items() if not k.startswith('badge_')
        }

    def _check_missing_entries(self, strings, languages):
        missing_items_lang = set()
        for key, values in strings.items():
            missing_languages = languages.difference(list(values.keys()))
            if missing_languages:
                print('%s%s%s' % (self._HEADER, key, self._NORMAL),
                      file=sys.stderr)

                for lang in sorted(languages):
                    if lang in values:
                        print('\t%s%-10s%s %s' %
                              (self._OKGREEN, lang, self._NORMAL,
                               values[lang]), file=sys.stderr)
                    else:
                        print('\t%s%-10s%s missing%s' %
                              (self._OKGREEN, lang, self._FAIL, self._NORMAL),
                              file=sys.stderr)
                        missing_items_lang.add(lang)

                raise linters.LinterException(
                    'There are missing items in the %s.lang'
                    ' file' % missing_items_lang,
                    fixable=False)

            if key == 'locale':
                values['pseudo'] = 'pseudo'
            else:
                values['pseudo'] = self._pseudoloc(values['en'])

    @staticmethod
    def _generate_content_entry(new_contents, original_contents, path,
                                new_content, contents_callback):
        original_content = contents_callback(path)
        if original_content.decode('utf-8') != new_content:
            print('Entries in %s do not match the .lang file.' % path,
                  file=sys.stderr)
            new_contents[path] = new_content.encode('utf-8')
            original_contents[path] = original_content

    def _generate_new_contents(self, strings, contents_callback):
        new_contents = {}
        original_contents = {}
        for language in self._LANGS + ['pseudo']:
            self._generate_content_entry(new_contents, original_contents,
                                         path='%s/%s.lang' % (
                                             self._TEMPLATES_PATH,
                                             language),
                                         new_content=self._generate_sorted(
                                             language, strings),
                                         contents_callback=contents_callback)
            self._generate_content_entry(new_contents, original_contents,
                                         path='%s/lang.%s.js' % (
                                             self._JS_TEMPLATES_PATH,
                                             language),
                                         new_content=self._generate_javascript(
                                             language, strings),
                                         contents_callback=contents_callback)
            self._generate_content_entry(new_contents, original_contents,
                                         path='%s/lang.%s.json' % (
                                             self._JS_TEMPLATES_PATH,
                                             language),
                                         new_content=self._generate_json(
                                             language, strings),
                                         contents_callback=contents_callback)

        return new_contents, original_contents

    def run_one(self, filename, contents):
        '''Runs the linter against |contents|.'''
        # pylint: disable=no-self-use, unused-argument
        return contents, []

    def run_all(self, file_contents, contents_callback):
        '''Runs the linter against a subset of files.'''
        # pylint: disable=no-self-use, unused-argument
        strings = self._get_translated_strings(contents_callback)
        strings.update(self._add_badges_entries(contents_callback))
        self._check_missing_entries(strings, set(self._LANGS))

        new_contents, original_contents = self._generate_new_contents(
            strings, contents_callback)

        return new_contents, original_contents, ['i18n']

    @property
    def name(self):
        '''Gets the name of the linter.'''
        return 'i18n'


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
