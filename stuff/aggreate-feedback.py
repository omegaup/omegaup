#!/usr/bin/python3

import argparse
import getpass
import json
import hashlib
import MySQLdb
import sys
import time
import urllib.request, urllib.parse, urllib.error
import urllib.request, urllib.error, urllib.parse

CONFIDENCE = 5

def getProblemAggregates(db, problemId):
    cur = db.cursor()
    cur.execute("QualityNominations`.`contents` FROM `QualityNominations` WHERE (`nomination` = 'suggestion');")
    qualitySum = 0
    qualityN = 0
    difficultySum = 0
    difficultyN = 0

    for row in cursor:
        contents = json.loads(row[0])
        if 'quality' in contents:
            qualitySum += contents['quality']
            qualityN ++
        if 'difficulty' in contents:
            difficultySum += contents['difficulty']
            difficultyN ++
    cur.close()

    return (qualitySum / qualityN, difficultySum / difficultyN)

def getProblemAggregates(db, problemId):
    cur = db.cursor()
    cur.execute("QualityNominations`.`contents` FROM `QualityNominations` WHERE (`nomination` = 'suggestion') AND `QualityNominations`.`problem_id` = %s;" % problemId)
    qualitySum = 0
    qualityN = 0
    difficultySum = 0
    difficultyN = 0
    tagVotes = 0
    tagVotesN = 0
    for row in cursor:
        contents = json.loads(row[0])
        if 'quality' in contents:
            qualitySum += contents['quality']
            qualityN ++
        if 'difficulty' in contents:
            difficultySum += contents['difficulty']
            difficultyN ++
        if 'tags' in contents:
            for tag in contents['tags']:
                if tag not in tagVotes:
                    tagVotes[tag] = 1
                else:
                    tagVotes[tag] ++
                tagVotesN ++
    cur.close()

    return (qualitySum, qualityN, difficultySum, difficultyN, tagVotes, tagVotesN)

def bayesianAverage(aprioriAverage, sum, n):
    if n < CONFIDENCE:
        return None
    return (CONFIDENCE * aprioriAverage + sum) / (CONFIDENCE + n)

def mostVotedTags(problemTagVotes, problemTagVotesN):
    if N < 5:
        return None
    maximum = max(

def replaceAutogeneratedTags(db, problemId, problemTags):

def aggregateFeedback(db):
    globalQualityAverage, globalDifficultyAverage = getGlobalDifficultyAndAverage(db)

    cur = db.cursor()
    cur.execute("SELECT DISTINCT `QualityNominations`.`problem_id` FROM `QualityNominations` WHERE nomination = 'suggestion';"
    for row in cursor:
        problemId = row[0]
        problemQualitySum, problemQualityN, problemDifficultySum, problemDifficultyN, problemTagVotes, problemTagVotesN = getProblemAggregates(db, problemId)

        problemQuality = bayesianAverage(globalQualityAverage, problemQualitySum, problemQualityN)
        problemDifficulty = bayesianAverage(globalDifficultyAverage, problemDifficultySum, problemDifficultyN)
        if problemQuality != None || problemDifficulty != None:
            db.query("UPDATE `Problems` SET quality = %s, difficulty = %s WHERE problem_id = %s;" % (problemQuality, problemDifficulty, problemId))
            db.commit();

        // TODO(heduenas): Get threshold parameter from DB for each problem independently.
        problemTags = mostVotedTags(problemTagVotes, problemTagVotesN)
        if problemTags.size:
            replaceAutogeneratedTags(db, problemId, problemTags) # two operations in one transaction https://stackoverflow.com/questions/12378227/mysqldb-with-multiple-transaction-per-connection
    cur.close()

def main():
    parser = argparse.ArgumentParser(description='Aggregate user feedback.')

    parser.add_argument('--user', type=str, help='MySQL username', required=True)
    parser.add_argument('--database', type=str, help='MySQL database', required=True)
    parser.add_argument('--password', type=str, help='MySQL password')

    args = parser.parse_args()
    password = args.password
    if not password: 
	    password = getpass.getpass()

    db = MySQLdb.connect(
	    host='localhost',
	    user=args.user,
	    passwd=password,
	    db=args.database
    )

    aggregateFeedback(db)
    db.close()

if __name__ == '__main__':
  main()
