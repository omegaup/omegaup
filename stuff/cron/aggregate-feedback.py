#!/usr/bin/python3

import argparse
import collections
import getpass
import json
import logging

import MySQLdb

CONFIDENCE = 5
MAX_NUM_TOPICS = 5

def getGlobalQualityAndDifficultyAverage(db):
    with db.cursor() as cur:
        cur.execute("""SELECT qn.`contents`
                       FROM `QualityNominations` as qn
                       WHERE `nomination` = 'suggestion';""")
        qualitySum = 0
        qualityN = 0
        difficultySum = 0
        difficultyN = 0

        for row in cur:
            try:
                contents = json.loads(row[0])
            except:
                logging.exception('Failed to parse contents')
                continue

            if 'quality' in contents:
                qualitySum += contents['quality']
                qualityN += 1
            if 'difficulty' in contents:
                difficultySum += contents['difficulty']
                difficultyN += 1

    qualityAverage = None
    if qualityN:
        qualityAverage = qualitySum / float(qualityN)
    difficultyAverage = None
    if difficultyN:
        difficultyAverage = difficultySum / float(difficultyN)
    return (qualityAverage, difficultyAverage)

def getProblemAggregates(db, problemId):
    with db.cursor() as cur:
        cur.execute("""SELECT qn.`contents`
                       FROM `QualityNominations` as qn
                       WHERE qn.`nomination` = 'suggestion'
                         AND qn.`problem_id` = %s;""",
                    (problemId,))
        qualitySum = 0
        qualityN = 0
        difficultySum = 0
        difficultyN = 0
        tagVotes = collections.defaultdict(int)
        tagVotesN = 0
        for row in cur:
            contents = json.loads(row[0])
            if 'quality' in contents:
                qualitySum += contents['quality']
                qualityN += 1
            if 'difficulty' in contents:
                difficultySum += contents['difficulty']
                difficultyN += 1
            if 'tags' in contents:
                for tag in contents['tags']:
                    tagVotes[tag] += 1
                    tagVotesN += 1

    return (qualitySum, qualityN, difficultySum, difficultyN, tagVotes,
            tagVotesN)

def bayesianAverage(aprioriAverage, valuesSum, valuesN):
    if valuesN < CONFIDENCE or aprioriAverage is None:
        return None
    return (CONFIDENCE * aprioriAverage + valuesSum) / (CONFIDENCE + valuesN)

def mostVotedTags(problemTagVotes, problemTagVotesN):
    if problemTagVotesN < 5:
        return None
    maximum = problemTagVotes[max(problemTagVotes, key=problemTagVotes.get)]
    finalTags = [tag for (tag, votes) in problemTagVotes.items()
                 if votes >= 0.25 * maximum]
    if len(finalTags) >= MAX_NUM_TOPICS:
        return None
    return finalTags

def replaceAutogeneratedTags(db, problemId, problemTags):
    try:
        logging.debug('Replacing problem %d tags with %r', problemId,
                      problemTags)
        with db.cursor() as cur:
            cur.execute("""DELETE FROM
                               `Problems_Tags`
                           WHERE
                               `problem_id` = %s AND `autogenerated` = 1;""",
                        (problemId,))
            cur.execute("""INSERT INTO
                               `Problems_Tags`(`problem_id`, `tag_id`,
                                               `public`, `autogenerated`)
                           SELECT
                               %%s AS `problem_id`,
                               `t`.`tag_id` AS `tag_id`,
                               1 AS `public`,
                               1 AS `autogenerated `
                           FROM
                               `Tags` AS `t`
                           WHERE
                               `t`.`name` IN (%s);""" %
                        ', '.join('%s' for _ in problemTags),
                        (problemId,) + tuple(problemTags))
            db.commit()
    except:
        logging.exception('Failed to replace autogenerated tags')
        db.rollback()

def aggregateFeedback(db):
    (globalQualityAverage,
     globalDifficultyAverage) = getGlobalQualityAndDifficultyAverage(db)

    with db.cursor() as cur:
        cur.execute("""SELECT DISTINCT qn.`problem_id`
                       FROM `QualityNominations` as qn
                       WHERE qn.`nomination` = 'suggestion';""")
        for row in cur:
            problemId = row[0]
            logging.debug('Aggregating feedback for problem %d', problemId)

            (problemQualitySum, problemQualityN,
             problemDifficultySum, problemDifficultyN,
             problemTagVotes,
             problemTagVotesN) = getProblemAggregates(db, problemId)

            problemQuality = bayesianAverage(
                globalQualityAverage, problemQualitySum, problemQualityN)
            problemDifficulty = bayesianAverage(globalDifficultyAverage,
                                                problemDifficultySum,
                                                problemDifficultyN)
            if problemQuality is not None and problemDifficulty is not None:
                logging.debug('Updating problem %d. quality=%f, difficulty=%f',
                              problemId, problemQuality, problemDifficulty)
                cur.execute("""UPDATE
                                   `Problems` as p
                               SET
                                   p.`quality` = %s, p.`difficulty` = %s
                               WHERE
                                   p.`problem_id` = %s;""",
                            (problemQuality, problemDifficulty, problemId))
                db.commit()
            else:
                logging.debug('Not enough information for problem %d',
                              problemId)

            # TODO(heduenas): Get threshold parameter from DB for each problem
            # independently.
            problemTags = mostVotedTags(problemTagVotes, problemTagVotesN)
            if problemTags:
                replaceAutogeneratedTags(db, problemId, problemTags)

def main():
    parser = argparse.ArgumentParser(
        description='Aggregate user feedback.')

    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Enables verbose logging')
    parser.add_argument('--host', type=str, help='MySQL host',
                        default='localhost')
    parser.add_argument('--user', type=str, help='MySQL username',
                        required=True)
    parser.add_argument('--password', type=str, help='MySQL password')
    parser.add_argument('--database', type=str, help='MySQL database',
                        default='omegaup')

    args = parser.parse_args()
    password = args.password
    if password is None:
        password = getpass.getpass()
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    db = MySQLdb.connect(
        host=args.host,
        user=args.user,
        passwd=password,
        db=args.database
    )

    aggregateFeedback(db)
    db.close()

if __name__ == '__main__':
    main()
