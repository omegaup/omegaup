#!/usr/bin/python3

import argparse
import collections
import getpass
import json
import hashlib
import MySQLdb
import logging
import sys
import time

CONFIDENCE = 5
MAX_NUM_TOPICS = 5

def getGlobalQualityAndDifficultyAverage(db):
    with db.cursor() as cur:
        cur.execute("""SELECT qn.`contents`
                       FROM `QualityNominations` as qn
                       WHERE `nomination` = 'suggestion';""")
        qualitySum = 0
        qualityN = 0
        difficultySum = 0
        difficultyN = 0

        for row in cur:
            try:
                contents = json.loads(row[0])
            except e:
                logging.exception('Failed to parse contents')
                continue

            if 'quality' in contents:
                qualitySum += contents['quality']
                qualityN += 1
            if 'difficulty' in contents:
                difficultySum += contents['difficulty']
                difficultyN += 1

    qualityAverage = None
    if qualityN:
      qualityAverage = qualitySum / float(qualityN)
    difficultyAverage = None
    if difficultyN:
      difficultyAverage = difficultySum / float(difficultyN)
    return (qualityAverage, difficultyAverage)

def getProblemAggregates(db, problemId):
    with db.cursor() as cur:
        cur.execute("""SELECT qn.`contents`
                       FROM `QualityNominations` as qn 
                       WHERE qn.`nomination` = 'suggestion'
                         AND qn.`problem_id` = %s;"""
                               % problemId)
        qualitySum = 0
        qualityN = 0
        difficultySum = 0
        difficultyN = 0
        tagVotes = collections.defaultdict(int)
        tagVotesN = 0
        for row in cur:
            contents = json.loads(row[0])
            if 'quality' in contents:
                qualitySum += contents['quality']
                qualityN += 1
            if 'difficulty' in contents:
                difficultySum += contents['difficulty']
                difficultyN += 1
            if 'tags' in contents:
                for tag in contents['tags']:
                    tagVotes[tag] += 1
                    tagVotesN += 1

    return (qualitySum, qualityN, difficultySum, difficultyN, tagVotes, tagVotesN)

def bayesianAverage(aprioriAverage, sum, n):
    if n < CONFIDENCE or aprioriAverage is None:
        return None
    return (CONFIDENCE * aprioriAverage + sum) / (CONFIDENCE + n)

def mostVotedTags(problemTagVotes, problemTagVotesN):
    if problemTagVotesN < 5:
        return None
    maximum = problemTagVotes[max(problemTagVotes, key=problemTagVotes.get)]
    finalTags = [tag for (tag, votes) in problemTagVotes.items() if (votes >= 0.25 * maximum)]
    if len(finalTags) >= MAX_NUM_TOPICS:
        return None
    return finalTags

def replaceAutogeneratedTags(db, problemId, problemTags):
    try:
        db.query("DELETE FROM `Problems_Tags` WHERE `problem_id` = %s AND `autogenerated` = 1;"
                % problemId);

        for tag in problemTags:
            with db.cursor() as cur:
                cur.execute("SELECT `Tags`.`tag_id` FROM `Tags` WHERE `name` = '%s';" % tag)
                tagId = cur.fetchone()[0]
                db.query("""INSERT INTO `Problems_Tags`
                            (`problem_id`, `tag_id`, `public`, `autogenerated`) 
                            VALUES (%s, %s, %s, %s);""" % (problemId, tagId, 1, 1))
        db.commit()
    except e:
        logging.exception('Failed to replace autogenerated tags')
        db.rollback()

def aggregateFeedback(db):
    globalQualityAverage, globalDifficultyAverage = getGlobalQualityAndDifficultyAverage(db)

    with db.cursor() as cur:
        cur.execute("""SELECT DISTINCT qn.`problem_id`
                       FROM `QualityNominations` as qn
                       WHERE qn.`nomination` = 'suggestion';""")
        for row in cur:
            problemId = row[0]

            (problemQualitySum, problemQualityN,
             problemDifficultySum, problemDifficultyN,
             problemTagVotes, problemTagVotesN) = getProblemAggregates(db, problemId)

            problemQuality = bayesianAverage(
                    globalQualityAverage, problemQualitySum, problemQualityN)
            problemDifficulty = bayesianAverage(globalDifficultyAverage,
                                                problemDifficultySum,
                                                problemDifficultyN)
            if problemQuality is not None or problemDifficulty != None:
                db.query("""UPDATE `Problems` as p SET p.`quality` = %s, p.`difficulty` = %s 
                            WHERE p.`problem_id` = %s;"""
                        % (problemQuality, problemDifficulty, problemId))
                db.commit();

            # TODO(heduenas): Get threshold parameter from DB for each problem independently.
            problemTags = mostVotedTags(problemTagVotes, problemTagVotesN)
            if len(problemTags):
                replaceAutogeneratedTags(db, problemId, problemTags)

def main():
    parser = argparse.ArgumentParser(description='Aggregate user feedback.')

    parser.add_argument('--host', type=str, help='MySQL host', default='localhost')
    parser.add_argument('--user', type=str, help='MySQL username', required=True)
    parser.add_argument('--password', type=str, help='MySQL password')
    parser.add_argument('--database', type=str, help='MySQL database', default='omegaup')

    args = parser.parse_args()
    password = args.password
    if password is None:
	    password = getpass.getpass()

    db = MySQLdb.connect(
	    host=args.host,
	    user=args.user,
	    passwd=password,
	    db=args.database
    )

    aggregateFeedback(db)
    db.close()

if __name__ == '__main__':
    main()
