name: PR Labeler

on:
  pull_request_target:
    types: [opened, synchronize, reopened, closed]

jobs:
  labeler:
    permissions:
      pull-requests: write
      contents: read
      issues: write
    runs-on: ubuntu-22.04
    name: Label PR by path and size
    steps:
      # Step 1: Checkout repo (required for actions/labeler to read config)
      - uses: actions/checkout@v4

      # Step 2: Create size labels if they don't exist (for fresh forks)
      - name: Create PR size labels if they don't exist
        run: |
          create_or_update_label() {
            local name=$1
            local color=$2
            local description=$3
            # URL encode the label name (replace / with %2F)
            local encoded_name=$(echo "$name" | sed 's|/|%2F|g')
            
            # Try to create the label first
            local create_response=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Authorization: token ${{ github.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/labels" \
              -d "{\"name\":\"$name\",\"color\":\"$color\",\"description\":\"$description\"}")
            
            local http_code=$(echo "$create_response" | tail -n1)
            
            if [ "$http_code" = "201" ]; then
              echo "Created label '$name'"
            elif [ "$http_code" = "422" ]; then
              # Label already exists, update it
              echo "Label '$name' already exists, updating..."
              curl -X PATCH \
                -H "Authorization: token ${{ github.token }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/labels/$encoded_name" \
                -d "{\"name\":\"$name\",\"color\":\"$color\",\"description\":\"$description\"}" \
                -f -s -o /dev/null || true
            else
              echo "Warning: Failed to create/update label '$name' (HTTP $http_code)"
            fi
          }

          # Create labels with specified colors
          create_or_update_label "size/XS" "0e8a16" "Very small PR (≤10 lines)"
          create_or_update_label "size/S" "28a745" "Small PR (≤50 lines)"
          create_or_update_label "size/M" "fbca04" "Medium PR (≤100 lines)"
          create_or_update_label "size/L" "d93f0b" "Large PR (≤200 lines)"
          create_or_update_label "size/XL" "b60205" "Extra large PR (>200 lines)"

      # Step 3: Apply path-based labels (sync-labels: false to preserve size labels)
      - name: Apply path-based labels
        uses: actions/labeler@v6
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          sync-labels: false
          dot: true

      # Step 4: Calculate and apply size label (idempotent - only if changed)
      - name: Apply size label
        uses: actions/github-script@v7
        with:
          script: |
            const sizeLabels = ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'];
            const sizeThresholds = [
              { label: 'size/XS', max: 10 },
              { label: 'size/S', max: 50 },
              { label: 'size/M', max: 100 },
              { label: 'size/L', max: 200 },
              { label: 'size/XL', max: Infinity }
            ];
            
            const filesToIgnore = [
              'composer.lock',
              'yarn.lock',
              'package-lock.json',
              'frontend/www/js/dist/',
              'frontend/www/css/dist/',
              'frontend/www/media/dist/',
              'coverage/',
              'coverage.xml',
              'frontend/www/grader/ephemeral/'
            ];
            
            const pr = context.payload.pull_request;
            const issueNumber = pr.number;
            
            // Skip labeling for closed PRs
            if (context.payload.action === 'closed') {
              core.info('PR is closed, skipping size labeling');
              return;
            }
            
            // Get all PR files using pagination (handles PRs with >100 files)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: issueNumber,
              per_page: 100
            });
            
            // Calculate total lines changed (excluding ignored files)
            let totalLines = 0;
            for (const file of files) {
              const shouldIgnore = filesToIgnore.some(pattern => 
                file.filename.includes(pattern) || 
                file.filename.endsWith('.lock')
              );
              if (!shouldIgnore) {
                totalLines += file.additions + file.deletions;
              }
            }
            
            core.info(`Total lines changed (excluding ignored): ${totalLines}`);
            
            // Determine the appropriate size label
            let newSizeLabel = 'size/XL';
            for (const threshold of sizeThresholds) {
              if (totalLines <= threshold.max) {
                newSizeLabel = threshold.label;
                break;
              }
            }
            
            core.info(`Calculated size label: ${newSizeLabel}`);
            
            // Add warning comment for XL PRs (check before label idempotency to ensure comment is posted)
            if (newSizeLabel === 'size/XL') {
              const warningMessage = `⚠️ This PR exceeds the recommended size of 200 lines.

Please make sure you are NOT addressing multiple issues with one PR. If it's possible to split this work into smaller, focused changes, that would be great and will help with review.

Note: This PR might require additional review time due to its size.`;
              
              // Check if warning comment already exists
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              const hasWarning = comments.some(c => c.body.includes('exceeds the recommended size'));
              
              if (!hasWarning) {
                core.info('Adding XL size warning comment');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: warningMessage
                });
              } else {
                core.info('XL size warning comment already exists');
              }
            }
            
            // Get current labels on the PR
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const currentSizeLabel = currentLabels.find(l => sizeLabels.includes(l.name));
            
            // Only update label if the size category has changed (idempotent)
            if (currentSizeLabel?.name === newSizeLabel) {
              core.info(`Size label ${newSizeLabel} already applied, no change needed`);
              return;
            }
            
            // Remove old size label if present
            if (currentSizeLabel) {
              core.info(`Removing old size label: ${currentSizeLabel.name}`);
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  name: currentSizeLabel.name
                });
              } catch (error) {
                core.warning(`Failed to remove label ${currentSizeLabel.name}: ${error.message}`);
              }
            }
            
            // Add new size label
            core.info(`Adding size label: ${newSizeLabel}`);
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: [newSizeLabel]
            });
