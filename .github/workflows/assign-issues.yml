name: "Assign Issues"

on:
    issue_comment:
        types: [created]
    schedule:
        # Run daily to handle reminders and automatic unassignments
        - cron: "0 3 * * *"
    workflow_dispatch:

# Prevent race condition when multiple users comment /assign simultaneously
concurrency:
    group: assign-issue-${{ github.event.issue.number || 'scheduled' }}
    cancel-in-progress: false

jobs:
    assign:
        runs-on: ubuntu-22.04
        permissions:
            issues: write
            pull-requests: write
        steps:
            - name: Check for experienced issue creator exception
              id: pre_check
              if: github.event_name == 'issue_comment'
              uses: actions/github-script@v8
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const comment = context.payload.comment.body.trim();
                      const commenter = context.payload.comment.user.login;
                      const issue = context.payload.issue;
                      
                      if (comment !== '/assign') {
                          core.setOutput('handled', 'false');
                          return;
                      }
                      
                      const isIssueCreator = issue.user.login === commenter;
                      if (!isIssueCreator) {
                          core.setOutput('handled', 'false');
                          return;
                      }
                      
                      const currentAssignees = issue.assignees.map(a => a.login);
                      if (currentAssignees.includes(commenter)) {
                          await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issue.number,
                              body: `@${commenter} You are already assigned to this issue.`
                          });
                          core.setOutput('handled', 'true');
                          return;
                      }
                      
                      const REQUIRED_APPROVED_PRS = 10;
                      let approvedPRCount = 0;
                      let cursor = null;
                      let hasNextPage = true;
                      const MAX_PRS_TO_QUERY = 200;
                      let totalPRsQueried = 0;
                      
                      while (hasNextPage && approvedPRCount < REQUIRED_APPROVED_PRS && totalPRsQueried < MAX_PRS_TO_QUERY) {
                          const result = await github.graphql(`
                              query($owner: String!, $repo: String!, $author: String!, $cursor: String) {
                                  repository(owner: $owner, name: $repo) {
                                      pullRequests(
                                          first: 50
                                          author: $author
                                          states: [MERGED]
                                          after: $cursor
                                          orderBy: {field: UPDATED_AT, direction: DESC}
                                      ) {
                                          pageInfo { hasNextPage endCursor }
                                          nodes {
                                              id
                                          }
                                      }
                                  }
                              }
                          `, {
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              author: commenter,
                              cursor
                          });
                          
                          const prs = result.repository.pullRequests;
                          totalPRsQueried += prs.nodes.length;
                          approvedPRCount += prs.nodes.length;
                          hasNextPage = prs.pageInfo.hasNextPage;
                          cursor = prs.pageInfo.endCursor;
                      }
                      
                      if (approvedPRCount >= REQUIRED_APPROVED_PRS) {
                          try {
                              await github.rest.issues.addAssignees({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  assignees: [commenter]
                              });
                              
                              await github.rest.issues.createComment({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  body: `Assigned to @${commenter}!\n\n` +
                                        `As an experienced contributor (${approvedPRCount} merged PRs) working on your own issue, ` +
                                        `you're exempt from the standard 5-assignment limit. Please open a pull request within 7 days. ` +
                                        `If no PR is opened, this issue will be automatically unassigned to keep the queue moving.`
                              });
                              
                              core.setOutput('handled', 'true');
                          } catch (error) {
                              core.setOutput('handled', 'false');
                          }
                          return;
                      }
                      
                      core.setOutput('handled', 'false');

            - name: Count user self-assignments
              id: count_assignments
              if: github.event_name == 'issue_comment' && steps.pre_check.outputs.handled != 'true'
              uses: actions/github-script@v8
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const comment = context.payload.comment.body.trim();
                      if (comment !== '/assign') {
                          core.setOutput('current_count', '0');
                          return;
                      }
                      
                      const commenter = context.payload.comment.user.login;
                      const MAX_ASSIGNMENTS = 5;
                      
                      // Search for ALL issues where this user ever commented "/assign"
                      const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:issue commenter:${commenter} "/assign" in:comments`;
                      
                      let potentialSelfAssignedIssues = [];
                      try {
                          const { data: searchResults } = await github.rest.search.issuesAndPullRequests({
                              q: searchQuery,
                              per_page: 100
                          });
                          // Filter out PRs
                          potentialSelfAssignedIssues = searchResults.items.filter(item => !item.pull_request);
                      } catch (error) {
                          console.log(`Search error: ${error.message}`);
                      }
                      
                      // Count self-assignments, but subtract those where user used /unassign
                      let selfAssignCount = 0;
                      
                      for (const issue of potentialSelfAssignedIssues) {
                          try {
                              // Use timeline API to get both comments and events in chronological order
                              const { data: timeline } = await github.rest.issues.listEventsForTimeline({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  per_page: 100
                              });
                              
                              // Find all /assign comments from this user
                              const assignComments = timeline.filter(e => {
                                  if (e.event !== 'commented') return false;
                                  const commentAuthor = e.actor?.login || e.user?.login;
                                  if (commentAuthor !== commenter) return false;
                                  return e.body?.trim() === '/assign';
                              });
                              
                              // Check if any /assign resulted in a successful assignment
                              let wasSuccessfullyAssigned = false;
                              let lastAssignTime = 0;
                              
                              for (const assignComment of assignComments) {
                                  const commentTime = new Date(assignComment.created_at).getTime();
                                  
                                  const wasAssigned = timeline.some(e => {
                                      if (e.event !== 'assigned') return false;
                                      if (e.assignee?.login !== commenter) return false;
                                      
                                      const assignTime = new Date(e.created_at).getTime();
                                      return assignTime >= commentTime && (assignTime - commentTime) < 60000;
                                  });
                                  
                                  if (wasAssigned) {
                                      wasSuccessfullyAssigned = true;
                                      lastAssignTime = Math.max(lastAssignTime, commentTime);
                                  }
                              }
                              
                              if (!wasSuccessfullyAssigned) continue;
                              
                              // Check if user voluntarily unassigned using /unassign AFTER the assignment
                              const voluntaryUnassign = timeline.some(e => {
                                  if (e.event !== 'commented') return false;
                                  const commentAuthor = e.actor?.login || e.user?.login;
                                  if (commentAuthor !== commenter) return false;
                                  if (e.body?.trim() !== '/unassign') return false;
                                  
                                  const unassignCommentTime = new Date(e.created_at).getTime();
                                  if (unassignCommentTime <= lastAssignTime) return false;
                                  
                                  // Check if this /unassign resulted in actual unassignment
                                  return timeline.some(ue => {
                                      if (ue.event !== 'unassigned') return false;
                                      if (ue.assignee?.login !== commenter) return false;
                                      
                                      const unassignTime = new Date(ue.created_at).getTime();
                                      return unassignTime >= unassignCommentTime && (unassignTime - unassignCommentTime) < 60000;
                                  });
                              });
                              
                              // Only count if user did NOT voluntarily unassign
                              if (!voluntaryUnassign) {
                                  selfAssignCount++;
                              }
                          } catch (error) {
                              console.log(`Error checking timeline for issue #${issue.number}: ${error.message}`);
                          }
                      }
                      
                      // Remaining after this assignment = max - current self-assigns - 1
                      const remainingAfterAssignment = MAX_ASSIGNMENTS - selfAssignCount - 1;
                      
                      core.setOutput('current_count', selfAssignCount.toString());
                      core.setOutput('remaining_count', Math.max(0, remainingAfterAssignment).toString());
                      core.setOutput('max_assignments', MAX_ASSIGNMENTS.toString());

            - name: Assign or unassign issues (standard flow)
              id: assign_action
              if: github.event_name != 'issue_comment' || steps.pre_check.outputs.handled != 'true'
              uses: takanome-dev/assign-issue-action@beta
              with:
                  github_token: ${{ secrets.GITHUB_TOKEN }}
                  maintainers: ""
                  self_assign_cmd: /assign
                  self_unassign_cmd: /unassign
                  # Unassign after 7 days if no PR is opened
                  days_until_unassign: 7
                  enable_auto_suggestion: true
                  allow_self_assign_author: true
                  enable_reminder: true
                  reminder_days: auto
                  reminder_comment: >
                      Quick reminder: please open a pull request within 3.5 days
                      or this issue will be unassigned so others can pick it up.
                  assigned_label: ""
                  pin_label: ""
                  max_assignments: 5
                  max_assignments_message: >
                      You already have the maximum number of assigned issues (5).
                      Please wrap up or unassign one before taking another.
                  block_assignment: true
                  block_assignment_comment: >
                      Kindly ask the maintainers to assign this issue to you again.
                  assigned_comment: ""
                  unassigned_comment: >
                      Unassigned because no pull request was opened within 7
                      days. If you want to be assigned to this issue again,
                      kindly ask the maintainers to assign it to you again.
                  assignment_suggestion_comment: >
                      If you'd like to take this issue, comment with /assign.
                      Please note the 7-day PR expectation.

            - name: Post assignment message with remaining count
              if: github.event_name == 'issue_comment' && steps.assign_action.outputs.assigned == 'yes'
              uses: actions/github-script@v8
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const commenter = context.payload.comment.user.login;
                      const remaining = '${{ steps.count_assignments.outputs.remaining_count }}';
                      const maxAssignments = '${{ steps.count_assignments.outputs.max_assignments }}';
                      
                      let remainingMessage = '';
                      if (remaining === '0') {
                          remainingMessage = `\n\nYou have reached your maximum of ${maxAssignments} assigned issues. Please complete or unassign an issue before taking another.`;
                      } else {
                          remainingMessage = `\n\nYou have **${remaining}** self-assign${remaining === '1' ? '' : 's'} remaining out of ${maxAssignments}.`;
                      }
                      
                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: context.payload.issue.number,
                          body: `Assigned! Please open a pull request within 7 days. If no PR is opened, this issue will be automatically unassigned to keep the queue moving.${remainingMessage}`
                      });
