name: autoupdate

permissions:
  contents: write
  pull-requests: write

on:
  # Trigger on pushes to main branch
  # This will automatically update all PRs targeting main when changes are pushed
  push:
    branches:
      - main

jobs:
  autoupdate:
    name: Auto-update Pull Requests
    runs-on: ubuntu-22.04
    steps:
      - name: Update PRs and check for conflicts
        id: update_prs
        uses: actions/github-script@v7
        with:
          script: |
            // Define labels that should prevent auto-update
            const EXCLUDED_LABELS = [
              "blocked â†’ not yet ready",
              "blocked â†’ waiting input",
              "blocked â†’ waiting parent",
              "Stale"
            ];

            // 1. Fetch all open PRs using pagination
            const prs = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: 'main',
              sort: 'updated',
              direction: 'desc'
            });

            console.log(`Checking ${prs.length} open pull requests...`);

            const results = {
              updated: [],
              conflicts: [],
              skipped_fork: [],
              skipped_label: [],
              already_current: [],
              errored: []
            };

            for (const pr of prs) {
              if (pr.draft) continue;

              // 2. Skip if PR has excluded labels
              if (pr.labels.some(l => EXCLUDED_LABELS.includes(l.name))) {
                results.skipped_label.push(`#${pr.number}`);
                continue;
              }

              // 3. Skip if PR is from a fork (security limitation)
              if (pr.head.repo.full_name !== context.repo.full_name) {
                results.skipped_fork.push(`#${pr.number}`);
                continue;
              }

              try {
                // 4. Attempt to update the branch with latest main
                await github.rest.pulls.updateBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                });
                results.updated.push(`#${pr.number}`);
                console.log(`âœ… Successfully updated PR #${pr.number}`);
              } catch (error) {
                if (error.status === 422) {
                  // status 422 can be "Already up to date" OR "Merge conflict"
                  const message = error.response?.data?.message || error.message || "";
                  if (message.toLowerCase().includes('conflict')) {
                    results.conflicts.push(`#${pr.number}`);
                    console.log(`âš ï¸ Merge conflict detected in PR #${pr.number}`);
                  } else {
                    results.already_current.push(`#${pr.number}`);
                    console.log(`â„¹ï¸ PR #${pr.number} is already up to date.`);
                  }
                } else {
                  results.errored.push(`#${pr.number} (${error.message})`);
                  console.log(`âŒ Error updating PR #${pr.number}: ${error.message}`);
                }
              }
            }

            // --- Enhanced Summary Reporting ---
            await core.summary
              .addHeading('Auto-update Summary')
              .addRaw('This workflow runs on every push to `main` to keep internal PRs synced.')
              .addTable([
                ['Status', 'Count', 'Pull Requests'],
                ['âœ… Updated', results.updated.length.toString(), results.updated.join(', ') || '-'],
                ['âš ï¸ Conflicts', results.conflicts.length.toString(), results.conflicts.join(', ') || '-'],
                ['â„¹ï¸ Skipped (Forks)', results.skipped_fork.length.toString(), results.skipped_fork.join(', ') || '-'],
                ['ðŸš« Skipped (Labels)', results.skipped_label.length.toString(), results.skipped_label.join(', ') || '-'],
                ['âœ” Already Current', results.already_current.length.toString(), results.already_current.join(', ') || '-'],
                ['âŒ Errors', results.errored.length.toString(), results.errored.join(', ') || '-'],
              ])
              .addRaw('\n> **Note for Fork PRs:** Contributors must manually sync forks by fetching `upstream/main` and rebasing.')
              .write();

            if (results.conflicts.length > 0) {
              core.warning(`Merge conflicts detected in: ${results.conflicts.join(', ')}`);
            }
