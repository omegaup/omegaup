// generated by frontend/server/cmd/APITool.php. DO NOT EDIT.
import { messages } from './api_types';
import { addError } from './errors';

interface ApiCallOptions {
  quiet?: boolean;
}

export function apiCall<
  RequestType extends { [key: string]: any },
  ServerResponseType,
  ResponseType = ServerResponseType
>(
  url: string,
  transform?: (result: ServerResponseType) => ResponseType,
): (params?: RequestType, options?: ApiCallOptions) => Promise<ResponseType> {
  return (params?: RequestType, options?: ApiCallOptions) =>
    new Promise((accept, reject) => {
      let responseOk = true;
      let responseStatus = 200;
      fetch(
        url,
        params
          ? {
              method: 'POST',
              body: Object.keys(params)
                .filter(
                  (key) =>
                    params[key] !== null && typeof params[key] !== 'undefined',
                )
                .map((key) => {
                  if (params[key] instanceof Date) {
                    return `${encodeURIComponent(key)}=${encodeURIComponent(
                      Math.round(params[key].getTime() / 1000),
                    )}`;
                  }
                  return `${encodeURIComponent(key)}=${encodeURIComponent(
                    params[key],
                  )}`;
                })
                .join('&'),
              headers: {
                'Content-Type':
                  'application/x-www-form-urlencoded;charset=UTF-8',
              },
            }
          : undefined,
      )
        .then((response) => {
          if (response.status == 499) {
            // If we cancel the connection, let's just swallow the error since
            // the user is not going to see it.
            return;
          }
          responseOk = response.ok;
          responseStatus = response.status;
          return response.json();
        })
        .then((data) => {
          if (!responseOk) {
            if (typeof data === 'object' && !Array.isArray(data)) {
              data.status = 'error';
              data.httpStatusCode = responseStatus;
            }
            if (!options?.quiet) {
              addError(data);
              console.error(data);
            }
            reject(data);
            return;
          }
          if (transform) {
            accept(transform(data));
          } else {
            accept(data);
          }
        })
        .catch((err) => {
          const errorData = {
            status: 'error',
            error: err,
            httpStatusCode: responseStatus,
          };
          if (!options?.quiet) {
            addError(errorData);
            console.error(errorData);
          }
          reject(errorData);
        });
    });
}

export const Admin = {
  platformReportStats: apiCall<
    messages.AdminPlatformReportStatsRequest,
    messages.AdminPlatformReportStatsResponse
  >('/api/admin/platformReportStats/'),
};

export const Authorization = {
  problem: apiCall<
    messages.AuthorizationProblemRequest,
    messages.AuthorizationProblemResponse
  >('/api/authorization/problem/'),
};

export const Badge = {
  badgeDetails: apiCall<
    messages.BadgeBadgeDetailsRequest,
    messages._BadgeBadgeDetailsServerResponse,
    messages.BadgeBadgeDetailsResponse
  >('/api/badge/badgeDetails/', (x) => {
    if (x.assignation_time)
      x.assignation_time = ((x: number) => new Date(x * 1000))(
        x.assignation_time,
      );
    if (x.first_assignation)
      x.first_assignation = ((x: number) => new Date(x * 1000))(
        x.first_assignation,
      );
    return x;
  }),
  list: apiCall<messages.BadgeListRequest, messages.BadgeListResponse>(
    '/api/badge/list/',
  ),
  myBadgeAssignationTime: apiCall<
    messages.BadgeMyBadgeAssignationTimeRequest,
    messages._BadgeMyBadgeAssignationTimeServerResponse,
    messages.BadgeMyBadgeAssignationTimeResponse
  >('/api/badge/myBadgeAssignationTime/', (x) => {
    if (x.assignation_time)
      x.assignation_time = ((x: number) => new Date(x * 1000))(
        x.assignation_time,
      );
    return x;
  }),
  myList: apiCall<
    messages.BadgeMyListRequest,
    messages._BadgeMyListServerResponse,
    messages.BadgeMyListResponse
  >('/api/badge/myList/', (x) => {
    x.badges = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.assignation_time)
          x.assignation_time = ((x: number) => new Date(x * 1000))(
            x.assignation_time,
          );
        if (x.first_assignation)
          x.first_assignation = ((x: number) => new Date(x * 1000))(
            x.first_assignation,
          );
        return x;
      });
    })(x.badges);
    return x;
  }),
  userList: apiCall<
    messages.BadgeUserListRequest,
    messages._BadgeUserListServerResponse,
    messages.BadgeUserListResponse
  >('/api/badge/userList/', (x) => {
    x.badges = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.assignation_time)
          x.assignation_time = ((x: number) => new Date(x * 1000))(
            x.assignation_time,
          );
        if (x.first_assignation)
          x.first_assignation = ((x: number) => new Date(x * 1000))(
            x.first_assignation,
          );
        return x;
      });
    })(x.badges);
    return x;
  }),
};

export const Clarification = {
  create: apiCall<
    messages.ClarificationCreateRequest,
    messages.ClarificationCreateResponse
  >('/api/clarification/create/'),
  details: apiCall<
    messages.ClarificationDetailsRequest,
    messages.ClarificationDetailsResponse
  >('/api/clarification/details/'),
  update: apiCall<
    messages.ClarificationUpdateRequest,
    messages.ClarificationUpdateResponse
  >('/api/clarification/update/'),
};

export const Contest = {
  activityReport: apiCall<
    messages.ContestActivityReportRequest,
    messages._ContestActivityReportServerResponse,
    messages.ContestActivityReportResponse
  >('/api/contest/activityReport/', (x) => {
    x.events = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.events);
    return x;
  }),
  addAdmin: apiCall<
    messages.ContestAddAdminRequest,
    messages.ContestAddAdminResponse
  >('/api/contest/addAdmin/'),
  addGroup: apiCall<
    messages.ContestAddGroupRequest,
    messages.ContestAddGroupResponse
  >('/api/contest/addGroup/'),
  addGroupAdmin: apiCall<
    messages.ContestAddGroupAdminRequest,
    messages.ContestAddGroupAdminResponse
  >('/api/contest/addGroupAdmin/'),
  addProblem: apiCall<
    messages.ContestAddProblemRequest,
    messages.ContestAddProblemResponse
  >('/api/contest/addProblem/'),
  addUser: apiCall<
    messages.ContestAddUserRequest,
    messages.ContestAddUserResponse
  >('/api/contest/addUser/'),
  adminDetails: apiCall<
    messages.ContestAdminDetailsRequest,
    messages._ContestAdminDetailsServerResponse,
    messages.ContestAdminDetailsResponse
  >('/api/contest/adminDetails/', (x) => {
    x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    if (x.submission_deadline)
      x.submission_deadline = ((x: number) => new Date(x * 1000))(
        x.submission_deadline,
      );
    return x;
  }),
  adminList: apiCall<
    messages.ContestAdminListRequest,
    messages._ContestAdminListServerResponse,
    messages.ContestAdminListResponse
  >('/api/contest/adminList/', (x) => {
    x.contests = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.last_updated = ((x: number) => new Date(x * 1000))(x.last_updated);
        if (x.original_finish_time)
          x.original_finish_time = ((x: number) => new Date(x * 1000))(
            x.original_finish_time,
          );
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.contests);
    return x;
  }),
  admins: apiCall<
    messages.ContestAdminsRequest,
    messages.ContestAdminsResponse
  >('/api/contest/admins/'),
  arbitrateRequest: apiCall<
    messages.ContestArbitrateRequestRequest,
    messages.ContestArbitrateRequestResponse
  >('/api/contest/arbitrateRequest/'),
  clarifications: apiCall<
    messages.ContestClarificationsRequest,
    messages._ContestClarificationsServerResponse,
    messages.ContestClarificationsResponse
  >('/api/contest/clarifications/', (x) => {
    x.clarifications = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.clarifications);
    return x;
  }),
  clone: apiCall<messages.ContestCloneRequest, messages.ContestCloneResponse>(
    '/api/contest/clone/',
  ),
  contestants: apiCall<
    messages.ContestContestantsRequest,
    messages.ContestContestantsResponse
  >('/api/contest/contestants/'),
  create: apiCall<
    messages.ContestCreateRequest,
    messages.ContestCreateResponse
  >('/api/contest/create/'),
  createVirtual: apiCall<
    messages.ContestCreateVirtualRequest,
    messages.ContestCreateVirtualResponse
  >('/api/contest/createVirtual/'),
  details: apiCall<
    messages.ContestDetailsRequest,
    messages._ContestDetailsServerResponse,
    messages.ContestDetailsResponse
  >('/api/contest/details/', (x) => {
    x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    if (x.submission_deadline)
      x.submission_deadline = ((x: number) => new Date(x * 1000))(
        x.submission_deadline,
      );
    return x;
  }),
  list: apiCall<
    messages.ContestListRequest,
    messages._ContestListServerResponse,
    messages.ContestListResponse
  >('/api/contest/list/', (x) => {
    x.results = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.last_updated = ((x: number) => new Date(x * 1000))(x.last_updated);
        x.original_finish_time = ((x: number) => new Date(x * 1000))(
          x.original_finish_time,
        );
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.results);
    return x;
  }),
  listParticipating: apiCall<
    messages.ContestListParticipatingRequest,
    messages._ContestListParticipatingServerResponse,
    messages.ContestListParticipatingResponse
  >('/api/contest/listParticipating/', (x) => {
    x.contests = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.last_updated = ((x: number) => new Date(x * 1000))(x.last_updated);
        if (x.original_finish_time)
          x.original_finish_time = ((x: number) => new Date(x * 1000))(
            x.original_finish_time,
          );
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.contests);
    return x;
  }),
  myList: apiCall<
    messages.ContestMyListRequest,
    messages._ContestMyListServerResponse,
    messages.ContestMyListResponse
  >('/api/contest/myList/', (x) => {
    x.contests = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.last_updated = ((x: number) => new Date(x * 1000))(x.last_updated);
        if (x.original_finish_time)
          x.original_finish_time = ((x: number) => new Date(x * 1000))(
            x.original_finish_time,
          );
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.contests);
    return x;
  }),
  open: apiCall<messages.ContestOpenRequest, messages.ContestOpenResponse>(
    '/api/contest/open/',
  ),
  problems: apiCall<
    messages.ContestProblemsRequest,
    messages.ContestProblemsResponse
  >('/api/contest/problems/'),
  publicDetails: apiCall<
    messages.ContestPublicDetailsRequest,
    messages._ContestPublicDetailsServerResponse,
    messages.ContestPublicDetailsResponse
  >('/api/contest/publicDetails/', (x) => {
    x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    return x;
  }),
  registerForContest: apiCall<
    messages.ContestRegisterForContestRequest,
    messages.ContestRegisterForContestResponse
  >('/api/contest/registerForContest/'),
  removeAdmin: apiCall<
    messages.ContestRemoveAdminRequest,
    messages.ContestRemoveAdminResponse
  >('/api/contest/removeAdmin/'),
  removeGroup: apiCall<
    messages.ContestRemoveGroupRequest,
    messages.ContestRemoveGroupResponse
  >('/api/contest/removeGroup/'),
  removeGroupAdmin: apiCall<
    messages.ContestRemoveGroupAdminRequest,
    messages.ContestRemoveGroupAdminResponse
  >('/api/contest/removeGroupAdmin/'),
  removeProblem: apiCall<
    messages.ContestRemoveProblemRequest,
    messages.ContestRemoveProblemResponse
  >('/api/contest/removeProblem/'),
  removeUser: apiCall<
    messages.ContestRemoveUserRequest,
    messages.ContestRemoveUserResponse
  >('/api/contest/removeUser/'),
  report: apiCall<
    messages.ContestReportRequest,
    messages._ContestReportServerResponse,
    messages.ContestReportResponse
  >('/api/contest/report/', (x) => {
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    return x;
  }),
  requests: apiCall<
    messages.ContestRequestsRequest,
    messages._ContestRequestsServerResponse,
    messages.ContestRequestsResponse
  >('/api/contest/requests/', (x) => {
    x.users = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.last_update)
          x.last_update = ((x: number) => new Date(x * 1000))(x.last_update);
        x.request_time = ((x: number) => new Date(x * 1000))(x.request_time);
        return x;
      });
    })(x.users);
    return x;
  }),
  role: apiCall<messages.ContestRoleRequest, messages.ContestRoleResponse>(
    '/api/contest/role/',
  ),
  runs: apiCall<
    messages.ContestRunsRequest,
    messages._ContestRunsServerResponse,
    messages.ContestRunsResponse
  >('/api/contest/runs/', (x) => {
    x.runs = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.runs);
    return x;
  }),
  runsDiff: apiCall<
    messages.ContestRunsDiffRequest,
    messages.ContestRunsDiffResponse
  >('/api/contest/runsDiff/'),
  scoreboard: apiCall<
    messages.ContestScoreboardRequest,
    messages._ContestScoreboardServerResponse,
    messages.ContestScoreboardResponse
  >('/api/contest/scoreboard/', (x) => {
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    return x;
  }),
  scoreboardEvents: apiCall<
    messages.ContestScoreboardEventsRequest,
    messages.ContestScoreboardEventsResponse
  >('/api/contest/scoreboardEvents/'),
  scoreboardMerge: apiCall<
    messages.ContestScoreboardMergeRequest,
    messages.ContestScoreboardMergeResponse
  >('/api/contest/scoreboardMerge/'),
  searchUsers: apiCall<
    messages.ContestSearchUsersRequest,
    messages.ContestSearchUsersResponse
  >('/api/contest/searchUsers/'),
  setRecommended: apiCall<
    messages.ContestSetRecommendedRequest,
    messages.ContestSetRecommendedResponse
  >('/api/contest/setRecommended/'),
  stats: apiCall<
    messages.ContestStatsRequest,
    messages._ContestStatsServerResponse,
    messages.ContestStatsResponse
  >('/api/contest/stats/', (x) => {
    if (x.max_wait_time)
      x.max_wait_time = ((x: number) => new Date(x * 1000))(x.max_wait_time);
    return x;
  }),
  update: apiCall<
    messages.ContestUpdateRequest,
    messages.ContestUpdateResponse
  >('/api/contest/update/'),
  updateEndTimeForIdentity: apiCall<
    messages.ContestUpdateEndTimeForIdentityRequest,
    messages.ContestUpdateEndTimeForIdentityResponse
  >('/api/contest/updateEndTimeForIdentity/'),
  users: apiCall<
    messages.ContestUsersRequest,
    messages._ContestUsersServerResponse,
    messages.ContestUsersResponse
  >('/api/contest/users/', (x) => {
    x.users = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.access_time)
          x.access_time = ((x: number) => new Date(x * 1000))(x.access_time);
        if (x.end_time)
          x.end_time = ((x: number) => new Date(x * 1000))(x.end_time);
        return x;
      });
    })(x.users);
    return x;
  }),
};

export const Course = {
  activityReport: apiCall<
    messages.CourseActivityReportRequest,
    messages._CourseActivityReportServerResponse,
    messages.CourseActivityReportResponse
  >('/api/course/activityReport/', (x) => {
    x.events = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.events);
    return x;
  }),
  addAdmin: apiCall<
    messages.CourseAddAdminRequest,
    messages.CourseAddAdminResponse
  >('/api/course/addAdmin/'),
  addGroupAdmin: apiCall<
    messages.CourseAddGroupAdminRequest,
    messages.CourseAddGroupAdminResponse
  >('/api/course/addGroupAdmin/'),
  addProblem: apiCall<
    messages.CourseAddProblemRequest,
    messages.CourseAddProblemResponse
  >('/api/course/addProblem/'),
  addStudent: apiCall<
    messages.CourseAddStudentRequest,
    messages.CourseAddStudentResponse
  >('/api/course/addStudent/'),
  adminDetails: apiCall<
    messages.CourseAdminDetailsRequest,
    messages._CourseAdminDetailsServerResponse,
    messages.CourseAdminDetailsResponse
  >('/api/course/adminDetails/', (x) => {
    x.assignments = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.assignments);
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    return x;
  }),
  admins: apiCall<messages.CourseAdminsRequest, messages.CourseAdminsResponse>(
    '/api/course/admins/',
  ),
  arbitrateRequest: apiCall<
    messages.CourseArbitrateRequestRequest,
    messages.CourseArbitrateRequestResponse
  >('/api/course/arbitrateRequest/'),
  assignmentDetails: apiCall<
    messages.CourseAssignmentDetailsRequest,
    messages._CourseAssignmentDetailsServerResponse,
    messages.CourseAssignmentDetailsResponse
  >('/api/course/assignmentDetails/', (x) => {
    x.courseAssignments = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.courseAssignments);
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    return x;
  }),
  assignmentScoreboard: apiCall<
    messages.CourseAssignmentScoreboardRequest,
    messages._CourseAssignmentScoreboardServerResponse,
    messages.CourseAssignmentScoreboardResponse
  >('/api/course/assignmentScoreboard/', (x) => {
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    return x;
  }),
  assignmentScoreboardEvents: apiCall<
    messages.CourseAssignmentScoreboardEventsRequest,
    messages.CourseAssignmentScoreboardEventsResponse
  >('/api/course/assignmentScoreboardEvents/'),
  clone: apiCall<messages.CourseCloneRequest, messages.CourseCloneResponse>(
    '/api/course/clone/',
  ),
  create: apiCall<messages.CourseCreateRequest, messages.CourseCreateResponse>(
    '/api/course/create/',
  ),
  createAssignment: apiCall<
    messages.CourseCreateAssignmentRequest,
    messages.CourseCreateAssignmentResponse
  >('/api/course/createAssignment/'),
  details: apiCall<
    messages.CourseDetailsRequest,
    messages._CourseDetailsServerResponse,
    messages.CourseDetailsResponse
  >('/api/course/details/', (x) => {
    x.assignments = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.assignments);
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    return x;
  }),
  generateTokenForCloneCourse: apiCall<
    messages.CourseGenerateTokenForCloneCourseRequest,
    messages.CourseGenerateTokenForCloneCourseResponse
  >('/api/course/generateTokenForCloneCourse/'),
  getProblemUsers: apiCall<
    messages.CourseGetProblemUsersRequest,
    messages.CourseGetProblemUsersResponse
  >('/api/course/getProblemUsers/'),
  introDetails: apiCall<
    messages.CourseIntroDetailsRequest,
    messages._CourseIntroDetailsServerResponse,
    messages.CourseIntroDetailsResponse
  >('/api/course/introDetails/', (x) => {
    if (x.details)
      x.details = ((x) => {
        x.assignments = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          });
        })(x.assignments);
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      })(x.details);
    return x;
  }),
  listAssignments: apiCall<
    messages.CourseListAssignmentsRequest,
    messages._CourseListAssignmentsServerResponse,
    messages.CourseListAssignmentsResponse
  >('/api/course/listAssignments/', (x) => {
    x.assignments = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.assignments);
    return x;
  }),
  listCourses: apiCall<
    messages.CourseListCoursesRequest,
    messages._CourseListCoursesServerResponse,
    messages.CourseListCoursesResponse
  >('/api/course/listCourses/', (x) => {
    x.admin = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.assignments = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          });
        })(x.assignments);
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.admin);
    x.public = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.assignments = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          });
        })(x.assignments);
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.public);
    x.student = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.assignments = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          });
        })(x.assignments);
        if (x.finish_time)
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.student);
    return x;
  }),
  listSolvedProblems: apiCall<
    messages.CourseListSolvedProblemsRequest,
    messages.CourseListSolvedProblemsResponse
  >('/api/course/listSolvedProblems/'),
  listStudents: apiCall<
    messages.CourseListStudentsRequest,
    messages.CourseListStudentsResponse
  >('/api/course/listStudents/'),
  listUnsolvedProblems: apiCall<
    messages.CourseListUnsolvedProblemsRequest,
    messages.CourseListUnsolvedProblemsResponse
  >('/api/course/listUnsolvedProblems/'),
  myProgress: apiCall<
    messages.CourseMyProgressRequest,
    messages.CourseMyProgressResponse
  >('/api/course/myProgress/'),
  registerForCourse: apiCall<
    messages.CourseRegisterForCourseRequest,
    messages.CourseRegisterForCourseResponse
  >('/api/course/registerForCourse/'),
  removeAdmin: apiCall<
    messages.CourseRemoveAdminRequest,
    messages.CourseRemoveAdminResponse
  >('/api/course/removeAdmin/'),
  removeAssignment: apiCall<
    messages.CourseRemoveAssignmentRequest,
    messages.CourseRemoveAssignmentResponse
  >('/api/course/removeAssignment/'),
  removeGroupAdmin: apiCall<
    messages.CourseRemoveGroupAdminRequest,
    messages.CourseRemoveGroupAdminResponse
  >('/api/course/removeGroupAdmin/'),
  removeProblem: apiCall<
    messages.CourseRemoveProblemRequest,
    messages.CourseRemoveProblemResponse
  >('/api/course/removeProblem/'),
  removeStudent: apiCall<
    messages.CourseRemoveStudentRequest,
    messages.CourseRemoveStudentResponse
  >('/api/course/removeStudent/'),
  requests: apiCall<
    messages.CourseRequestsRequest,
    messages._CourseRequestsServerResponse,
    messages.CourseRequestsResponse
  >('/api/course/requests/', (x) => {
    x.users = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.last_update)
          x.last_update = ((x: number) => new Date(x * 1000))(x.last_update);
        x.request_time = ((x: number) => new Date(x * 1000))(x.request_time);
        return x;
      });
    })(x.users);
    return x;
  }),
  runs: apiCall<
    messages.CourseRunsRequest,
    messages._CourseRunsServerResponse,
    messages.CourseRunsResponse
  >('/api/course/runs/', (x) => {
    x.runs = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.runs);
    return x;
  }),
  studentProgress: apiCall<
    messages.CourseStudentProgressRequest,
    messages._CourseStudentProgressServerResponse,
    messages.CourseStudentProgressResponse
  >('/api/course/studentProgress/', (x) => {
    x.problems = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.runs = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.runs);
        return x;
      });
    })(x.problems);
    return x;
  }),
  update: apiCall<messages.CourseUpdateRequest, messages.CourseUpdateResponse>(
    '/api/course/update/',
  ),
  updateAssignment: apiCall<
    messages.CourseUpdateAssignmentRequest,
    messages.CourseUpdateAssignmentResponse
  >('/api/course/updateAssignment/'),
  updateAssignmentsOrder: apiCall<
    messages.CourseUpdateAssignmentsOrderRequest,
    messages.CourseUpdateAssignmentsOrderResponse
  >('/api/course/updateAssignmentsOrder/'),
  updateProblemsOrder: apiCall<
    messages.CourseUpdateProblemsOrderRequest,
    messages.CourseUpdateProblemsOrderResponse
  >('/api/course/updateProblemsOrder/'),
};

export const Grader = {
  status: apiCall<messages.GraderStatusRequest, messages.GraderStatusResponse>(
    '/api/grader/status/',
  ),
};

export const Group = {
  addUser: apiCall<messages.GroupAddUserRequest, messages.GroupAddUserResponse>(
    '/api/group/addUser/',
  ),
  create: apiCall<messages.GroupCreateRequest, messages.GroupCreateResponse>(
    '/api/group/create/',
  ),
  createScoreboard: apiCall<
    messages.GroupCreateScoreboardRequest,
    messages.GroupCreateScoreboardResponse
  >('/api/group/createScoreboard/'),
  details: apiCall<messages.GroupDetailsRequest, messages.GroupDetailsResponse>(
    '/api/group/details/',
  ),
  list: apiCall<messages.GroupListRequest, messages.GroupListResponse>(
    '/api/group/list/',
  ),
  members: apiCall<messages.GroupMembersRequest, messages.GroupMembersResponse>(
    '/api/group/members/',
  ),
  myList: apiCall<
    messages.GroupMyListRequest,
    messages._GroupMyListServerResponse,
    messages.GroupMyListResponse
  >('/api/group/myList/', (x) => {
    x.groups = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.create_time = ((x: number) => new Date(x * 1000))(x.create_time);
        return x;
      });
    })(x.groups);
    return x;
  }),
  removeUser: apiCall<
    messages.GroupRemoveUserRequest,
    messages.GroupRemoveUserResponse
  >('/api/group/removeUser/'),
  update: apiCall<messages.GroupUpdateRequest, messages.GroupUpdateResponse>(
    '/api/group/update/',
  ),
};

export const GroupScoreboard = {
  addContest: apiCall<
    messages.GroupScoreboardAddContestRequest,
    messages.GroupScoreboardAddContestResponse
  >('/api/groupScoreboard/addContest/'),
  details: apiCall<
    messages.GroupScoreboardDetailsRequest,
    messages._GroupScoreboardDetailsServerResponse,
    messages.GroupScoreboardDetailsResponse
  >('/api/groupScoreboard/details/', (x) => {
    x.contests = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
        x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
        return x;
      });
    })(x.contests);
    return x;
  }),
  list: apiCall<
    messages.GroupScoreboardListRequest,
    messages.GroupScoreboardListResponse
  >('/api/groupScoreboard/list/'),
  removeContest: apiCall<
    messages.GroupScoreboardRemoveContestRequest,
    messages.GroupScoreboardRemoveContestResponse
  >('/api/groupScoreboard/removeContest/'),
};

export const Identity = {
  bulkCreate: apiCall<
    messages.IdentityBulkCreateRequest,
    messages.IdentityBulkCreateResponse
  >('/api/identity/bulkCreate/'),
  changePassword: apiCall<
    messages.IdentityChangePasswordRequest,
    messages.IdentityChangePasswordResponse
  >('/api/identity/changePassword/'),
  create: apiCall<
    messages.IdentityCreateRequest,
    messages.IdentityCreateResponse
  >('/api/identity/create/'),
  selectIdentity: apiCall<
    messages.IdentitySelectIdentityRequest,
    messages.IdentitySelectIdentityResponse
  >('/api/identity/selectIdentity/'),
  update: apiCall<
    messages.IdentityUpdateRequest,
    messages.IdentityUpdateResponse
  >('/api/identity/update/'),
};

export const Interview = {
  addUsers: apiCall<
    messages.InterviewAddUsersRequest,
    messages.InterviewAddUsersResponse
  >('/api/interview/addUsers/'),
  create: apiCall<
    messages.InterviewCreateRequest,
    messages.InterviewCreateResponse
  >('/api/interview/create/'),
  details: apiCall<
    messages.InterviewDetailsRequest,
    messages._InterviewDetailsServerResponse,
    messages.InterviewDetailsResponse
  >('/api/interview/details/', (x) => {
    x.users = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.access_time)
          x.access_time = ((x: number) => new Date(x * 1000))(x.access_time);
        return x;
      });
    })(x.users);
    return x;
  }),
  list: apiCall<messages.InterviewListRequest, messages.InterviewListResponse>(
    '/api/interview/list/',
  ),
};

export const Notification = {
  myList: apiCall<
    messages.NotificationMyListRequest,
    messages._NotificationMyListServerResponse,
    messages.NotificationMyListResponse
  >('/api/notification/myList/', (x) => {
    x.notifications = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.timestamp = ((x: number) => new Date(x * 1000))(x.timestamp);
        return x;
      });
    })(x.notifications);
    return x;
  }),
  readNotifications: apiCall<
    messages.NotificationReadNotificationsRequest,
    messages.NotificationReadNotificationsResponse
  >('/api/notification/readNotifications/'),
};

export const Problem = {
  addAdmin: apiCall<
    messages.ProblemAddAdminRequest,
    messages.ProblemAddAdminResponse
  >('/api/problem/addAdmin/'),
  addGroupAdmin: apiCall<
    messages.ProblemAddGroupAdminRequest,
    messages.ProblemAddGroupAdminResponse
  >('/api/problem/addGroupAdmin/'),
  addTag: apiCall<
    messages.ProblemAddTagRequest,
    messages.ProblemAddTagResponse
  >('/api/problem/addTag/'),
  adminList: apiCall<
    messages.ProblemAdminListRequest,
    messages.ProblemAdminListResponse
  >('/api/problem/adminList/'),
  admins: apiCall<
    messages.ProblemAdminsRequest,
    messages.ProblemAdminsResponse
  >('/api/problem/admins/'),
  bestScore: apiCall<
    messages.ProblemBestScoreRequest,
    messages.ProblemBestScoreResponse
  >('/api/problem/bestScore/'),
  clarifications: apiCall<
    messages.ProblemClarificationsRequest,
    messages._ProblemClarificationsServerResponse,
    messages.ProblemClarificationsResponse
  >('/api/problem/clarifications/', (x) => {
    x.clarifications = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.clarifications);
    return x;
  }),
  create: apiCall<
    messages.ProblemCreateRequest,
    messages.ProblemCreateResponse
  >('/api/problem/create/'),
  delete: apiCall<
    messages.ProblemDeleteRequest,
    messages.ProblemDeleteResponse
  >('/api/problem/delete/'),
  details: apiCall<
    messages.ProblemDetailsRequest,
    messages._ProblemDetailsServerResponse,
    messages.ProblemDetailsResponse
  >('/api/problem/details/', (x) => {
    x.creation_date = ((x: number) => new Date(x * 1000))(x.creation_date);
    if (x.problemsetter)
      x.problemsetter = ((x) => {
        if (x.creation_date)
          x.creation_date = ((x: number) => new Date(x * 1000))(
            x.creation_date,
          );
        return x;
      })(x.problemsetter);
    if (x.runs)
      x.runs = ((x) => {
        if (!Array.isArray(x)) {
          return x;
        }
        return x.map((x) => {
          x.time = ((x: number) => new Date(x * 1000))(x.time);
          return x;
        });
      })(x.runs);
    if (x.solvers)
      x.solvers = ((x) => {
        if (!Array.isArray(x)) {
          return x;
        }
        return x.map((x) => {
          x.time = ((x: number) => new Date(x * 1000))(x.time);
          return x;
        });
      })(x.solvers);
    return x;
  }),
  list: apiCall<messages.ProblemListRequest, messages.ProblemListResponse>(
    '/api/problem/list/',
  ),
  myList: apiCall<
    messages.ProblemMyListRequest,
    messages.ProblemMyListResponse
  >('/api/problem/myList/'),
  randomKarelProblem: apiCall<
    messages.ProblemRandomKarelProblemRequest,
    messages.ProblemRandomKarelProblemResponse
  >('/api/problem/randomKarelProblem/'),
  randomLanguageProblem: apiCall<
    messages.ProblemRandomLanguageProblemRequest,
    messages.ProblemRandomLanguageProblemResponse
  >('/api/problem/randomLanguageProblem/'),
  rejudge: apiCall<
    messages.ProblemRejudgeRequest,
    messages.ProblemRejudgeResponse
  >('/api/problem/rejudge/'),
  removeAdmin: apiCall<
    messages.ProblemRemoveAdminRequest,
    messages.ProblemRemoveAdminResponse
  >('/api/problem/removeAdmin/'),
  removeGroupAdmin: apiCall<
    messages.ProblemRemoveGroupAdminRequest,
    messages.ProblemRemoveGroupAdminResponse
  >('/api/problem/removeGroupAdmin/'),
  removeTag: apiCall<
    messages.ProblemRemoveTagRequest,
    messages.ProblemRemoveTagResponse
  >('/api/problem/removeTag/'),
  runs: apiCall<
    messages.ProblemRunsRequest,
    messages._ProblemRunsServerResponse,
    messages.ProblemRunsResponse
  >('/api/problem/runs/', (x) => {
    x.runs = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.runs);
    return x;
  }),
  runsDiff: apiCall<
    messages.ProblemRunsDiffRequest,
    messages.ProblemRunsDiffResponse
  >('/api/problem/runsDiff/'),
  selectVersion: apiCall<
    messages.ProblemSelectVersionRequest,
    messages.ProblemSelectVersionResponse
  >('/api/problem/selectVersion/'),
  solution: apiCall<
    messages.ProblemSolutionRequest,
    messages.ProblemSolutionResponse
  >('/api/problem/solution/'),
  stats: apiCall<messages.ProblemStatsRequest, messages.ProblemStatsResponse>(
    '/api/problem/stats/',
  ),
  tags: apiCall<messages.ProblemTagsRequest, messages.ProblemTagsResponse>(
    '/api/problem/tags/',
  ),
  update: apiCall<
    messages.ProblemUpdateRequest,
    messages.ProblemUpdateResponse
  >('/api/problem/update/'),
  updateProblemLevel: apiCall<
    messages.ProblemUpdateProblemLevelRequest,
    messages.ProblemUpdateProblemLevelResponse
  >('/api/problem/updateProblemLevel/'),
  updateSolution: apiCall<
    messages.ProblemUpdateSolutionRequest,
    messages.ProblemUpdateSolutionResponse
  >('/api/problem/updateSolution/'),
  updateStatement: apiCall<
    messages.ProblemUpdateStatementRequest,
    messages.ProblemUpdateStatementResponse
  >('/api/problem/updateStatement/'),
  versions: apiCall<
    messages.ProblemVersionsRequest,
    messages._ProblemVersionsServerResponse,
    messages.ProblemVersionsResponse
  >('/api/problem/versions/', (x) => {
    x.log = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.author = ((x) => {
          if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
          return x;
        })(x.author);
        x.committer = ((x) => {
          if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
          return x;
        })(x.committer);
        return x;
      });
    })(x.log);
    return x;
  }),
};

export const ProblemForfeited = {
  getCounts: apiCall<
    messages.ProblemForfeitedGetCountsRequest,
    messages.ProblemForfeitedGetCountsResponse
  >('/api/problemForfeited/getCounts/'),
};

export const Problemset = {
  details: apiCall<
    messages.ProblemsetDetailsRequest,
    messages._ProblemsetDetailsServerResponse,
    messages.ProblemsetDetailsResponse
  >('/api/problemset/details/', (x) => {
    if (x.courseAssignments)
      x.courseAssignments = ((x) => {
        if (!Array.isArray(x)) {
          return x;
        }
        return x.map((x) => {
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        });
      })(x.courseAssignments);
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    if (x.start_time)
      x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    if (x.submission_deadline)
      x.submission_deadline = ((x: number) => new Date(x * 1000))(
        x.submission_deadline,
      );
    if (x.users)
      x.users = ((x) => {
        if (!Array.isArray(x)) {
          return x;
        }
        return x.map((x) => {
          if (x.access_time)
            x.access_time = ((x: number) => new Date(x * 1000))(x.access_time);
          return x;
        });
      })(x.users);
    return x;
  }),
  scoreboard: apiCall<
    messages.ProblemsetScoreboardRequest,
    messages._ProblemsetScoreboardServerResponse,
    messages.ProblemsetScoreboardResponse
  >('/api/problemset/scoreboard/', (x) => {
    if (x.finish_time)
      x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
    x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    return x;
  }),
  scoreboardEvents: apiCall<
    messages.ProblemsetScoreboardEventsRequest,
    messages.ProblemsetScoreboardEventsResponse
  >('/api/problemset/scoreboardEvents/'),
};

export const QualityNomination = {
  create: apiCall<
    messages.QualityNominationCreateRequest,
    messages.QualityNominationCreateResponse
  >('/api/qualityNomination/create/'),
  details: apiCall<
    messages.QualityNominationDetailsRequest,
    messages._QualityNominationDetailsServerResponse,
    messages.QualityNominationDetailsResponse
  >('/api/qualityNomination/details/', (x) => {
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    x.votes = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.votes);
    return x;
  }),
  list: apiCall<
    messages.QualityNominationListRequest,
    messages._QualityNominationListServerResponse,
    messages.QualityNominationListResponse
  >('/api/qualityNomination/list/', (x) => {
    x.nominations = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        x.votes = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.votes);
        return x;
      });
    })(x.nominations);
    return x;
  }),
  myAssignedList: apiCall<
    messages.QualityNominationMyAssignedListRequest,
    messages._QualityNominationMyAssignedListServerResponse,
    messages.QualityNominationMyAssignedListResponse
  >('/api/qualityNomination/myAssignedList/', (x) => {
    x.nominations = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        x.votes = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.votes);
        return x;
      });
    })(x.nominations);
    return x;
  }),
  myList: apiCall<
    messages.QualityNominationMyListRequest,
    messages._QualityNominationMyListServerResponse,
    messages.QualityNominationMyListResponse
  >('/api/qualityNomination/myList/', (x) => {
    x.nominations = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        x.votes = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.votes);
        return x;
      });
    })(x.nominations);
    return x;
  }),
  resolve: apiCall<
    messages.QualityNominationResolveRequest,
    messages.QualityNominationResolveResponse
  >('/api/qualityNomination/resolve/'),
};

export const Reset = {
  create: apiCall<messages.ResetCreateRequest, messages.ResetCreateResponse>(
    '/api/reset/create/',
  ),
  generateToken: apiCall<
    messages.ResetGenerateTokenRequest,
    messages.ResetGenerateTokenResponse
  >('/api/reset/generateToken/'),
  update: apiCall<messages.ResetUpdateRequest, messages.ResetUpdateResponse>(
    '/api/reset/update/',
  ),
};

export const Run = {
  counts: apiCall<messages.RunCountsRequest, messages.RunCountsResponse>(
    '/api/run/counts/',
  ),
  create: apiCall<
    messages.RunCreateRequest,
    messages._RunCreateServerResponse,
    messages.RunCreateResponse
  >('/api/run/create/', (x) => {
    x.nextSubmissionTimestamp = ((x: number) => new Date(x * 1000))(
      x.nextSubmissionTimestamp,
    );
    x.submission_deadline = ((x: number) => new Date(x * 1000))(
      x.submission_deadline,
    );
    return x;
  }),
  details: apiCall<messages.RunDetailsRequest, messages.RunDetailsResponse>(
    '/api/run/details/',
  ),
  disqualify: apiCall<
    messages.RunDisqualifyRequest,
    messages.RunDisqualifyResponse
  >('/api/run/disqualify/'),
  list: apiCall<
    messages.RunListRequest,
    messages._RunListServerResponse,
    messages.RunListResponse
  >('/api/run/list/', (x) => {
    x.runs = ((x) => {
      if (!Array.isArray(x)) {
        return x;
      }
      return x.map((x) => {
        x.time = ((x: number) => new Date(x * 1000))(x.time);
        return x;
      });
    })(x.runs);
    return x;
  }),
  rejudge: apiCall<messages.RunRejudgeRequest, messages.RunRejudgeResponse>(
    '/api/run/rejudge/',
  ),
  source: apiCall<messages.RunSourceRequest, messages.RunSourceResponse>(
    '/api/run/source/',
  ),
  status: apiCall<
    messages.RunStatusRequest,
    messages._RunStatusServerResponse,
    messages.RunStatusResponse
  >('/api/run/status/', (x) => {
    x.time = ((x: number) => new Date(x * 1000))(x.time);
    return x;
  }),
};

export const School = {
  create: apiCall<messages.SchoolCreateRequest, messages.SchoolCreateResponse>(
    '/api/school/create/',
  ),
  list: apiCall<messages.SchoolListRequest, messages.SchoolListResponse>(
    '/api/school/list/',
  ),
  selectSchoolOfTheMonth: apiCall<
    messages.SchoolSelectSchoolOfTheMonthRequest,
    messages.SchoolSelectSchoolOfTheMonthResponse
  >('/api/school/selectSchoolOfTheMonth/'),
};

export const Scoreboard = {
  refresh: apiCall<
    messages.ScoreboardRefreshRequest,
    messages.ScoreboardRefreshResponse
  >('/api/scoreboard/refresh/'),
};

export const Session = {
  currentSession: apiCall<
    messages.SessionCurrentSessionRequest,
    messages.SessionCurrentSessionResponse
  >('/api/session/currentSession/'),
  googleLogin: apiCall<
    messages.SessionGoogleLoginRequest,
    messages.SessionGoogleLoginResponse
  >('/api/session/googleLogin/'),
};

export const Tag = {
  frequentTags: apiCall<
    messages.TagFrequentTagsRequest,
    messages.TagFrequentTagsResponse
  >('/api/tag/frequentTags/'),
  list: apiCall<messages.TagListRequest, messages.TagListResponse>(
    '/api/tag/list/',
  ),
};

export const Time = {
  get: apiCall<messages.TimeGetRequest, messages.TimeGetResponse>(
    '/api/time/get/',
  ),
};

export const User = {
  acceptPrivacyPolicy: apiCall<
    messages.UserAcceptPrivacyPolicyRequest,
    messages.UserAcceptPrivacyPolicyResponse
  >('/api/user/acceptPrivacyPolicy/'),
  addExperiment: apiCall<
    messages.UserAddExperimentRequest,
    messages.UserAddExperimentResponse
  >('/api/user/addExperiment/'),
  addGroup: apiCall<
    messages.UserAddGroupRequest,
    messages.UserAddGroupResponse
  >('/api/user/addGroup/'),
  addRole: apiCall<messages.UserAddRoleRequest, messages.UserAddRoleResponse>(
    '/api/user/addRole/',
  ),
  associateIdentity: apiCall<
    messages.UserAssociateIdentityRequest,
    messages.UserAssociateIdentityResponse
  >('/api/user/associateIdentity/'),
  changePassword: apiCall<
    messages.UserChangePasswordRequest,
    messages.UserChangePasswordResponse
  >('/api/user/changePassword/'),
  coderOfTheMonth: apiCall<
    messages.UserCoderOfTheMonthRequest,
    messages._UserCoderOfTheMonthServerResponse,
    messages.UserCoderOfTheMonthResponse
  >('/api/user/coderOfTheMonth/', (x) => {
    if (x.coderinfo)
      x.coderinfo = ((x) => {
        if (x.birth_date)
          x.birth_date = ((x: number) => new Date(x * 1000))(x.birth_date);
        if (x.graduation_date)
          x.graduation_date = ((x: number) => new Date(x * 1000))(
            x.graduation_date,
          );
        return x;
      })(x.coderinfo);
    return x;
  }),
  coderOfTheMonthList: apiCall<
    messages.UserCoderOfTheMonthListRequest,
    messages.UserCoderOfTheMonthListResponse
  >('/api/user/coderOfTheMonthList/'),
  contestStats: apiCall<
    messages.UserContestStatsRequest,
    messages._UserContestStatsServerResponse,
    messages.UserContestStatsResponse
  >('/api/user/contestStats/', (x) => {
    x.contests = ((x) => {
      if (x instanceof Object) {
        Object.keys(x).forEach(
          (y) =>
            (x[y] = ((x) => {
              x.data = ((x) => {
                x.finish_time = ((x: number) => new Date(x * 1000))(
                  x.finish_time,
                );
                x.last_updated = ((x: number) => new Date(x * 1000))(
                  x.last_updated,
                );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              })(x.data);
              return x;
            })(x[y])),
        );
      }
      return x;
    })(x.contests);
    return x;
  }),
  create: apiCall<messages.UserCreateRequest, messages.UserCreateResponse>(
    '/api/user/create/',
  ),
  extraInformation: apiCall<
    messages.UserExtraInformationRequest,
    messages._UserExtraInformationServerResponse,
    messages.UserExtraInformationResponse
  >('/api/user/extraInformation/', (x) => {
    if (x.last_login)
      x.last_login = ((x: number) => new Date(x * 1000))(x.last_login);
    return x;
  }),
  generateGitToken: apiCall<
    messages.UserGenerateGitTokenRequest,
    messages.UserGenerateGitTokenResponse
  >('/api/user/generateGitToken/'),
  generateOmiUsers: apiCall<
    messages.UserGenerateOmiUsersRequest,
    messages.UserGenerateOmiUsersResponse
  >('/api/user/generateOmiUsers/'),
  interviewStats: apiCall<
    messages.UserInterviewStatsRequest,
    messages.UserInterviewStatsResponse
  >('/api/user/interviewStats/'),
  lastPrivacyPolicyAccepted: apiCall<
    messages.UserLastPrivacyPolicyAcceptedRequest,
    messages.UserLastPrivacyPolicyAcceptedResponse
  >('/api/user/lastPrivacyPolicyAccepted/'),
  list: apiCall<messages.UserListRequest, messages.UserListResponse>(
    '/api/user/list/',
  ),
  listAssociatedIdentities: apiCall<
    messages.UserListAssociatedIdentitiesRequest,
    messages.UserListAssociatedIdentitiesResponse
  >('/api/user/listAssociatedIdentities/'),
  listUnsolvedProblems: apiCall<
    messages.UserListUnsolvedProblemsRequest,
    messages.UserListUnsolvedProblemsResponse
  >('/api/user/listUnsolvedProblems/'),
  login: apiCall<messages.UserLoginRequest, messages.UserLoginResponse>(
    '/api/user/login/',
  ),
  mailingListBackfill: apiCall<
    messages.UserMailingListBackfillRequest,
    messages.UserMailingListBackfillResponse
  >('/api/user/mailingListBackfill/'),
  problemsCreated: apiCall<
    messages.UserProblemsCreatedRequest,
    messages.UserProblemsCreatedResponse
  >('/api/user/problemsCreated/'),
  problemsSolved: apiCall<
    messages.UserProblemsSolvedRequest,
    messages.UserProblemsSolvedResponse
  >('/api/user/problemsSolved/'),
  profile: apiCall<
    messages.UserProfileRequest,
    messages._UserProfileServerResponse,
    messages.UserProfileResponse
  >('/api/user/profile/', (x) => {
    if (x.birth_date)
      x.birth_date = ((x: number) => new Date(x * 1000))(x.birth_date);
    if (x.graduation_date)
      x.graduation_date = ((x: number) => new Date(x * 1000))(
        x.graduation_date,
      );
    return x;
  }),
  removeExperiment: apiCall<
    messages.UserRemoveExperimentRequest,
    messages.UserRemoveExperimentResponse
  >('/api/user/removeExperiment/'),
  removeGroup: apiCall<
    messages.UserRemoveGroupRequest,
    messages.UserRemoveGroupResponse
  >('/api/user/removeGroup/'),
  removeRole: apiCall<
    messages.UserRemoveRoleRequest,
    messages.UserRemoveRoleResponse
  >('/api/user/removeRole/'),
  selectCoderOfTheMonth: apiCall<
    messages.UserSelectCoderOfTheMonthRequest,
    messages.UserSelectCoderOfTheMonthResponse
  >('/api/user/selectCoderOfTheMonth/'),
  stats: apiCall<messages.UserStatsRequest, messages.UserStatsResponse>(
    '/api/user/stats/',
  ),
  statusVerified: apiCall<
    messages.UserStatusVerifiedRequest,
    messages.UserStatusVerifiedResponse
  >('/api/user/statusVerified/'),
  update: apiCall<messages.UserUpdateRequest, messages.UserUpdateResponse>(
    '/api/user/update/',
  ),
  updateBasicInfo: apiCall<
    messages.UserUpdateBasicInfoRequest,
    messages.UserUpdateBasicInfoResponse
  >('/api/user/updateBasicInfo/'),
  updateMainEmail: apiCall<
    messages.UserUpdateMainEmailRequest,
    messages.UserUpdateMainEmailResponse
  >('/api/user/updateMainEmail/'),
  validateFilter: apiCall<
    messages.UserValidateFilterRequest,
    messages.UserValidateFilterResponse
  >('/api/user/validateFilter/'),
  verifyEmail: apiCall<
    messages.UserVerifyEmailRequest,
    messages.UserVerifyEmailResponse
  >('/api/user/verifyEmail/'),
};
