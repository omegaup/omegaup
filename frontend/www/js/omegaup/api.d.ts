// generated by frontend/server/cmd/APITool.php. DO NOT EDIT.
namespace api {
  // Type aliases
  type UserListItem = { label: string; value: string };

  // ACL
  export interface ACL {}

  // Admin
  type AdminPlatformReportStatsRequest = any;
  type AdminPlatformReportStatsResponse = {
    report: {
      acceptedSubmissions: numeric;
      activeSchools: numeric;
      activeUsers: { [key: string]: numeric };
      courses: numeric;
      omiCourse: {
        attemptedUsers: numeric;
        completedUsers: numeric;
        passedUsers: numeric;
      };
    };
  };
  export interface Admin {
    platformReportStats: () => Promise<AdminPlatformReportStatsResponse>;
  }

  // Authorization
  type AuthorizationProblemRequest = any;
  type AuthorizationProblemResponse = {
    has_solved: boolean;
    is_admin: boolean;
    can_view: boolean;
    can_edit: boolean;
  };
  export interface Authorization {
    problem: () => Promise<AuthorizationProblemResponse>;
  }

  // Badge
  type BadgeBadgeDetailsRequest = any;
  type BadgeBadgeDetailsResponse = {
    first_assignation?: numeric;
    total_users: numeric;
    owners_count: numeric;
    status: string;
  };
  type BadgeListRequest = any;
  type BadgeListResponse = string[];
  type BadgeMyBadgeAssignationTimeRequest = any;
  type BadgeMyBadgeAssignationTimeResponse = {
    assignation_time?: numeric;
    status: string;
  };
  type BadgeMyListRequest = any;
  type BadgeMyListResponse = {
    badges: { assignation_time: string; badge_alias: string }[];
  };
  type BadgeUserListRequest = any;
  type BadgeUserListResponse = {
    badges: { assignation_time: string; badge_alias: string }[];
    status: string;
  };
  export interface Badge {
    badgeDetails: () => Promise<BadgeBadgeDetailsResponse>;
    list: () => Promise<BadgeListResponse>;
    myBadgeAssignationTime: () => Promise<BadgeMyBadgeAssignationTimeResponse>;
    myList: () => Promise<BadgeMyListResponse>;
    userList: () => Promise<BadgeUserListResponse>;
  }

  // Clarification
  type ClarificationCreateRequest = any;
  type ClarificationCreateResponse = { clarification_id: numeric };
  type ClarificationDetailsRequest = any;
  type ClarificationDetailsResponse = {
    message: string;
    answer?: string;
    time: numeric;
    problem_id: numeric;
    problemset_id?: numeric;
  };
  type ClarificationUpdateRequest = any;
  type ClarificationUpdateResponse = { status: string };
  export interface Clarification {
    create: () => Promise<ClarificationCreateResponse>;
    details: () => Promise<ClarificationDetailsResponse>;
    update: () => Promise<ClarificationUpdateResponse>;
  }

  // Contest
  type ContestActivityReportRequest = any;
  type ContestActivityReportResponse = {
    events: {
      username: string;
      ip: numeric;
      time: numeric;
      classname: string;
      alias: string;
    }[];
  };
  type ContestAddAdminRequest = any;
  type ContestAddAdminResponse = { status: string };
  type ContestAddGroupRequest = any;
  type ContestAddGroupResponse = { status: string };
  type ContestAddGroupAdminRequest = any;
  type ContestAddGroupAdminResponse = { status: string };
  type ContestAddProblemRequest = any;
  type ContestAddProblemResponse = { status: string };
  type ContestAddUserRequest = any;
  type ContestAddUserResponse = { status: string };
  type ContestAdminDetailsRequest = any;
  type ContestAdminDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    available_languages: { [key: string]: string };
    description: string;
    director?: string;
    feedback: string;
    finish_time: numeric;
    languages: string[];
    needs_basic_information: boolean;
    partial_score: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: numeric;
    penalty: numeric;
    penalty_calc_policy: string;
    penalty_type: string;
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      letter: string;
      order: numeric;
      points: numeric;
      problem_id: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
    }[];
    points_decay_factor: numeric;
    problemset_id: numeric;
    requests_user_information: string;
    rerun_id: numeric;
    scoreboard: numeric;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    show_scoreboard_after: boolean;
    start_time: numeric;
    submissions_gap: numeric;
    title: string;
    window_length?: numeric;
  };
  type ContestAdminListRequest = any;
  type ContestAdminListResponse = {
    contests: {
      admission_mode: string;
      alias: string;
      finish_time: numeric;
      rerun_id: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      start_time: numeric;
      title: string;
    }[];
  };
  type ContestAdminsRequest = any;
  type ContestAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  type ContestArbitrateRequestRequest = any;
  type ContestArbitrateRequestResponse = { status: string };
  type ContestClarificationsRequest = any;
  type ContestClarificationsResponse = {
    clarifications: {
      answer?: string;
      author: string;
      clarification_id: numeric;
      message: string;
      problem_alias: string;
      public: boolean;
      receiver?: string;
      time: numeric;
    }[];
  };
  type ContestCloneRequest = any;
  type ContestCloneResponse = { alias: string };
  type ContestContestantsRequest = any;
  type ContestContestantsResponse = {
    contestants: {
      name?: string;
      username: string;
      email?: string;
      state?: string;
      country?: string;
      school?: string;
    }[];
  };
  type ContestCreateRequest = any;
  type ContestCreateResponse = { status: string };
  type ContestCreateVirtualRequest = any;
  type ContestCreateVirtualResponse = { alias: string };
  type ContestCsvReportRequest = any;
  type ContestDetailsRequest = any;
  type ContestDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    description: string;
    director?: string;
    feedback: string;
    finish_time: numeric;
    languages: string[];
    needs_basic_information: boolean;
    opened: boolean;
    partial_score: boolean;
    original_contest_alias?: string;
    original_problemset_id?: numeric;
    penalty: numeric;
    penalty_calc_policy: string;
    penalty_type: string;
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      letter: string;
      order: numeric;
      points: numeric;
      problem_id: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
    }[];
    points_decay_factor: numeric;
    problemset_id: numeric;
    requests_user_information: string;
    scoreboard: numeric;
    show_scoreboard_after: boolean;
    start_time: numeric;
    submissions_gap: numeric;
    submission_deadline: numeric;
    title: string;
    window_length?: numeric;
  };
  type ContestDownloadRequest = any;
  type ContestListRequest = any;
  type ContestListResponse = {
    number_of_results: numeric;
    results: {
      admission_mode: string;
      alias: string;
      contest_id: numeric;
      description: string;
      finish_time: numeric;
      last_updated: numeric;
      original_finish_time: string;
      problemset_id: numeric;
      recommended: boolean;
      rerun_id: numeric;
      start_time: numeric;
      title: string;
      window_length?: numeric;
    }[];
  };
  type ContestListParticipatingRequest = any;
  type ContestListParticipatingResponse = {
    contests: {
      acl_id: numeric;
      admission_mode: string;
      alias: string;
      contest_id: numeric;
      description: string;
      feedback: string;
      finish_time: numeric;
      languages?: string;
      last_updated: numeric;
      original_finish_time: string;
      partial_score: numeric;
      penalty: numeric;
      penalty_calc_policy: string;
      penalty_type: string;
      points_decay_factor: numeric;
      problemset_id: numeric;
      recommended: boolean;
      rerun_id: numeric;
      scoreboard: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      show_scoreboard_after: numeric;
      start_time: numeric;
      submissions_gap: numeric;
      title: string;
      urgent: numeric;
      window_length?: numeric;
    }[];
  };
  type ContestMyListRequest = any;
  type ContestMyListResponse = {
    contests: {
      acl_id: numeric;
      admission_mode: string;
      alias: string;
      contest_id: numeric;
      description: string;
      feedback: string;
      finish_time: numeric;
      languages?: string;
      last_updated: numeric;
      original_finish_time: string;
      partial_score: numeric;
      penalty: numeric;
      penalty_calc_policy: string;
      penalty_type: string;
      points_decay_factor: numeric;
      problemset_id: numeric;
      recommended: boolean;
      rerun_id: numeric;
      scoreboard: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      show_scoreboard_after: numeric;
      start_time: numeric;
      submissions_gap: numeric;
      title: string;
      urgent: numeric;
      window_length?: numeric;
    }[];
  };
  type ContestOpenRequest = any;
  type ContestOpenResponse = { status: string };
  type ContestProblemsRequest = any;
  type ContestProblemsResponse = {
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      order: numeric;
      points: numeric;
      problem_id: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
    }[];
  };
  type ContestPublicDetailsRequest = any;
  type ContestPublicDetailsResponse = {
    admission_mode: string;
    alias: string;
    description: string;
    feedback: string;
    finish_time: numeric;
    languages: string;
    partial_score: boolean;
    penalty: numeric;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: numeric;
    problemset_id: numeric;
    rerun_id: numeric;
    scoreboard: numeric;
    show_scoreboard_after: boolean;
    start_time: numeric;
    submissions_gap: numeric;
    title: string;
    window_length?: numeric;
    user_registration_requested: boolean;
    user_registration_answered: boolean;
    user_registration_accepted?: boolean;
  };
  type ContestRegisterForContestRequest = any;
  type ContestRegisterForContestResponse = { status: string };
  type ContestRemoveAdminRequest = any;
  type ContestRemoveAdminResponse = { status: string };
  type ContestRemoveGroupRequest = any;
  type ContestRemoveGroupResponse = { status: string };
  type ContestRemoveGroupAdminRequest = any;
  type ContestRemoveGroupAdminResponse = { status: string };
  type ContestRemoveProblemRequest = any;
  type ContestRemoveProblemResponse = { status: string };
  type ContestRemoveUserRequest = any;
  type ContestRemoveUserResponse = { status: string };
  type ContestReportRequest = any;
  type ContestReportResponse = {
    finish_time?: numeric;
    problems: { alias: string; order: numeric }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: numeric;
      problems: {
        alias: string;
        penalty: numeric;
        percent: numeric;
        place: numeric;
        points: numeric;
        run_details: {
          cases: {
            contest_score: numeric;
            max_score: numeric;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: numeric;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: numeric; time: numeric; wall_time: numeric };
              }[];
            }[];
          };
        };
        runs: numeric;
      }[];
      total: { penalty: numeric; points: numeric };
      username: string;
    }[];
    start_time: numeric;
    time: numeric;
    title: string;
  };
  type ContestRequestsRequest = any;
  type ContestRequestsResponse = {
    users: {
      accepted?: boolean;
      admin: { username?: string };
      country?: string;
      last_update?: string;
      request_time: string;
      username: string;
    }[];
    contest_alias: string;
  };
  type ContestRoleRequest = any;
  type ContestRoleResponse = { status: string; admin: boolean };
  type ContestRunsRequest = any;
  type ContestRunsResponse = {
    runs: {
      run_id: numeric;
      guid: string;
      language: string;
      status: string;
      verdict: string;
      runtime: numeric;
      penalty: numeric;
      memory: numeric;
      score: numeric;
      contest_score: numeric;
      judged_by?: string;
      time: numeric;
      submit_delay: numeric;
      type?: string;
      username: string;
      alias: string;
      country_id?: string;
      contest_alias?: string;
    }[];
  };
  type ContestRunsDiffRequest = any;
  type ContestRunsDiffResponse = {
    diff: {
      guid: string;
      new_score?: numeric;
      new_status?: string;
      new_verdict?: string;
      old_score?: numeric;
      old_status?: string;
      old_verdict?: string;
      problemset_id?: numeric;
      username: string;
    }[];
  };
  type ContestScoreboardRequest = any;
  type ContestScoreboardResponse = {
    finish_time?: numeric;
    problems: { alias: string; order: numeric }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: numeric;
      problems: {
        alias: string;
        penalty: numeric;
        percent: numeric;
        place: numeric;
        points: numeric;
        run_details: {
          cases: {
            contest_score: numeric;
            max_score: numeric;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: numeric;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: numeric; time: numeric; wall_time: numeric };
              }[];
            }[];
          };
        };
        runs: numeric;
      }[];
      total: { penalty: numeric; points: numeric };
      username: string;
    }[];
    start_time: numeric;
    time: numeric;
    title: string;
  };
  type ContestScoreboardEventsRequest = any;
  type ContestScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: numeric;
      is_invited: boolean;
      total: { points: numeric; penalty: numeric };
      name?: string;
      username: string;
      problem: { alias: string; points: numeric; penalty: numeric };
    }[];
  };
  type ContestScoreboardMergeRequest = any;
  type ContestScoreboardMergeResponse = {
    ranking: {
      name?: string;
      username: string;
      contests: { [key: string]: { points: numeric; penalty: numeric } };
      total: { points: numeric; penalty: numeric };
    }[];
  };
  type ContestSetRecommendedRequest = any;
  type ContestSetRecommendedResponse = { status: string };
  type ContestStatsRequest = any;
  type ContestStatsResponse = {
    total_runs: numeric;
    pending_runs: string[];
    max_wait_time: numeric;
    max_wait_time_guid?: string;
    verdict_counts: { [key: string]: numeric };
    distribution: { [key: int]: numeric };
    size_of_bucket: numeric;
    total_points: numeric;
  };
  type ContestUpdateRequest = any;
  type ContestUpdateResponse = { status: string };
  type ContestUpdateEndTimeForIdentityRequest = any;
  type ContestUpdateEndTimeForIdentityResponse = { status: string };
  type ContestUsersRequest = any;
  type ContestUsersResponse = {
    users: {
      access_time?: numeric;
      country_id?: string;
      end_time?: numeric;
      is_owner?: numeric;
      username: string;
    }[];
    groups: { alias: string; name: string }[];
  };
  export interface Contest {
    activityReport: () => Promise<ContestActivityReportResponse>;
    addAdmin: () => Promise<ContestAddAdminResponse>;
    addGroup: () => Promise<ContestAddGroupResponse>;
    addGroupAdmin: () => Promise<ContestAddGroupAdminResponse>;
    addProblem: () => Promise<ContestAddProblemResponse>;
    addUser: () => Promise<ContestAddUserResponse>;
    adminDetails: () => Promise<ContestAdminDetailsResponse>;
    adminList: () => Promise<ContestAdminListResponse>;
    admins: () => Promise<ContestAdminsResponse>;
    arbitrateRequest: () => Promise<ContestArbitrateRequestResponse>;
    clarifications: () => Promise<ContestClarificationsResponse>;
    clone: () => Promise<ContestCloneResponse>;
    contestants: () => Promise<ContestContestantsResponse>;
    create: () => Promise<ContestCreateResponse>;
    createVirtual: () => Promise<ContestCreateVirtualResponse>;
    csvReport: () => Promise<void>;
    details: () => Promise<ContestDetailsResponse>;
    download: () => Promise<void>;
    list: () => Promise<ContestListResponse>;
    listParticipating: () => Promise<ContestListParticipatingResponse>;
    myList: () => Promise<ContestMyListResponse>;
    open: () => Promise<ContestOpenResponse>;
    problems: () => Promise<ContestProblemsResponse>;
    publicDetails: () => Promise<ContestPublicDetailsResponse>;
    registerForContest: () => Promise<ContestRegisterForContestResponse>;
    removeAdmin: () => Promise<ContestRemoveAdminResponse>;
    removeGroup: () => Promise<ContestRemoveGroupResponse>;
    removeGroupAdmin: () => Promise<ContestRemoveGroupAdminResponse>;
    removeProblem: () => Promise<ContestRemoveProblemResponse>;
    removeUser: () => Promise<ContestRemoveUserResponse>;
    report: () => Promise<ContestReportResponse>;
    requests: () => Promise<ContestRequestsResponse>;
    role: () => Promise<ContestRoleResponse>;
    runs: () => Promise<ContestRunsResponse>;
    runsDiff: () => Promise<ContestRunsDiffResponse>;
    scoreboard: () => Promise<ContestScoreboardResponse>;
    scoreboardEvents: () => Promise<ContestScoreboardEventsResponse>;
    scoreboardMerge: () => Promise<ContestScoreboardMergeResponse>;
    setRecommended: () => Promise<ContestSetRecommendedResponse>;
    stats: () => Promise<ContestStatsResponse>;
    update: () => Promise<ContestUpdateResponse>;
    updateEndTimeForIdentity: () => Promise<
      ContestUpdateEndTimeForIdentityResponse
    >;
    users: () => Promise<ContestUsersResponse>;
  }

  // Controller
  export interface Controller {}

  // Course
  type CourseActivityReportRequest = any;
  type CourseActivityReportResponse = {
    events: {
      username: string;
      ip: numeric;
      time: numeric;
      classname: string;
      alias: string;
    }[];
  };
  type CourseAddAdminRequest = any;
  type CourseAddAdminResponse = { status: string };
  type CourseAddGroupAdminRequest = any;
  type CourseAddGroupAdminResponse = { status: string };
  type CourseAddProblemRequest = any;
  type CourseAddProblemResponse = { status: string };
  type CourseAddStudentRequest = any;
  type CourseAddStudentResponse = { status: string };
  type CourseAdminDetailsRequest = any;
  type CourseAdminDetailsResponse = {
    name: string;
    description: string;
    alias: string;
    basic_information_required: boolean;
    requests_user_information: string;
    assignments: {
      name: string;
      description: string;
      alias: string;
      publish_time_delay?: numeric;
      assignment_type: string;
      start_time: numeric;
      finish_time?: numeric;
      max_points: numeric;
      order: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
    }[];
    school_id?: numeric;
    start_time: numeric;
    finish_time?: numeric;
    is_admin: boolean;
    public: boolean;
    show_scoreboard: boolean;
    student_count: numeric;
    school_name?: string;
  };
  type CourseAdminsRequest = any;
  type CourseAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  type CourseArbitrateRequestRequest = any;
  type CourseArbitrateRequestResponse = { status: string };
  type CourseAssignmentDetailsRequest = any;
  type CourseAssignmentDetailsResponse = {
    name?: string;
    description?: string;
    assignment_type?: string;
    start_time: numeric;
    finish_time?: numeric;
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      order: numeric;
      points: numeric;
      problem_id: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
    }[];
    director: string;
    problemset_id: numeric;
    admin: boolean;
  };
  type CourseAssignmentScoreboardRequest = any;
  type CourseAssignmentScoreboardResponse = {
    finish_time?: numeric;
    problems: { alias: string; order: numeric }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: numeric;
      problems: {
        alias: string;
        penalty: numeric;
        percent: numeric;
        place: numeric;
        points: numeric;
        run_details: {
          cases: {
            contest_score: numeric;
            max_score: numeric;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: numeric;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: numeric; time: numeric; wall_time: numeric };
              }[];
            }[];
          };
        };
        runs: numeric;
      }[];
      total: { penalty: numeric; points: numeric };
      username: string;
    }[];
    start_time: numeric;
    time: numeric;
    title: string;
  };
  type CourseAssignmentScoreboardEventsRequest = any;
  type CourseAssignmentScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: numeric;
      is_invited: boolean;
      name?: string;
      problem: { alias: string; penalty: numeric; points: numeric };
      total: { penalty: numeric; points: numeric };
      username: string;
    }[];
  };
  type CourseCloneRequest = any;
  type CourseCloneResponse = { alias: string };
  type CourseCreateRequest = any;
  type CourseCreateResponse = { status: string };
  type CourseCreateAssignmentRequest = any;
  type CourseCreateAssignmentResponse = { status: string };
  type CourseDetailsRequest = any;
  type CourseDetailsResponse = {
    name: string;
    description: string;
    alias: string;
    basic_information_required: boolean;
    requests_user_information: string;
    assignments: {
      name: string;
      description: string;
      alias: string;
      publish_time_delay?: numeric;
      assignment_type: string;
      start_time: numeric;
      finish_time?: numeric;
      max_points: numeric;
      order: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
    }[];
    school_id?: numeric;
    start_time: numeric;
    finish_time?: numeric;
    is_admin: boolean;
    public: boolean;
    show_scoreboard: boolean;
    student_count: numeric;
    school_name?: string;
  };
  type CourseGetProblemUsersRequest = any;
  type CourseGetProblemUsersResponse = { identities: string[] };
  type CourseIntroDetailsRequest = any;
  type CourseIntroDetailsResponse = {
    name: string;
    description: string;
    alias: string;
    currentUsername: string;
    needsBasicInformation: boolean;
    requestsUserInformation: string;
    shouldShowAcceptTeacher: boolean;
    statements: {
      privacy: {
        markdown?: string;
        gitObjectId?: string;
        statementType?: string;
      };
      acceptTeacher: {
        gitObjectId?: string;
        markdown: string;
        statementType: string;
      };
    };
    isFirstTimeAccess: boolean;
    shouldShowResults: boolean;
  };
  type CourseListAssignmentsRequest = any;
  type CourseListAssignmentsResponse = {
    assignments: {
      alias: string;
      assignment_type: string;
      description: string;
      finish_time?: numeric;
      has_runs: boolean;
      name: string;
      order: numeric;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      start_time: numeric;
    }[];
  };
  type CourseListCoursesRequest = any;
  type CourseListCoursesResponse = {
    admin: {
      alias: string;
      counts: { [key: string]: numeric };
      finish_time?: numeric;
      name: string;
      start_time: numeric;
    }[];
    public: {
      alias: string;
      counts: { [key: string]: numeric };
      finish_time?: numeric;
      name: string;
      start_time: numeric;
    }[];
    student: {
      alias: string;
      counts: { [key: string]: numeric };
      finish_time?: numeric;
      name: string;
      start_time: numeric;
    }[];
  };
  type CourseListSolvedProblemsRequest = any;
  type CourseListSolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  type CourseListStudentsRequest = any;
  type CourseListStudentsResponse = {
    students: {
      name?: string;
      progress: { [key: string]: numeric };
      username: string;
    }[];
  };
  type CourseListUnsolvedProblemsRequest = any;
  type CourseListUnsolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  type CourseMyProgressRequest = any;
  type CourseMyProgressResponse = {
    assignments: { [key: string]: { score: numeric; max_score: numeric } };
  };
  type CourseRegisterForCourseRequest = any;
  type CourseRegisterForCourseResponse = { status: string };
  type CourseRemoveAdminRequest = any;
  type CourseRemoveAdminResponse = { status: string };
  type CourseRemoveAssignmentRequest = any;
  type CourseRemoveGroupAdminRequest = any;
  type CourseRemoveGroupAdminResponse = { status: string };
  type CourseRemoveProblemRequest = any;
  type CourseRemoveProblemResponse = { status: string };
  type CourseRemoveStudentRequest = any;
  type CourseRemoveStudentResponse = { status: string };
  type CourseRequestsRequest = any;
  type CourseRequestsResponse = {
    users: {
      accepted?: boolean;
      admin: { name?: string; user_id?: numeric; username?: string };
      country?: string;
      country_id?: string;
      course_id: numeric;
      identity_id: numeric;
      last_update?: string;
      request_time: string;
      user_id?: numeric;
      username: string;
    }[];
  };
  type CourseRunsRequest = any;
  type CourseRunsResponse = {
    runs: {
      run_id: numeric;
      guid: string;
      language: string;
      status: string;
      verdict: string;
      runtime: numeric;
      penalty: numeric;
      memory: numeric;
      score: numeric;
      contest_score: numeric;
      judged_by?: string;
      time: numeric;
      submit_delay: numeric;
      type?: string;
      username: string;
      alias: string;
      country_id?: string;
      contest_alias?: string;
    }[];
  };
  type CourseStudentProgressRequest = any;
  type CourseStudentProgressResponse = {
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      letter: string;
      order: numeric;
      points: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
      runs: {
        guid: string;
        language: string;
        source: string;
        status: string;
        verdict: string;
        runtime: numeric;
        penalty: numeric;
        memory: numeric;
        score: numeric;
        contest_score?: numeric;
        time: numeric;
        submit_delay: numeric;
      }[];
    }[];
  };
  type CourseUpdateRequest = any;
  type CourseUpdateResponse = { status: string };
  type CourseUpdateAssignmentRequest = any;
  type CourseUpdateAssignmentResponse = { status: string };
  type CourseUpdateAssignmentsOrderRequest = any;
  type CourseUpdateAssignmentsOrderResponse = { status: string };
  type CourseUpdateProblemsOrderRequest = any;
  type CourseUpdateProblemsOrderResponse = { status: string };
  export interface Course {
    activityReport: () => Promise<CourseActivityReportResponse>;
    addAdmin: () => Promise<CourseAddAdminResponse>;
    addGroupAdmin: () => Promise<CourseAddGroupAdminResponse>;
    addProblem: () => Promise<CourseAddProblemResponse>;
    addStudent: () => Promise<CourseAddStudentResponse>;
    adminDetails: () => Promise<CourseAdminDetailsResponse>;
    admins: () => Promise<CourseAdminsResponse>;
    arbitrateRequest: () => Promise<CourseArbitrateRequestResponse>;
    assignmentDetails: () => Promise<CourseAssignmentDetailsResponse>;
    assignmentScoreboard: () => Promise<CourseAssignmentScoreboardResponse>;
    assignmentScoreboardEvents: () => Promise<
      CourseAssignmentScoreboardEventsResponse
    >;
    clone: () => Promise<CourseCloneResponse>;
    create: () => Promise<CourseCreateResponse>;
    createAssignment: () => Promise<CourseCreateAssignmentResponse>;
    details: () => Promise<CourseDetailsResponse>;
    getProblemUsers: () => Promise<CourseGetProblemUsersResponse>;
    introDetails: () => Promise<CourseIntroDetailsResponse>;
    listAssignments: () => Promise<CourseListAssignmentsResponse>;
    listCourses: () => Promise<CourseListCoursesResponse>;
    listSolvedProblems: () => Promise<CourseListSolvedProblemsResponse>;
    listStudents: () => Promise<CourseListStudentsResponse>;
    listUnsolvedProblems: () => Promise<CourseListUnsolvedProblemsResponse>;
    myProgress: () => Promise<CourseMyProgressResponse>;
    registerForCourse: () => Promise<CourseRegisterForCourseResponse>;
    removeAdmin: () => Promise<CourseRemoveAdminResponse>;
    removeAssignment: () => Promise<void>;
    removeGroupAdmin: () => Promise<CourseRemoveGroupAdminResponse>;
    removeProblem: () => Promise<CourseRemoveProblemResponse>;
    removeStudent: () => Promise<CourseRemoveStudentResponse>;
    requests: () => Promise<CourseRequestsResponse>;
    runs: () => Promise<CourseRunsResponse>;
    studentProgress: () => Promise<CourseStudentProgressResponse>;
    update: () => Promise<CourseUpdateResponse>;
    updateAssignment: () => Promise<CourseUpdateAssignmentResponse>;
    updateAssignmentsOrder: () => Promise<CourseUpdateAssignmentsOrderResponse>;
    updateProblemsOrder: () => Promise<CourseUpdateProblemsOrderResponse>;
  }

  // Grader
  type GraderStatusRequest = any;
  type GraderStatusResponse = {
    grader: {
      status: string;
      broadcaster_sockets: numeric;
      embedded_runner: boolean;
      queue: {
        running: { name: string; id: numeric }[];
        run_queue_length: numeric;
        runner_queue_length: numeric;
        runners: string[];
      };
    };
  };
  export interface Grader {
    status: () => Promise<GraderStatusResponse>;
  }

  // Group
  type GroupAddUserRequest = any;
  type GroupAddUserResponse = { status: string };
  type GroupCreateRequest = any;
  type GroupCreateResponse = { status: string };
  type GroupCreateScoreboardRequest = any;
  type GroupCreateScoreboardResponse = { status: string };
  type GroupDetailsRequest = any;
  type GroupDetailsResponse = {
    exists: boolean;
    group: {
      create_time: numeric;
      alias?: string;
      name?: string;
      description?: string;
    };
    scoreboards: {
      alias: string;
      create_time: string;
      description?: string;
      name: string;
    }[];
  };
  type GroupListRequest = any;
  type GroupListResponse = { label: string; value: string }[];
  type GroupMembersRequest = any;
  type GroupMembersResponse = {
    identities: {
      classname: string;
      country?: string;
      country_id?: string;
      name?: string;
      school?: string;
      school_id?: numeric;
      state?: string;
      state_id?: string;
      username: string;
    }[];
  };
  type GroupMyListRequest = any;
  type GroupMyListResponse = {
    groups: {
      alias: string;
      create_time: numeric;
      description?: string;
      name: string;
    }[];
  };
  type GroupRemoveUserRequest = any;
  type GroupRemoveUserResponse = { status: string };
  export interface Group {
    addUser: () => Promise<GroupAddUserResponse>;
    create: () => Promise<GroupCreateResponse>;
    createScoreboard: () => Promise<GroupCreateScoreboardResponse>;
    details: () => Promise<GroupDetailsResponse>;
    list: () => Promise<GroupListResponse>;
    members: () => Promise<GroupMembersResponse>;
    myList: () => Promise<GroupMyListResponse>;
    removeUser: () => Promise<GroupRemoveUserResponse>;
  }

  // GroupScoreboard
  type GroupScoreboardAddContestRequest = any;
  type GroupScoreboardAddContestResponse = { status: string };
  type GroupScoreboardDetailsRequest = any;
  type GroupScoreboardDetailsResponse = {
    ranking: {
      name?: string;
      username: string;
      contests: { [key: string]: { points: numeric; penalty: numeric } };
      total: { points: numeric; penalty: numeric };
    }[];
    scoreboard: {
      group_scoreboard_id: numeric;
      group_id: numeric;
      create_time: numeric;
      alias: string;
      name: string;
      description: string;
    };
    contests: {
      contest_id: numeric;
      problemset_id: numeric;
      acl_id: numeric;
      title: string;
      description: string;
      start_time: numeric;
      finish_time: numeric;
      last_updated: numeric;
      window_length?: numeric;
      rerun_id: numeric;
      admission_mode: string;
      alias: string;
      scoreboard: numeric;
      points_decay_factor: numeric;
      partial_score: boolean;
      submissions_gap: numeric;
      feedback: string;
      penalty: string;
      penalty_calc_policy: string;
      show_scoreboard_after: boolean;
      urgent: boolean;
      languages: string;
      recommended: boolean;
      only_ac: boolean;
      weight: numeric;
    }[];
  };
  type GroupScoreboardListRequest = any;
  type GroupScoreboardListResponse = {
    scoreboards: {
      group_scoreboard_id: numeric;
      group_id: numeric;
      create_time: numeric;
      alias: string;
      name: string;
      description: string;
    }[];
  };
  type GroupScoreboardRemoveContestRequest = any;
  type GroupScoreboardRemoveContestResponse = { status: string };
  export interface GroupScoreboard {
    addContest: () => Promise<GroupScoreboardAddContestResponse>;
    details: () => Promise<GroupScoreboardDetailsResponse>;
    list: () => Promise<GroupScoreboardListResponse>;
    removeContest: () => Promise<GroupScoreboardRemoveContestResponse>;
  }

  // Identity
  type IdentityBulkCreateRequest = any;
  type IdentityBulkCreateResponse = { status: string };
  type IdentityChangePasswordRequest = any;
  type IdentityChangePasswordResponse = { status: string };
  type IdentityCreateRequest = any;
  type IdentityCreateResponse = { username: string };
  type IdentityUpdateRequest = any;
  type IdentityUpdateResponse = { status: string };
  export interface Identity {
    bulkCreate: () => Promise<IdentityBulkCreateResponse>;
    changePassword: () => Promise<IdentityChangePasswordResponse>;
    create: () => Promise<IdentityCreateResponse>;
    update: () => Promise<IdentityUpdateResponse>;
  }

  // Interview
  type InterviewAddUsersRequest = any;
  type InterviewAddUsersResponse = { status: string };
  type InterviewCreateRequest = any;
  type InterviewCreateResponse = { status: string };
  type InterviewDetailsRequest = any;
  type InterviewDetailsResponse = {
    description?: string;
    contest_alias?: string;
    problemset_id?: numeric;
    users: {
      user_id?: numeric;
      username: string;
      access_time?: string;
      email?: string;
      opened_interview: boolean;
      country?: string;
    }[];
    exists: boolean;
  };
  type InterviewListRequest = any;
  type InterviewListResponse = {
    result: {
      acl_id: numeric;
      alias: string;
      description: string;
      interview_id: numeric;
      problemset_id: numeric;
      title: string;
      window_length: numeric;
    }[];
  };
  export interface Interview {
    addUsers: () => Promise<InterviewAddUsersResponse>;
    create: () => Promise<InterviewCreateResponse>;
    details: () => Promise<InterviewDetailsResponse>;
    list: () => Promise<InterviewListResponse>;
  }

  // Notification
  type NotificationMyListRequest = any;
  type NotificationMyListResponse = {
    notifications: {
      contents: string;
      notification_id: numeric;
      timestamp: numeric;
    }[];
  };
  type NotificationReadNotificationsRequest = any;
  type NotificationReadNotificationsResponse = { status: string };
  export interface Notification {
    myList: () => Promise<NotificationMyListResponse>;
    readNotifications: () => Promise<NotificationReadNotificationsResponse>;
  }

  // Problem
  type ProblemAddAdminRequest = any;
  type ProblemAddAdminResponse = { status: string };
  type ProblemAddGroupAdminRequest = any;
  type ProblemAddGroupAdminResponse = { status: string };
  type ProblemAddTagRequest = any;
  type ProblemAddTagResponse = { name: string };
  type ProblemAdminListRequest = any;
  type ProblemAdminListResponse = {
    pagerItems: { class: string; label: string; url: string }[];
    problems: { tags: { name: string; source: string }[] }[];
  };
  type ProblemAdminsRequest = any;
  type ProblemAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  type ProblemBestScoreRequest = any;
  type ProblemBestScoreResponse = { score: numeric };
  type ProblemClarificationsRequest = any;
  type ProblemClarificationsResponse = {
    clarifications: {
      clarification_id: numeric;
      contest_alias: string;
      author?: string;
      message: string;
      time: numeric;
      answer?: string;
      public: boolean;
    }[];
  };
  type ProblemCreateRequest = any;
  type ProblemCreateResponse = { status: string };
  type ProblemDeleteRequest = any;
  type ProblemDeleteResponse = { status: string };
  type ProblemDetailsRequest = any;
  type ProblemDetailsResponse = {
    accepted: numeric;
    admin: boolean;
    alias: string;
    commit: string;
    creation_date: numeric;
    difficulty?: numeric;
    email_clarifications: boolean;
    exists: boolean;
    input_limit: numeric;
    languages: string[];
    order: string;
    points: numeric;
    preferred_language: string;
    problemsetter: { creation_date: numeric; name: string; username: string };
    quality_seal: boolean;
    runs: {
      alias: string;
      contest_score?: numeric;
      guid: string;
      language: string;
      memory: numeric;
      penalty: numeric;
      runtime: numeric;
      score: numeric;
      status: string;
      submit_delay: numeric;
      time: numeric;
      username: string;
      verdict: string;
    }[];
    score: numeric;
    settings: {
      cases: { [key: string]: { in: string; out: string; weight: numeric } };
      limits: {
        MemoryLimit: numeric | string;
        OverallWallTimeLimit: string;
        TimeLimit: string;
      };
      validator: { name: string; tolerance: numeric };
    };
    solvers: {
      language: string;
      memory: numeric;
      runtime: numeric;
      time: numeric;
      username: string;
    }[];
    source: string;
    statement: {
      images: { [key: string]: string };
      language: string;
      markdown: string;
    };
    submissions: numeric;
    title: string;
    version: string;
    visibility: numeric;
    visits: numeric;
  };
  type ProblemDownloadRequest = any;
  type ProblemImageRequest = any;
  type ProblemListRequest = any;
  type ProblemListResponse = {
    results: {
      alias: string;
      difficulty?: numeric;
      difficulty_histogram: numeric[];
      points: numeric;
      quality?: numeric;
      quality_histogram: numeric[];
      ratio: numeric;
      score: numeric;
      tags: { source: string; name: string }[];
      title: string;
      visibility: numeric;
      quality_seal: boolean;
    }[];
    total: numeric;
  };
  type ProblemMyListRequest = any;
  type ProblemMyListResponse = {
    pagerItems: { class: string; label: string; url: string }[];
    problems: { tags: { name: string; source: string }[] }[];
  };
  type ProblemRejudgeRequest = any;
  type ProblemRejudgeResponse = { status: string };
  type ProblemRemoveAdminRequest = any;
  type ProblemRemoveAdminResponse = { status: string };
  type ProblemRemoveGroupAdminRequest = any;
  type ProblemRemoveGroupAdminResponse = { status: string };
  type ProblemRemoveTagRequest = any;
  type ProblemRemoveTagResponse = { status: string };
  type ProblemRunsRequest = any;
  type ProblemRunsResponse = {
    runs: {
      guid: string;
      language: string;
      status: string;
      verdict: string;
      runtime: numeric;
      penalty: numeric;
      memory: numeric;
      score: numeric;
      contest_score?: numeric;
      time: numeric;
      submit_delay: numeric;
      alias: string;
      username: string;
      run_id: numeric;
      judged_by?: string;
      type?: string;
      country_id?: string;
      contest_alias?: string;
    }[];
  };
  type ProblemRunsDiffRequest = any;
  type ProblemRunsDiffResponse = {
    diff: {
      username: string;
      guid: string;
      problemset_id?: numeric;
      old_status?: string;
      old_verdict?: string;
      old_score?: numeric;
      new_status?: string;
      new_verdict?: string;
      new_score?: numeric;
    }[];
  };
  type ProblemSelectVersionRequest = any;
  type ProblemSelectVersionResponse = { status: string };
  type ProblemSolutionRequest = any;
  type ProblemSolutionResponse = {
    exists: boolean;
    solution: {
      language: string;
      markdown: string;
      images: { [key: string]: string };
    };
  };
  type ProblemStatsRequest = any;
  type ProblemStatsResponse = {
    cases_stats: { [key: string]: numeric };
    pending_runs: { guid: string }[];
    total_runs: numeric;
    verdict_counts: { [key: string]: numeric };
  };
  type ProblemTagsRequest = any;
  type ProblemTagsResponse = { tags: { name: string; public: boolean }[] };
  type ProblemTemplateRequest = any;
  type ProblemUpdateRequest = any;
  type ProblemUpdateResponse = { rejudged: boolean };
  type ProblemUpdateSolutionRequest = any;
  type ProblemUpdateSolutionResponse = { status: string };
  type ProblemUpdateStatementRequest = any;
  type ProblemUpdateStatementResponse = { status: string };
  type ProblemVersionsRequest = any;
  type ProblemVersionsResponse = {
    published?: string;
    log: {
      commit: string;
      tree?: { [key: string]: string };
      parents: string[];
      author: { name: string; email: string; time?: numeric | string };
      committer: { name: string; email: string; time?: numeric | string };
      message: string;
      version?: string;
    }[];
  };
  export interface Problem {
    addAdmin: () => Promise<ProblemAddAdminResponse>;
    addGroupAdmin: () => Promise<ProblemAddGroupAdminResponse>;
    addTag: () => Promise<ProblemAddTagResponse>;
    adminList: () => Promise<ProblemAdminListResponse>;
    admins: () => Promise<ProblemAdminsResponse>;
    bestScore: () => Promise<ProblemBestScoreResponse>;
    clarifications: () => Promise<ProblemClarificationsResponse>;
    create: () => Promise<ProblemCreateResponse>;
    delete: () => Promise<ProblemDeleteResponse>;
    details: () => Promise<ProblemDetailsResponse>;
    download: () => Promise<void>;
    image: () => Promise<void>;
    list: () => Promise<ProblemListResponse>;
    myList: () => Promise<ProblemMyListResponse>;
    rejudge: () => Promise<ProblemRejudgeResponse>;
    removeAdmin: () => Promise<ProblemRemoveAdminResponse>;
    removeGroupAdmin: () => Promise<ProblemRemoveGroupAdminResponse>;
    removeTag: () => Promise<ProblemRemoveTagResponse>;
    runs: () => Promise<ProblemRunsResponse>;
    runsDiff: () => Promise<ProblemRunsDiffResponse>;
    selectVersion: () => Promise<ProblemSelectVersionResponse>;
    solution: () => Promise<ProblemSolutionResponse>;
    stats: () => Promise<ProblemStatsResponse>;
    tags: () => Promise<ProblemTagsResponse>;
    template: () => Promise<void>;
    update: () => Promise<ProblemUpdateResponse>;
    updateSolution: () => Promise<ProblemUpdateSolutionResponse>;
    updateStatement: () => Promise<ProblemUpdateStatementResponse>;
    versions: () => Promise<ProblemVersionsResponse>;
  }

  // ProblemForfeited
  type ProblemForfeitedGetCountsRequest = any;
  type ProblemForfeitedGetCountsResponse = { allowed: numeric; seen: numeric };
  export interface ProblemForfeited {
    getCounts: () => Promise<ProblemForfeitedGetCountsResponse>;
  }

  // Problemset
  type ProblemsetDetailsRequest = any;
  type ProblemsetDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    assignment_type?: string;
    contest_alias?: string;
    description?: string;
    director?: string | omegaup.dao.Identities;
    exists: boolean;
    feedback: string;
    finish_time?: numeric;
    languages: string[];
    name?: string;
    needs_basic_information: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: numeric;
    partial_score: boolean;
    penalty: numeric;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: numeric;
    problems: {
      accepted: numeric;
      alias: string;
      commit: string;
      difficulty: numeric;
      languages: string;
      letter: string;
      order: numeric;
      points: numeric;
      problem_id: numeric;
      submissions: numeric;
      title: string;
      version: string;
      visibility: numeric;
      visits: numeric;
    }[];
    problemset_id?: numeric;
    requests_user_information: string;
    scoreboard: numeric;
    show_scoreboard_after: boolean;
    start_time: numeric;
    submission_deadline: numeric;
    submissions_gap: numeric;
    title: string;
    users: {
      access_time?: string;
      country?: string;
      email?: string;
      opened_interview: boolean;
      user_id?: numeric;
      username: string;
    }[];
    window_length?: numeric;
  };
  type ProblemsetScoreboardRequest = any;
  type ProblemsetScoreboardResponse = {
    finish_time?: numeric;
    problems: { alias: string; order: numeric }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: numeric;
      problems: {
        alias: string;
        penalty: numeric;
        percent: numeric;
        place: numeric;
        points: numeric;
        run_details: {
          cases: {
            contest_score: numeric;
            max_score: numeric;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: numeric;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: numeric; time: numeric; wall_time: numeric };
              }[];
            }[];
          };
        };
        runs: numeric;
      }[];
      total: { penalty: numeric; points: numeric };
      username: string;
    }[];
    start_time: numeric;
    time: numeric;
    title: string;
  };
  type ProblemsetScoreboardEventsRequest = any;
  type ProblemsetScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: numeric;
      is_invited: boolean;
      total: { points: numeric; penalty: numeric };
      name?: string;
      username: string;
      problem: { alias: string; points: numeric; penalty: numeric };
    }[];
  };
  export interface Problemset {
    details: () => Promise<ProblemsetDetailsResponse>;
    scoreboard: () => Promise<ProblemsetScoreboardResponse>;
    scoreboardEvents: () => Promise<ProblemsetScoreboardEventsResponse>;
  }

  // QualityNomination
  type QualityNominationCreateRequest = any;
  type QualityNominationCreateResponse = { qualitynomination_id: numeric };
  type QualityNominationDetailsRequest = any;
  type QualityNominationDetailsResponse = {
    author: { name?: string; username: string };
    contents: {
      before_ac: boolean;
      difficulty: numeric;
      quality: numeric;
      rationale: string;
      reason: string;
      statements: { [key: string]: string };
      tags: string[];
    };
    nomination: string;
    nomination_status: string;
    nominator: { name?: string; username: string };
    original_contents: {
      source?: string;
      statements: {
        [key: string]: {
          language: string;
          markdown: string;
          images: { [key: string]: string };
        };
      };
      tags: { source: string; name: string }[];
    };
    problem: { alias: string; title: string };
    qualitynomination_id: numeric;
    reviewer: boolean;
    time: numeric;
    votes: {
      time?: numeric;
      user: { name?: string; username: string };
      vote: numeric;
    }[];
  };
  type QualityNominationListRequest = any;
  type QualityNominationListResponse = {
    totalRows: numeric;
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: numeric;
            quality: numeric;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: numeric;
          status: string;
          time: numeric;
          votes: {
            time?: numeric;
            user: { name?: string; username: string };
            vote: numeric;
          }[];
        }
      | null[];
  };
  type QualityNominationMyAssignedListRequest = any;
  type QualityNominationMyAssignedListResponse = {
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: numeric;
            quality: numeric;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: numeric;
          status: string;
          time: numeric;
          votes: {
            time?: numeric;
            user: { name?: string; username: string };
            vote: numeric;
          }[];
        }
      | null[];
  };
  type QualityNominationMyListRequest = any;
  type QualityNominationMyListResponse = {
    totalRows: numeric;
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: numeric;
            quality: numeric;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: numeric;
          status: string;
          time: numeric;
          votes: {
            time?: numeric;
            user: { name?: string; username: string };
            vote: numeric;
          }[];
        }
      | null[];
  };
  type QualityNominationResolveRequest = any;
  type QualityNominationResolveResponse = { status: string };
  export interface QualityNomination {
    create: () => Promise<QualityNominationCreateResponse>;
    details: () => Promise<QualityNominationDetailsResponse>;
    list: () => Promise<QualityNominationListResponse>;
    myAssignedList: () => Promise<QualityNominationMyAssignedListResponse>;
    myList: () => Promise<QualityNominationMyListResponse>;
    resolve: () => Promise<QualityNominationResolveResponse>;
  }

  // Reset
  type ResetCreateRequest = any;
  type ResetCreateResponse = { message: string; token: string };
  type ResetGenerateTokenRequest = any;
  type ResetGenerateTokenResponse = { link: string; token: string };
  type ResetUpdateRequest = any;
  type ResetUpdateResponse = { message: string };
  export interface Reset {
    create: () => Promise<ResetCreateResponse>;
    generateToken: () => Promise<ResetGenerateTokenResponse>;
    update: () => Promise<ResetUpdateResponse>;
  }

  // Run
  type RunCountsRequest = any;
  type RunCountsResponse = {
    total: { [key: string]: numeric };
    ac: { [key: string]: numeric };
  };
  type RunCreateRequest = any;
  type RunCreateResponse = {
    guid: string;
    submission_deadline: numeric;
    nextSubmissionTimestamp: numeric;
  };
  type RunDetailsRequest = any;
  type RunDetailsResponse = {
    admin: boolean;
    compile_error: string;
    details: {
      compile_meta: {
        [key: string]: {
          memory: numeric;
          sys_time: numeric;
          time: numeric;
          verdict: string;
          wall_time: numeric;
        };
      };
      contest_score: numeric;
      groups: {
        cases: {
          contest_score: numeric;
          max_score: numeric;
          meta: { verdict: string };
          name: string;
          score: numeric;
          verdict: string;
        }[];
        contest_score: numeric;
        group: string;
        max_score: numeric;
        score: numeric;
      }[];
      judged_by: string;
      max_score: numeric;
      memory: numeric;
      score: numeric;
      time: numeric;
      verdict: string;
      wall_time: numeric;
    };
    guid: string;
    judged_by: string;
    language: string;
    logs: string;
    source: string;
  };
  type RunDisqualifyRequest = any;
  type RunDisqualifyResponse = { status: string };
  type RunDownloadRequest = any;
  type RunListRequest = any;
  type RunListResponse = {
    runs: {
      alias: string;
      contest_alias?: string;
      contest_score?: numeric;
      country_id?: string;
      guid: string;
      judged_by?: string;
      language: string;
      memory: numeric;
      penalty: numeric;
      run_id: numeric;
      runtime: numeric;
      score: numeric;
      submit_delay: numeric;
      time: numeric;
      type?: string;
      username: string;
      verdict: string;
    }[];
  };
  type RunRejudgeRequest = any;
  type RunRejudgeResponse = { status: string };
  type RunSourceRequest = any;
  type RunSourceResponse = {
    compile_error: string;
    details: {
      compile_meta: {
        [key: string]: {
          memory: numeric;
          sys_time: numeric;
          time: numeric;
          verdict: string;
          wall_time: numeric;
        };
      };
      contest_score: numeric;
      groups: {
        cases: {
          contest_score: numeric;
          max_score: numeric;
          meta: { verdict: string };
          name: string;
          score: numeric;
          verdict: string;
        }[];
        contest_score: numeric;
        group: string;
        max_score: numeric;
        score: numeric;
      }[];
      judged_by: string;
      max_score: numeric;
      memory: numeric;
      score: numeric;
      time: numeric;
      verdict: string;
      wall_time: numeric;
    };
    source: string;
  };
  type RunStatusRequest = any;
  type RunStatusResponse = {
    contest_score?: numeric;
    memory: numeric;
    penalty: numeric;
    runtime: numeric;
    score: numeric;
    submit_delay: numeric;
    time: numeric;
  };
  export interface Run {
    counts: () => Promise<RunCountsResponse>;
    create: () => Promise<RunCreateResponse>;
    details: () => Promise<RunDetailsResponse>;
    disqualify: () => Promise<RunDisqualifyResponse>;
    download: () => Promise<void>;
    list: () => Promise<RunListResponse>;
    rejudge: () => Promise<RunRejudgeResponse>;
    source: () => Promise<RunSourceResponse>;
    status: () => Promise<RunStatusResponse>;
  }

  // School
  type SchoolCreateRequest = any;
  type SchoolCreateResponse = { status: string; school_id: numeric };
  type SchoolListRequest = any;
  type SchoolListResponse = { id: numeric; label: string; value: string }[];
  type SchoolMonthlySolvedProblemsCountRequest = any;
  type SchoolMonthlySolvedProblemsCountResponse = {
    distinct_problems_solved: {
      year: numeric;
      month: numeric;
      count: numeric;
    }[];
    status: string;
  };
  type SchoolRankRequest = any;
  type SchoolRankResponse = {
    rank: {
      country_id?: string;
      name: string;
      ranking?: numeric;
      school_id: numeric;
      score: numeric;
    }[];
    totalRows: numeric;
  };
  type SchoolSchoolCodersOfTheMonthRequest = any;
  type SchoolSchoolCodersOfTheMonthResponse = {
    coders: { time: string; username: string; classname: string }[];
  };
  type SchoolSchoolsOfTheMonthRequest = any;
  type SchoolSchoolsOfTheMonthResponse = {
    rank: {
      school_id: numeric;
      name: string;
      country_id: string;
      score: numeric;
    }[];
  };
  type SchoolSelectSchoolOfTheMonthRequest = any;
  type SchoolSelectSchoolOfTheMonthResponse = { status: string };
  type SchoolUsersRequest = any;
  type SchoolUsersResponse = {
    status: string;
    users: {
      username: string;
      classname: string;
      created_problems: numeric;
      solved_problems: numeric;
      organized_contests: numeric;
    }[];
  };
  export interface School {
    create: () => Promise<SchoolCreateResponse>;
    list: () => Promise<SchoolListResponse>;
    monthlySolvedProblemsCount: () => Promise<
      SchoolMonthlySolvedProblemsCountResponse
    >;
    rank: () => Promise<SchoolRankResponse>;
    schoolCodersOfTheMonth: () => Promise<SchoolSchoolCodersOfTheMonthResponse>;
    schoolsOfTheMonth: () => Promise<SchoolSchoolsOfTheMonthResponse>;
    selectSchoolOfTheMonth: () => Promise<SchoolSelectSchoolOfTheMonthResponse>;
    users: () => Promise<SchoolUsersResponse>;
  }

  // Scoreboard
  type ScoreboardRefreshRequest = any;
  type ScoreboardRefreshResponse = { status: string };
  export interface Scoreboard {
    refresh: () => Promise<ScoreboardRefreshResponse>;
  }

  // Session
  type SessionCurrentSessionRequest = any;
  type SessionCurrentSessionResponse = {
    session?: {
      valid: boolean;
      email?: string;
      user?: omegaup.dao.Users;
      identity?: omegaup.dao.Identities;
      auth_token?: string;
      is_admin: boolean;
    };
    time: numeric;
  };
  type SessionGoogleLoginRequest = any;
  type SessionGoogleLoginResponse = { [key: string]: string };
  export interface Session {
    currentSession: () => Promise<SessionCurrentSessionResponse>;
    googleLogin: () => Promise<SessionGoogleLoginResponse>;
  }

  // Submission
  type SubmissionLatestSubmissionsRequest = any;
  type SubmissionLatestSubmissionsResponse = {
    submissions: {
      time: numeric;
      username: string;
      school_id?: numeric;
      school_name?: string;
      alias: string;
      title: string;
      language: string;
      verdict: string;
      runtime: numeric;
      memory: numeric;
    }[];
    totalRows: numeric;
  };
  export interface Submission {
    latestSubmissions: () => Promise<SubmissionLatestSubmissionsResponse>;
  }

  // Tag
  type TagListRequest = any;
  type TagListResponse = { name: string }[];
  export interface Tag {
    list: () => Promise<TagListResponse>;
  }

  // Time
  type TimeGetRequest = any;
  type TimeGetResponse = { time: numeric };
  export interface Time {
    get: () => Promise<TimeGetResponse>;
  }

  // User
  type UserAcceptPrivacyPolicyRequest = any;
  type UserAcceptPrivacyPolicyResponse = { status: string };
  type UserAddExperimentRequest = any;
  type UserAddExperimentResponse = { status: string };
  type UserAddGroupRequest = any;
  type UserAddGroupResponse = { status: string };
  type UserAddRoleRequest = any;
  type UserAddRoleResponse = { status: string };
  type UserAssociateIdentityRequest = any;
  type UserAssociateIdentityResponse = { status: string };
  type UserChangePasswordRequest = any;
  type UserChangePasswordResponse = { status: string };
  type UserCoderOfTheMonthRequest = any;
  type UserCoderOfTheMonthResponse = {
    coderinfo?: {
      birth_date?: numeric;
      country?: string;
      country_id?: string;
      email?: string;
      gender?: string;
      graduation_date?: numeric;
      gravatar_92: string;
      hide_problem_tags?: boolean;
      is_private: boolean;
      locale: string;
      name?: string;
      preferred_language?: string;
      scholar_degree?: string;
      school?: string;
      school_id?: numeric;
      state?: string;
      state_id?: string;
      username?: string;
      verified: boolean;
    };
  };
  type UserCoderOfTheMonthListRequest = any;
  type UserCoderOfTheMonthListResponse = {
    coders: {
      username: string;
      country_id: string;
      gravatar_32: string;
      date: string;
      classname: string;
    }[];
  };
  type UserContestStatsRequest = any;
  type UserContestStatsResponse = {
    contests: {
      [key: string]: {
        data: {
          alias: string;
          title: string;
          start_time: numeric;
          finish_time: numeric;
          last_updated: numeric;
        };
        place?: numeric;
      };
    };
  };
  type UserCreateRequest = any;
  type UserCreateResponse = { username: string };
  type UserExtraInformationRequest = any;
  type UserExtraInformationResponse = {
    within_last_day: boolean;
    verified: boolean;
    username: string;
    last_login?: numeric;
  };
  type UserGenerateGitTokenRequest = any;
  type UserGenerateGitTokenResponse = { token: string };
  type UserGenerateOmiUsersRequest = any;
  type UserGenerateOmiUsersResponse = { [key: string]: string };
  type UserInterviewStatsRequest = any;
  type UserInterviewStatsResponse = {
    user_verified: boolean;
    interview_url: string;
    name_or_username?: string;
    opened_interview: boolean;
    finished: boolean;
  };
  type UserLastPrivacyPolicyAcceptedRequest = any;
  type UserLastPrivacyPolicyAcceptedResponse = { hasAccepted: boolean };
  type UserListRequest = any;
  type UserListResponse = api.UserListItem[];
  type UserListAssociatedIdentitiesRequest = any;
  type UserListAssociatedIdentitiesResponse = {
    identities: { username: string; default: boolean }[];
  };
  type UserListUnsolvedProblemsRequest = any;
  type UserListUnsolvedProblemsResponse = {
    problems: {
      title: string;
      alias: string;
      submissions: numeric;
      accepted: numeric;
      difficulty: numeric;
    }[];
  };
  type UserLoginRequest = any;
  type UserLoginResponse = { auth_token: string };
  type UserMailingListBackfillRequest = any;
  type UserMailingListBackfillResponse = { users: { [key: string]: boolean } };
  type UserProblemsCreatedRequest = any;
  type UserProblemsCreatedResponse = {
    problems: { title: string; alias: string }[];
  };
  type UserProblemsSolvedRequest = any;
  type UserProblemsSolvedResponse = {
    problems: {
      title: string;
      alias: string;
      submissions: numeric;
      accepted: numeric;
    }[];
  };
  type UserProfileRequest = any;
  type UserProfileResponse = {
    birth_date?: numeric;
    classname: string;
    country?: string;
    country_id?: string;
    email?: string;
    gender?: string;
    graduation_date?: numeric;
    gravatar_92?: string;
    hide_problem_tags?: boolean;
    is_private: boolean;
    locale?: string;
    name?: string;
    preferred_language?: string;
    rankinfo: { name?: string; problems_solved?: numeric; rank?: numeric };
    scholar_degree?: string;
    school?: string;
    school_id?: numeric;
    state?: string;
    state_id?: string;
    username?: string;
    verified?: boolean;
  };
  type UserRankByProblemsSolvedRequest = any;
  type UserRankByProblemsSolvedResponse = {
    rank:
      | {
          classname: string;
          country_id?: string;
          name?: string;
          problems_solved: numeric;
          ranking: numeric;
          score: numeric;
          user_id: numeric;
          username: string;
        }[]
      | numeric;
    total: numeric;
    name: string;
    problems_solved: numeric;
  };
  type UserRemoveExperimentRequest = any;
  type UserRemoveExperimentResponse = { status: string };
  type UserRemoveGroupRequest = any;
  type UserRemoveGroupResponse = { status: string };
  type UserRemoveRoleRequest = any;
  type UserRemoveRoleResponse = { status: string };
  type UserSelectCoderOfTheMonthRequest = any;
  type UserSelectCoderOfTheMonthResponse = { status: string };
  type UserStatsRequest = any;
  type UserStatsResponse = {
    runs: { date?: string; runs: numeric; verdict: string }[];
  };
  type UserStatusVerifiedRequest = any;
  type UserStatusVerifiedResponse = { username: string; verified: boolean };
  type UserUpdateRequest = any;
  type UserUpdateResponse = { status: string };
  type UserUpdateBasicInfoRequest = any;
  type UserUpdateBasicInfoResponse = { status: string };
  type UserUpdateMainEmailRequest = any;
  type UserUpdateMainEmailResponse = { status: string };
  type UserValidateFilterRequest = any;
  type UserValidateFilterResponse = {
    user?: string;
    admin: boolean;
    problem_admin: string[];
    contest_admin: string[];
    problemset_admin: numeric[];
  };
  type UserVerifyEmailRequest = any;
  type UserVerifyEmailResponse = { status: string };
  export interface User {
    acceptPrivacyPolicy: () => Promise<UserAcceptPrivacyPolicyResponse>;
    addExperiment: () => Promise<UserAddExperimentResponse>;
    addGroup: () => Promise<UserAddGroupResponse>;
    addRole: () => Promise<UserAddRoleResponse>;
    associateIdentity: () => Promise<UserAssociateIdentityResponse>;
    changePassword: () => Promise<UserChangePasswordResponse>;
    coderOfTheMonth: () => Promise<UserCoderOfTheMonthResponse>;
    coderOfTheMonthList: () => Promise<UserCoderOfTheMonthListResponse>;
    contestStats: () => Promise<UserContestStatsResponse>;
    create: () => Promise<UserCreateResponse>;
    extraInformation: () => Promise<UserExtraInformationResponse>;
    generateGitToken: () => Promise<UserGenerateGitTokenResponse>;
    generateOmiUsers: () => Promise<UserGenerateOmiUsersResponse>;
    interviewStats: () => Promise<UserInterviewStatsResponse>;
    lastPrivacyPolicyAccepted: () => Promise<
      UserLastPrivacyPolicyAcceptedResponse
    >;
    list: () => Promise<UserListResponse>;
    listAssociatedIdentities: () => Promise<
      UserListAssociatedIdentitiesResponse
    >;
    listUnsolvedProblems: () => Promise<UserListUnsolvedProblemsResponse>;
    login: () => Promise<UserLoginResponse>;
    mailingListBackfill: () => Promise<UserMailingListBackfillResponse>;
    problemsCreated: () => Promise<UserProblemsCreatedResponse>;
    problemsSolved: () => Promise<UserProblemsSolvedResponse>;
    profile: () => Promise<UserProfileResponse>;
    rankByProblemsSolved: () => Promise<UserRankByProblemsSolvedResponse>;
    removeExperiment: () => Promise<UserRemoveExperimentResponse>;
    removeGroup: () => Promise<UserRemoveGroupResponse>;
    removeRole: () => Promise<UserRemoveRoleResponse>;
    selectCoderOfTheMonth: () => Promise<UserSelectCoderOfTheMonthResponse>;
    stats: () => Promise<UserStatsResponse>;
    statusVerified: () => Promise<UserStatusVerifiedResponse>;
    update: () => Promise<UserUpdateResponse>;
    updateBasicInfo: () => Promise<UserUpdateBasicInfoResponse>;
    updateMainEmail: () => Promise<UserUpdateMainEmailResponse>;
    validateFilter: () => Promise<UserValidateFilterResponse>;
    verifyEmail: () => Promise<UserVerifyEmailResponse>;
  }
}

const API = {
  ACL: api.ACL,
  Admin: api.Admin,
  Authorization: api.Authorization,
  Badge: api.Badge,
  Clarification: api.Clarification,
  Contest: api.Contest,
  Controller: api.Controller,
  Course: api.Course,
  Grader: api.Grader,
  Group: api.Group,
  GroupScoreboard: api.GroupScoreboard,
  Identity: api.Identity,
  Interview: api.Interview,
  Notification: api.Notification,
  Problem: api.Problem,
  ProblemForfeited: api.ProblemForfeited,
  Problemset: api.Problemset,
  QualityNomination: api.QualityNomination,
  Reset: api.Reset,
  Run: api.Run,
  School: api.School,
  Scoreboard: api.Scoreboard,
  Session: api.Session,
  Submission: api.Submission,
  Tag: api.Tag,
  Time: api.Time,
  User: api.User,
};

export { API as default };
