// generated by frontend/server/cmd/APITool.php. DO NOT EDIT.

// DAO types
export namespace dao {
  export interface Identities {
    country_id?: string;
    current_identity_school_id?: number;
    gender?: string;
    identity_id?: number;
    language_id?: number;
    name?: string;
    password?: string;
    state_id?: string;
    user_id?: number;
    username?: string;
  }

  export interface Users {
    birth_date?: string;
    facebook_user_id?: string;
    git_token?: string;
    hide_problem_tags?: boolean;
    in_mailing_list?: boolean;
    is_private?: boolean;
    main_email_id?: number;
    main_identity_id?: number;
    preferred_language?: string;
    reset_digest?: string;
    reset_sent_at?: number;
    scholar_degree?: string;
    user_id?: number;
    verification_id?: string;
    verified?: boolean;
  }
}

// Type aliases
export namespace types {
  export namespace payloadParsers {
    export function BadgeDetailsPayload(
      elementId: string,
    ): types.BadgeDetailsPayload {
      return (x => {
        x.badge = (x => {
          x.assignation_time = ((x: number) => new Date(x * 1000))(
            x.assignation_time,
          );
          if (x.first_assignation)
            x.first_assignation = ((x: number) => new Date(x * 1000))(
              x.first_assignation,
            );
          return x;
        })(x.badge);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CommonPayload(elementId: string): types.CommonPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ContestListPayload(
      elementId: string,
    ): types.ContestListPayload {
      return (x => {
        x.contests = (x => {
          x.current = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.current);
          x.future = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.future);
          x.participating = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.participating);
          x.past = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.past);
          x.public = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.public);
          x.recommended_current = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.recommended_current);
          x.recommended_past = (x => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map(x => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.recommended_past);
          return x;
        })(x.contests);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function IndexPayload(elementId: string): types.IndexPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ProblemFormPayload(
      elementId: string,
    ): types.ProblemFormPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ProblemListPayload(
      elementId: string,
    ): types.ProblemListPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function StatsPayload(elementId: string): types.StatsPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function UserRankTablePayload(
      elementId: string,
    ): types.UserRankTablePayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }
  }

  export interface AssignmentProgress {
    [key: string]: types.Progress;
  }

  export interface Badge {
    assignation_time: Date;
    badge_alias: string;
    unlocked: boolean;
    first_assignation?: Date;
    total_users: number;
    owners_count: number;
  }

  export interface BadgeDetailsPayload {
    badge: types.Badge;
  }

  export interface Clarification {
    answer?: string;
    author: string;
    clarification_id: number;
    message: string;
    problem_alias: string;
    public: boolean;
    receiver?: string;
    time: Date;
  }

  export interface CoderOfTheMonth {
    category: string;
    classname: string;
    coder_of_the_month_id: number;
    country_id: string;
    description?: string;
    interview_url?: string;
    problems_solved: number;
    ranking: number;
    school_id?: number;
    score: number;
    selected_by?: number;
    time: string;
    user_id: number;
    username: string;
  }

  export interface CommonPayload {
    omegaUpLockDown: boolean;
    bootstrap4: boolean;
    inContest: boolean;
    isLoggedIn: boolean;
    isReviewer: boolean;
    gravatarURL51: string;
    currentUsername: string;
    isMainUserIdentity: boolean;
    isAdmin: boolean;
    lockDownImage: string;
    navbarSection: string;
  }

  export interface ContestListItem {
    admission_mode: string;
    alias: string;
    contest_id: number;
    description: string;
    finish_time: Date;
    last_updated: Date;
    original_finish_time: Date;
    problemset_id: number;
    recommended: boolean;
    rerun_id: number;
    start_time: Date;
    title: string;
    window_length?: number;
  }

  export interface ContestListPayload {
    contests: {
      current: types.ContestListItem[];
      future: types.ContestListItem[];
      participating: types.ContestListItem[];
      past: types.ContestListItem[];
      public: types.ContestListItem[];
      recommended_current: types.ContestListItem[];
      recommended_past: types.ContestListItem[];
    };
    isLogged: boolean;
    query: string;
  }

  export interface CourseAssignment {
    alias: string;
    assignment_type: string;
    description: string;
    finish_time?: number;
    max_points: number;
    name: string;
    order: number;
    publish_time_delay?: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    start_time: number;
  }

  export interface CourseDetails {
    admission_mode: string;
    alias: string;
    assignments: types.CourseAssignment[];
    basic_information_required: boolean;
    description: string;
    finish_time?: number;
    isCurator: boolean;
    is_admin: boolean;
    name: string;
    requests_user_information: string;
    school_id?: number;
    school_name?: string;
    show_scoreboard: boolean;
    start_time: number;
    student_count: number;
  }

  export interface GraderStatus {
    status: string;
    broadcaster_sockets: number;
    embedded_runner: boolean;
    queue: {
      running: { name: string; id: number }[];
      run_queue_length: number;
      runner_queue_length: number;
      runners: string[];
    };
  }

  export interface IndexPayload {
    coderOfTheMonthData: {
      all?: types.UserProfile;
      female?: types.UserProfile;
    };
    currentUserInfo: { username: string };
    userRank: types.CoderOfTheMonth[];
    schoolOfTheMonthData?: {
      country_id?: string;
      country?: string;
      name: string;
      school_id: number;
      state?: string;
    };
    schoolRank: {
      name: string;
      ranking: number;
      school_id: number;
      school_of_the_month_id: number;
      score: number;
    }[];
  }

  export interface Notification {
    contents: types.NotificationContents;
    notification_id: number;
    timestamp: Date;
  }

  export interface NotificationContents {
    type: string;
    badge: string;
  }

  export interface PageItem {
    class: string;
    label: string;
    page: number;
    url: string;
  }

  export interface Problem {
    title: string;
    alias: string;
    submissions: number;
    accepted: number;
    difficulty: number;
  }

  export interface ProblemFormPayload {
    alias: string;
    allowUserAddTags: boolean;
    emailClarifications: boolean;
    extraWallTime: number | string;
    inputLimit: number | string;
    isUpdate: boolean;
    languages: string;
    memoryLimit: number | string;
    message: string;
    outputLimit: number | string;
    overallWallTimeLimit: number | string;
    selectedTags?: { public: boolean; tagname: string }[];
    source: string;
    statusError: string;
    tags: { name?: string }[];
    timeLimit: number | string;
    title: string;
    validLanguages: { [key: string]: string };
    validator: string;
    validatorTimeLimit: number | string;
    validatorTypes: { [key: string]: null | string };
    visibility: number;
  }

  export interface ProblemListItem {
    alias: string;
    difficulty?: number;
    difficulty_histogram: number[];
    points: number;
    quality?: number;
    quality_histogram: number[];
    ratio: number;
    score: number;
    tags: { source: string; name: string }[];
    title: string;
    visibility: number;
    quality_seal: boolean;
  }

  export interface ProblemListPayload {
    currentTags: string[];
    loggedIn: boolean;
    pagerItems: types.PageItem[];
    problems: types.ProblemListItem[];
    keyword: string;
    language: string;
    mode: string;
    column: string;
    languages: string[];
    columns: string[];
    modes: string[];
    tagData: { name?: string }[];
    tags: string[];
  }

  export interface ProblemsetProblem {
    accepted: number;
    alias: string;
    commit: string;
    difficulty: number;
    languages: string;
    letter: string;
    order: number;
    points: number;
    problem_id: number;
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  }

  export interface Progress {
    score: number;
    max_score: number;
  }

  export interface Run {
    run_id: number;
    guid: string;
    language: string;
    status: string;
    verdict: string;
    runtime: number;
    penalty: number;
    memory: number;
    score: number;
    contest_score: number;
    judged_by?: string;
    time: Date;
    submit_delay: number;
    type?: string;
    username: string;
    alias: string;
    country_id?: string;
    contest_alias?: string;
  }

  export interface Scoreboard {
    finish_time?: number;
    problems: { alias: string; order: number }[];
    ranking: types.ScoreboardRankingEntry[];
    start_time: number;
    time: number;
    title: string;
  }

  export interface ScoreboardRankingEntry {
    country?: string;
    is_invited: boolean;
    name?: string;
    place: number;
    problems: {
      alias: string;
      penalty: number;
      percent: number;
      place: number;
      points: number;
      run_details: {
        cases: {
          contest_score: number;
          max_score: number;
          meta: { status: string };
          name?: string;
          out_diff: string;
          score: number;
          verdict: string;
        }[];
        details: {
          groups: {
            cases: {
              meta: { memory: number; time: number; wall_time: number };
            }[];
          }[];
        };
      };
      runs: number;
    }[];
    total: { penalty: number; points: number };
    username: string;
  }

  export interface StatsPayload {
    alias: string;
    entity_type: string;
    cases_stats: { [key: string]: number };
    pending_runs: string[];
    total_runs: number;
    verdict_counts: { [key: string]: number };
    max_wait_time: number;
    max_wait_time_guid?: string;
    distribution: { [key: number]: number };
    size_of_bucket: number;
    total_points: number;
  }

  export interface UserListItem {
    label: string;
    value: string;
  }

  export interface UserProfile {
    birth_date?: number;
    classname: string;
    country: string;
    country_id?: string;
    email?: string;
    gender?: string;
    graduation_date?: number;
    gravatar_92: string;
    hide_problem_tags?: boolean;
    is_private: boolean;
    locale: string;
    name?: string;
    preferred_language?: string;
    scholar_degree?: string;
    school?: string;
    school_id?: number;
    state?: string;
    state_id?: string;
    username?: string;
    verified: boolean;
  }

  export interface UserRankTablePayload {
    availableFilters: { country?: string; school?: string; state?: string };
    filter: string;
    isIndex: boolean;
    isLogged: boolean;
    length: number;
    page: number;
  }
}

// API messages
export namespace messages {
  // Admin
  export type AdminPlatformReportStatsRequest = { [key: string]: any };
  export type AdminPlatformReportStatsResponse = {
    report: {
      acceptedSubmissions: number;
      activeSchools: number;
      activeUsers: { [key: string]: number };
      courses: number;
      omiCourse: {
        attemptedUsers: number;
        completedUsers: number;
        passedUsers: number;
      };
    };
  };

  // Authorization
  export type AuthorizationProblemRequest = { [key: string]: any };
  export type AuthorizationProblemResponse = {
    has_solved: boolean;
    is_admin: boolean;
    can_view: boolean;
    can_edit: boolean;
  };

  // Badge
  export type BadgeBadgeDetailsRequest = { [key: string]: any };
  export type _BadgeBadgeDetailsServerResponse = any;
  export type BadgeBadgeDetailsResponse = types.Badge;
  export type BadgeListRequest = { [key: string]: any };
  export type BadgeListResponse = string[];
  export type BadgeMyBadgeAssignationTimeRequest = { [key: string]: any };
  export type _BadgeMyBadgeAssignationTimeServerResponse = any;
  export type BadgeMyBadgeAssignationTimeResponse = { assignation_time?: Date };
  export type BadgeMyListRequest = { [key: string]: any };
  export type _BadgeMyListServerResponse = any;
  export type BadgeMyListResponse = { badges: types.Badge[] };
  export type BadgeUserListRequest = { [key: string]: any };
  export type _BadgeUserListServerResponse = any;
  export type BadgeUserListResponse = { badges: types.Badge[] };

  // Clarification
  export type ClarificationCreateRequest = { [key: string]: any };
  export type ClarificationCreateResponse = { clarification_id: number };
  export type ClarificationDetailsRequest = { [key: string]: any };
  export type ClarificationDetailsResponse = {
    message: string;
    answer?: string;
    time: number;
    problem_id: number;
    problemset_id?: number;
  };
  export type ClarificationUpdateRequest = { [key: string]: any };
  export type ClarificationUpdateResponse = {};

  // Contest
  export type ContestActivityReportRequest = { [key: string]: any };
  export type ContestActivityReportResponse = {
    events: {
      username: string;
      ip: number;
      time: number;
      classname: string;
      alias: string;
    }[];
  };
  export type ContestAddAdminRequest = { [key: string]: any };
  export type ContestAddAdminResponse = {};
  export type ContestAddGroupRequest = { [key: string]: any };
  export type ContestAddGroupResponse = {};
  export type ContestAddGroupAdminRequest = { [key: string]: any };
  export type ContestAddGroupAdminResponse = {};
  export type ContestAddProblemRequest = { [key: string]: any };
  export type ContestAddProblemResponse = {};
  export type ContestAddUserRequest = { [key: string]: any };
  export type ContestAddUserResponse = {};
  export type ContestAdminDetailsRequest = { [key: string]: any };
  export type ContestAdminDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    available_languages: { [key: string]: string };
    description: string;
    director?: string;
    feedback: string;
    finish_time: number;
    languages: string[];
    needs_basic_information: boolean;
    partial_score: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    problems: {
      accepted: number;
      alias: string;
      commit: string;
      difficulty: number;
      languages: string;
      letter: string;
      order: number;
      points: number;
      problem_id: number;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
    points_decay_factor: number;
    problemset_id: number;
    requests_user_information: string;
    rerun_id: number;
    scoreboard: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    show_scoreboard_after: boolean;
    start_time: number;
    submissions_gap: number;
    title: string;
    window_length?: number;
  };
  export type ContestAdminListRequest = { [key: string]: any };
  export type _ContestAdminListServerResponse = any;
  export type ContestAdminListResponse = {
    contests: {
      admission_mode: string;
      alias: string;
      finish_time: Date;
      rerun_id: number;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      start_time: Date;
      title: string;
    }[];
  };
  export type ContestAdminsRequest = { [key: string]: any };
  export type ContestAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  export type ContestArbitrateRequestRequest = { [key: string]: any };
  export type ContestArbitrateRequestResponse = {};
  export type ContestClarificationsRequest = { [key: string]: any };
  export type _ContestClarificationsServerResponse = any;
  export type ContestClarificationsResponse = {
    clarifications: types.Clarification[];
  };
  export type ContestCloneRequest = { [key: string]: any };
  export type ContestCloneResponse = { alias: string };
  export type ContestContestantsRequest = { [key: string]: any };
  export type ContestContestantsResponse = {
    contestants: {
      name?: string;
      username: string;
      email?: string;
      state?: string;
      country?: string;
      school?: string;
    }[];
  };
  export type ContestCreateRequest = { [key: string]: any };
  export type ContestCreateResponse = {};
  export type ContestCreateVirtualRequest = { [key: string]: any };
  export type ContestCreateVirtualResponse = { alias: string };
  export type ContestDetailsRequest = { [key: string]: any };
  export type ContestDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    description: string;
    director?: string;
    feedback: string;
    finish_time: number;
    languages: string[];
    needs_basic_information: boolean;
    opened: boolean;
    partial_score: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    problems: {
      accepted: number;
      alias: string;
      commit: string;
      difficulty: number;
      languages: string;
      letter: string;
      order: number;
      points: number;
      problem_id: number;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
    points_decay_factor: number;
    problemset_id: number;
    requests_user_information: string;
    scoreboard: number;
    show_scoreboard_after: boolean;
    start_time: number;
    submissions_gap: number;
    submission_deadline: number;
    title: string;
    window_length?: number;
  };
  export type ContestListRequest = { [key: string]: any };
  export type _ContestListServerResponse = any;
  export type ContestListResponse = {
    number_of_results: number;
    results: {
      admission_mode: string;
      alias: string;
      contest_id: number;
      description: string;
      finish_time: Date;
      last_updated: Date;
      original_finish_time: Date;
      problemset_id: number;
      recommended: boolean;
      rerun_id: number;
      start_time: Date;
      title: string;
      window_length?: number;
    }[];
  };
  export type ContestListParticipatingRequest = { [key: string]: any };
  export type _ContestListParticipatingServerResponse = any;
  export type ContestListParticipatingResponse = {
    contests: {
      acl_id: number;
      admission_mode: string;
      alias: string;
      contest_id: number;
      description: string;
      feedback: string;
      finish_time: Date;
      languages?: string;
      last_updated: Date;
      original_finish_time: Date;
      partial_score: number;
      penalty: number;
      penalty_calc_policy: string;
      penalty_type: string;
      points_decay_factor: number;
      problemset_id: number;
      recommended: boolean;
      rerun_id: number;
      scoreboard: number;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      show_scoreboard_after: number;
      start_time: Date;
      submissions_gap: number;
      title: string;
      urgent: number;
      window_length?: number;
    }[];
  };
  export type ContestMyListRequest = { [key: string]: any };
  export type _ContestMyListServerResponse = any;
  export type ContestMyListResponse = {
    contests: {
      acl_id: number;
      admission_mode: string;
      alias: string;
      contest_id: number;
      description: string;
      feedback: string;
      finish_time: Date;
      languages?: string;
      last_updated: Date;
      original_finish_time: Date;
      partial_score: number;
      penalty: number;
      penalty_calc_policy: string;
      penalty_type: string;
      points_decay_factor: number;
      problemset_id: number;
      recommended: boolean;
      rerun_id: number;
      scoreboard: number;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      show_scoreboard_after: number;
      start_time: Date;
      submissions_gap: number;
      title: string;
      urgent: number;
      window_length?: number;
    }[];
  };
  export type ContestOpenRequest = { [key: string]: any };
  export type ContestOpenResponse = {};
  export type ContestProblemsRequest = { [key: string]: any };
  export type ContestProblemsResponse = {
    problems: {
      accepted: number;
      alias: string;
      commit: string;
      difficulty: number;
      languages: string;
      order: number;
      points: number;
      problem_id: number;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
  };
  export type ContestPublicDetailsRequest = { [key: string]: any };
  export type ContestPublicDetailsResponse = {
    admission_mode: string;
    alias: string;
    description: string;
    feedback: string;
    finish_time: number;
    languages: string;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problemset_id: number;
    rerun_id: number;
    scoreboard: number;
    show_scoreboard_after: boolean;
    start_time: number;
    submissions_gap: number;
    title: string;
    window_length?: number;
    user_registration_requested: boolean;
    user_registration_answered: boolean;
    user_registration_accepted?: boolean;
  };
  export type ContestRegisterForContestRequest = { [key: string]: any };
  export type ContestRegisterForContestResponse = {};
  export type ContestRemoveAdminRequest = { [key: string]: any };
  export type ContestRemoveAdminResponse = {};
  export type ContestRemoveGroupRequest = { [key: string]: any };
  export type ContestRemoveGroupResponse = {};
  export type ContestRemoveGroupAdminRequest = { [key: string]: any };
  export type ContestRemoveGroupAdminResponse = {};
  export type ContestRemoveProblemRequest = { [key: string]: any };
  export type ContestRemoveProblemResponse = {};
  export type ContestRemoveUserRequest = { [key: string]: any };
  export type ContestRemoveUserResponse = {};
  export type ContestReportRequest = { [key: string]: any };
  export type ContestReportResponse = {
    finish_time?: number;
    problems: { alias: string; order: number }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: number;
      problems: {
        alias: string;
        penalty: number;
        percent: number;
        place: number;
        points: number;
        run_details: {
          cases: {
            contest_score: number;
            max_score: number;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: number;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: number; time: number; wall_time: number };
              }[];
            }[];
          };
        };
        runs: number;
      }[];
      total: { penalty: number; points: number };
      username: string;
    }[];
    start_time: number;
    time: number;
    title: string;
  };
  export type ContestRequestsRequest = { [key: string]: any };
  export type _ContestRequestsServerResponse = any;
  export type ContestRequestsResponse = {
    users: {
      accepted?: boolean;
      admin: { username?: string };
      country?: string;
      last_update?: Date;
      request_time: Date;
      username: string;
    }[];
    contest_alias: string;
  };
  export type ContestRoleRequest = { [key: string]: any };
  export type ContestRoleResponse = { admin: boolean };
  export type ContestRunsRequest = { [key: string]: any };
  export type _ContestRunsServerResponse = any;
  export type ContestRunsResponse = { runs: types.Run[] };
  export type ContestRunsDiffRequest = { [key: string]: any };
  export type ContestRunsDiffResponse = {
    diff: {
      guid: string;
      new_score?: number;
      new_status?: string;
      new_verdict?: string;
      old_score?: number;
      old_status?: string;
      old_verdict?: string;
      problemset_id?: number;
      username: string;
    }[];
  };
  export type ContestScoreboardRequest = { [key: string]: any };
  export type ContestScoreboardResponse = {
    finish_time?: number;
    problems: { alias: string; order: number }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: number;
      problems: {
        alias: string;
        penalty: number;
        percent: number;
        place: number;
        points: number;
        run_details: {
          cases: {
            contest_score: number;
            max_score: number;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: number;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: number; time: number; wall_time: number };
              }[];
            }[];
          };
        };
        runs: number;
      }[];
      total: { penalty: number; points: number };
      username: string;
    }[];
    start_time: number;
    time: number;
    title: string;
  };
  export type ContestScoreboardEventsRequest = { [key: string]: any };
  export type ContestScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: number;
      is_invited: boolean;
      total: { points: number; penalty: number };
      name?: string;
      username: string;
      problem: { alias: string; points: number; penalty: number };
    }[];
  };
  export type ContestScoreboardMergeRequest = { [key: string]: any };
  export type ContestScoreboardMergeResponse = {
    ranking: {
      name?: string;
      username: string;
      contests: { [key: string]: { points: number; penalty: number } };
      total: { points: number; penalty: number };
    }[];
  };
  export type ContestSetRecommendedRequest = { [key: string]: any };
  export type ContestSetRecommendedResponse = {};
  export type ContestStatsRequest = { [key: string]: any };
  export type ContestStatsResponse = {
    total_runs: number;
    pending_runs: string[];
    max_wait_time: number;
    max_wait_time_guid?: string;
    verdict_counts: { [key: string]: number };
    distribution: { [key: number]: number };
    size_of_bucket: number;
    total_points: number;
  };
  export type ContestUpdateRequest = { [key: string]: any };
  export type ContestUpdateResponse = {};
  export type ContestUpdateEndTimeForIdentityRequest = { [key: string]: any };
  export type ContestUpdateEndTimeForIdentityResponse = {};
  export type ContestUsersRequest = { [key: string]: any };
  export type ContestUsersResponse = {
    users: {
      access_time?: number;
      country_id?: string;
      end_time?: number;
      is_owner?: number;
      username: string;
    }[];
    groups: { alias: string; name: string }[];
  };

  // Course
  export type CourseActivityReportRequest = { [key: string]: any };
  export type CourseActivityReportResponse = {
    events: {
      username: string;
      ip: number;
      time: number;
      classname: string;
      alias: string;
    }[];
  };
  export type CourseAddAdminRequest = { [key: string]: any };
  export type CourseAddAdminResponse = {};
  export type CourseAddGroupAdminRequest = { [key: string]: any };
  export type CourseAddGroupAdminResponse = {};
  export type CourseAddProblemRequest = { [key: string]: any };
  export type CourseAddProblemResponse = {};
  export type CourseAddStudentRequest = { [key: string]: any };
  export type CourseAddStudentResponse = {};
  export type CourseAdminDetailsRequest = { [key: string]: any };
  export type CourseAdminDetailsResponse = types.CourseDetails;
  export type CourseAdminsRequest = { [key: string]: any };
  export type CourseAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  export type CourseArbitrateRequestRequest = { [key: string]: any };
  export type CourseArbitrateRequestResponse = {};
  export type CourseAssignmentDetailsRequest = { [key: string]: any };
  export type CourseAssignmentDetailsResponse = {
    name?: string;
    description?: string;
    assignment_type?: string;
    start_time: number;
    finish_time?: number;
    problems: {
      accepted: number;
      alias: string;
      commit: string;
      difficulty: number;
      languages: string;
      order: number;
      points: number;
      problem_id: number;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
    director: string;
    problemset_id: number;
    admin: boolean;
  };
  export type CourseAssignmentScoreboardRequest = { [key: string]: any };
  export type CourseAssignmentScoreboardResponse = {
    finish_time?: number;
    problems: { alias: string; order: number }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place: number;
      problems: {
        alias: string;
        penalty: number;
        percent: number;
        place: number;
        points: number;
        run_details: {
          cases: {
            contest_score: number;
            max_score: number;
            meta: { status: string };
            name?: string;
            out_diff: string;
            score: number;
            verdict: string;
          }[];
          details: {
            groups: {
              cases: {
                meta: { memory: number; time: number; wall_time: number };
              }[];
            }[];
          };
        };
        runs: number;
      }[];
      total: { penalty: number; points: number };
      username: string;
    }[];
    start_time: number;
    time: number;
    title: string;
  };
  export type CourseAssignmentScoreboardEventsRequest = { [key: string]: any };
  export type CourseAssignmentScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: number;
      is_invited: boolean;
      name?: string;
      problem: { alias: string; penalty: number; points: number };
      total: { penalty: number; points: number };
      username: string;
    }[];
  };
  export type CourseCloneRequest = { [key: string]: any };
  export type CourseCloneResponse = { alias: string };
  export type CourseCreateRequest = { [key: string]: any };
  export type CourseCreateResponse = {};
  export type CourseCreateAssignmentRequest = { [key: string]: any };
  export type CourseCreateAssignmentResponse = {};
  export type CourseDetailsRequest = { [key: string]: any };
  export type CourseDetailsResponse = types.CourseDetails;
  export type CourseGetProblemUsersRequest = { [key: string]: any };
  export type CourseGetProblemUsersResponse = { identities: string[] };
  export type CourseIntroDetailsRequest = { [key: string]: any };
  export type CourseIntroDetailsResponse = {
    name: string;
    description: string;
    alias: string;
    currentUsername: string;
    needsBasicInformation: boolean;
    requestsUserInformation: string;
    shouldShowAcceptTeacher: boolean;
    statements: {
      privacy: {
        markdown?: string;
        gitObjectId?: string;
        statementType?: string;
      };
      acceptTeacher: {
        gitObjectId?: string;
        markdown: string;
        statementType: string;
      };
    };
    isFirstTimeAccess: boolean;
    shouldShowResults: boolean;
  };
  export type CourseListAssignmentsRequest = { [key: string]: any };
  export type CourseListAssignmentsResponse = {
    assignments: {
      alias: string;
      assignment_type: string;
      description: string;
      finish_time?: number;
      has_runs: boolean;
      name: string;
      order: number;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      start_time: number;
    }[];
  };
  export type CourseListCoursesRequest = { [key: string]: any };
  export type CourseListCoursesResponse = {
    admin: {
      alias: string;
      counts: { [key: string]: number };
      finish_time?: number;
      name: string;
      start_time: number;
    }[];
    public: {
      alias: string;
      counts: { [key: string]: number };
      finish_time?: number;
      name: string;
      start_time: number;
    }[];
    student: {
      alias: string;
      counts: { [key: string]: number };
      finish_time?: number;
      name: string;
      start_time: number;
    }[];
  };
  export type CourseListSolvedProblemsRequest = { [key: string]: any };
  export type CourseListSolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  export type CourseListStudentsRequest = { [key: string]: any };
  export type CourseListStudentsResponse = {
    students: {
      name?: string;
      progress: { [key: string]: number };
      username: string;
    }[];
  };
  export type CourseListUnsolvedProblemsRequest = { [key: string]: any };
  export type CourseListUnsolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  export type CourseMyProgressRequest = { [key: string]: any };
  export type CourseMyProgressResponse = {
    assignments: types.AssignmentProgress;
  };
  export type CourseRegisterForCourseRequest = { [key: string]: any };
  export type CourseRegisterForCourseResponse = {};
  export type CourseRemoveAdminRequest = { [key: string]: any };
  export type CourseRemoveAdminResponse = {};
  export type CourseRemoveGroupAdminRequest = { [key: string]: any };
  export type CourseRemoveGroupAdminResponse = {};
  export type CourseRemoveProblemRequest = { [key: string]: any };
  export type CourseRemoveProblemResponse = {};
  export type CourseRemoveStudentRequest = { [key: string]: any };
  export type CourseRemoveStudentResponse = {};
  export type CourseRequestsRequest = { [key: string]: any };
  export type _CourseRequestsServerResponse = any;
  export type CourseRequestsResponse = {
    users: {
      accepted?: boolean;
      admin: { name?: string; username: string };
      country?: string;
      country_id?: string;
      last_update?: Date;
      request_time: Date;
      username: string;
    }[];
  };
  export type CourseRunsRequest = { [key: string]: any };
  export type _CourseRunsServerResponse = any;
  export type CourseRunsResponse = {
    runs: {
      run_id: number;
      guid: string;
      language: string;
      status: string;
      verdict: string;
      runtime: number;
      penalty: number;
      memory: number;
      score: number;
      contest_score: number;
      judged_by?: string;
      time: Date;
      submit_delay: number;
      type?: string;
      username: string;
      alias: string;
      country_id?: string;
      contest_alias?: string;
    }[];
  };
  export type CourseStudentProgressRequest = { [key: string]: any };
  export type _CourseStudentProgressServerResponse = any;
  export type CourseStudentProgressResponse = {
    problems: {
      accepted: number;
      alias: string;
      commit: string;
      difficulty: number;
      languages: string;
      letter: string;
      order: number;
      points: number;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
      runs: {
        guid: string;
        language: string;
        source: string;
        status: string;
        verdict: string;
        runtime: number;
        penalty: number;
        memory: number;
        score: number;
        contest_score?: number;
        time: Date;
        submit_delay: number;
      }[];
    }[];
  };
  export type CourseUpdateRequest = { [key: string]: any };
  export type CourseUpdateResponse = {};
  export type CourseUpdateAssignmentRequest = { [key: string]: any };
  export type CourseUpdateAssignmentResponse = {};
  export type CourseUpdateAssignmentsOrderRequest = { [key: string]: any };
  export type CourseUpdateAssignmentsOrderResponse = {};
  export type CourseUpdateProblemsOrderRequest = { [key: string]: any };
  export type CourseUpdateProblemsOrderResponse = {};

  // Grader
  export type GraderStatusRequest = { [key: string]: any };
  export type GraderStatusResponse = { grader: types.GraderStatus };

  // Group
  export type GroupAddUserRequest = { [key: string]: any };
  export type GroupAddUserResponse = {};
  export type GroupCreateRequest = { [key: string]: any };
  export type GroupCreateResponse = {};
  export type GroupCreateScoreboardRequest = { [key: string]: any };
  export type GroupCreateScoreboardResponse = {};
  export type GroupDetailsRequest = { [key: string]: any };
  export type GroupDetailsResponse = {
    exists: boolean;
    group: {
      create_time: number;
      alias?: string;
      name?: string;
      description?: string;
    };
    scoreboards: {
      alias: string;
      create_time: string;
      description?: string;
      name: string;
    }[];
  };
  export type GroupListRequest = { [key: string]: any };
  export type GroupListResponse = { label: string; value: string }[];
  export type GroupMembersRequest = { [key: string]: any };
  export type GroupMembersResponse = {
    identities: {
      classname: string;
      country?: string;
      country_id?: string;
      name?: string;
      school?: string;
      school_id?: number;
      state?: string;
      state_id?: string;
      username: string;
    }[];
  };
  export type GroupMyListRequest = { [key: string]: any };
  export type GroupMyListResponse = {
    groups: {
      alias: string;
      create_time: number;
      description?: string;
      name: string;
    }[];
  };
  export type GroupRemoveUserRequest = { [key: string]: any };
  export type GroupRemoveUserResponse = {};

  // GroupScoreboard
  export type GroupScoreboardAddContestRequest = { [key: string]: any };
  export type GroupScoreboardAddContestResponse = {};
  export type GroupScoreboardDetailsRequest = { [key: string]: any };
  export type GroupScoreboardDetailsResponse = {
    ranking: {
      name?: string;
      username: string;
      contests: { [key: string]: { points: number; penalty: number } };
      total: { points: number; penalty: number };
    }[];
    scoreboard: {
      group_scoreboard_id: number;
      group_id: number;
      create_time: number;
      alias: string;
      name: string;
      description: string;
    };
    contests: {
      contest_id: number;
      problemset_id: number;
      acl_id: number;
      title: string;
      description: string;
      start_time: number;
      finish_time: number;
      last_updated: number;
      window_length?: number;
      rerun_id: number;
      admission_mode: string;
      alias: string;
      scoreboard: number;
      points_decay_factor: number;
      partial_score: boolean;
      submissions_gap: number;
      feedback: string;
      penalty: string;
      penalty_calc_policy: string;
      show_scoreboard_after: boolean;
      urgent: boolean;
      languages: string;
      recommended: boolean;
      only_ac: boolean;
      weight: number;
    }[];
  };
  export type GroupScoreboardListRequest = { [key: string]: any };
  export type GroupScoreboardListResponse = {
    scoreboards: {
      group_scoreboard_id: number;
      group_id: number;
      create_time: number;
      alias: string;
      name: string;
      description: string;
    }[];
  };
  export type GroupScoreboardRemoveContestRequest = { [key: string]: any };
  export type GroupScoreboardRemoveContestResponse = {};

  // Identity
  export type IdentityBulkCreateRequest = { [key: string]: any };
  export type IdentityBulkCreateResponse = {};
  export type IdentityChangePasswordRequest = { [key: string]: any };
  export type IdentityChangePasswordResponse = {};
  export type IdentityCreateRequest = { [key: string]: any };
  export type IdentityCreateResponse = { username: string };
  export type IdentityUpdateRequest = { [key: string]: any };
  export type IdentityUpdateResponse = {};

  // Interview
  export type InterviewAddUsersRequest = { [key: string]: any };
  export type InterviewAddUsersResponse = {};
  export type InterviewCreateRequest = { [key: string]: any };
  export type InterviewCreateResponse = {};
  export type InterviewDetailsRequest = { [key: string]: any };
  export type _InterviewDetailsServerResponse = any;
  export type InterviewDetailsResponse = {
    description?: string;
    contest_alias?: string;
    problemset_id?: number;
    users: {
      user_id?: number;
      username: string;
      access_time?: Date;
      email?: string;
      opened_interview: boolean;
      country?: string;
    }[];
    exists: boolean;
  };
  export type InterviewListRequest = { [key: string]: any };
  export type InterviewListResponse = {
    result: {
      acl_id: number;
      alias: string;
      description: string;
      interview_id: number;
      problemset_id: number;
      title: string;
      window_length: number;
    }[];
  };

  // Notification
  export type NotificationMyListRequest = { [key: string]: any };
  export type _NotificationMyListServerResponse = any;
  export type NotificationMyListResponse = {
    notifications: types.Notification[];
  };
  export type NotificationReadNotificationsRequest = { [key: string]: any };
  export type NotificationReadNotificationsResponse = {};

  // Problem
  export type ProblemAddAdminRequest = { [key: string]: any };
  export type ProblemAddAdminResponse = {};
  export type ProblemAddGroupAdminRequest = { [key: string]: any };
  export type ProblemAddGroupAdminResponse = {};
  export type ProblemAddTagRequest = { [key: string]: any };
  export type ProblemAddTagResponse = { name: string };
  export type ProblemAdminListRequest = { [key: string]: any };
  export type ProblemAdminListResponse = {
    pagerItems: types.PageItem[];
    problems: { tags: { name: string; source: string }[] }[];
  };
  export type ProblemAdminsRequest = { [key: string]: any };
  export type ProblemAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  export type ProblemBestScoreRequest = { [key: string]: any };
  export type ProblemBestScoreResponse = { score: number };
  export type ProblemClarificationsRequest = { [key: string]: any };
  export type _ProblemClarificationsServerResponse = any;
  export type ProblemClarificationsResponse = {
    clarifications: {
      clarification_id: number;
      contest_alias: string;
      author?: string;
      message: string;
      time: Date;
      answer?: string;
      public: boolean;
    }[];
  };
  export type ProblemCreateRequest = { [key: string]: any };
  export type ProblemCreateResponse = {};
  export type ProblemDeleteRequest = { [key: string]: any };
  export type ProblemDeleteResponse = {};
  export type ProblemDetailsRequest = { [key: string]: any };
  export type _ProblemDetailsServerResponse = any;
  export type ProblemDetailsResponse = {
    accepted: number;
    admin: boolean;
    alias: string;
    commit: string;
    creation_date: number;
    difficulty?: number;
    email_clarifications: boolean;
    exists: boolean;
    input_limit: number;
    languages: string[];
    order: string;
    points: number;
    preferred_language: string;
    problemsetter: { creation_date: number; name: string; username: string };
    quality_seal: boolean;
    runs: {
      alias: string;
      contest_score?: number;
      guid: string;
      language: string;
      memory: number;
      penalty: number;
      runtime: number;
      score: number;
      status: string;
      submit_delay: number;
      time: Date;
      username: string;
      verdict: string;
    }[];
    score: number;
    settings: {
      cases: { [key: string]: { in: string; out: string; weight: number } };
      limits: {
        MemoryLimit: number | string;
        OverallWallTimeLimit: string;
        TimeLimit: string;
      };
      validator: { name: string; tolerance: number };
    };
    solvers: {
      language: string;
      memory: number;
      runtime: number;
      time: number;
      username: string;
    }[];
    source: string;
    statement: {
      images: { [key: string]: string };
      language: string;
      markdown: string;
    };
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  };
  export type ProblemListRequest = { [key: string]: any };
  export type ProblemListResponse = {
    results: types.ProblemListItem[];
    total: number;
  };
  export type ProblemMyListRequest = { [key: string]: any };
  export type ProblemMyListResponse = {
    pagerItems: types.PageItem[];
    problems: { tags: { name: string; source: string }[] }[];
  };
  export type ProblemRejudgeRequest = { [key: string]: any };
  export type ProblemRejudgeResponse = {};
  export type ProblemRemoveAdminRequest = { [key: string]: any };
  export type ProblemRemoveAdminResponse = {};
  export type ProblemRemoveGroupAdminRequest = { [key: string]: any };
  export type ProblemRemoveGroupAdminResponse = {};
  export type ProblemRemoveTagRequest = { [key: string]: any };
  export type ProblemRemoveTagResponse = {};
  export type ProblemRunsRequest = { [key: string]: any };
  export type _ProblemRunsServerResponse = any;
  export type ProblemRunsResponse = {
    runs: {
      guid: string;
      language: string;
      status: string;
      verdict: string;
      runtime: number;
      penalty: number;
      memory: number;
      score: number;
      contest_score?: number;
      time: Date;
      submit_delay: number;
      alias: string;
      username: string;
      run_id: number;
      judged_by?: string;
      type?: string;
      country_id?: string;
      contest_alias?: string;
    }[];
  };
  export type ProblemRunsDiffRequest = { [key: string]: any };
  export type ProblemRunsDiffResponse = {
    diff: {
      username: string;
      guid: string;
      problemset_id?: number;
      old_status?: string;
      old_verdict?: string;
      old_score?: number;
      new_status?: string;
      new_verdict?: string;
      new_score?: number;
    }[];
  };
  export type ProblemSelectVersionRequest = { [key: string]: any };
  export type ProblemSelectVersionResponse = {};
  export type ProblemSolutionRequest = { [key: string]: any };
  export type ProblemSolutionResponse = {
    exists: boolean;
    solution: {
      language: string;
      markdown: string;
      images: { [key: string]: string };
    };
  };
  export type ProblemStatsRequest = { [key: string]: any };
  export type ProblemStatsResponse = {
    cases_stats: { [key: string]: number };
    pending_runs: string[];
    total_runs: number;
    verdict_counts: { [key: string]: number };
  };
  export type ProblemTagsRequest = { [key: string]: any };
  export type ProblemTagsResponse = {
    tags: { name: string; public: boolean }[];
  };
  export type ProblemUpdateRequest = { [key: string]: any };
  export type ProblemUpdateResponse = { rejudged: boolean };
  export type ProblemUpdateSolutionRequest = { [key: string]: any };
  export type ProblemUpdateSolutionResponse = {};
  export type ProblemUpdateStatementRequest = { [key: string]: any };
  export type ProblemUpdateStatementResponse = {};
  export type ProblemVersionsRequest = { [key: string]: any };
  export type ProblemVersionsResponse = {
    published?: string;
    log: {
      commit: string;
      tree?: { [key: string]: string };
      parents: string[];
      author: { name: string; email: string; time?: number | string };
      committer: { name: string; email: string; time?: number | string };
      message: string;
      version?: string;
    }[];
  };

  // ProblemForfeited
  export type ProblemForfeitedGetCountsRequest = { [key: string]: any };
  export type ProblemForfeitedGetCountsResponse = {
    allowed: number;
    seen: number;
  };

  // Problemset
  export type ProblemsetDetailsRequest = { [key: string]: any };
  export type _ProblemsetDetailsServerResponse = any;
  export type ProblemsetDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    assignment_type?: string;
    contest_alias?: string;
    description?: string;
    director?: string | dao.Identities;
    exists: boolean;
    feedback: string;
    finish_time?: number;
    languages: string[];
    name?: string;
    needs_basic_information: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problems: types.ProblemsetProblem[];
    problemset_id?: number;
    requests_user_information: string;
    scoreboard: number;
    show_scoreboard_after: boolean;
    start_time: number;
    submission_deadline: number;
    submissions_gap: number;
    title: string;
    users: {
      access_time?: Date;
      country?: string;
      email?: string;
      opened_interview: boolean;
      user_id?: number;
      username: string;
    }[];
    window_length?: number;
  };
  export type ProblemsetScoreboardRequest = { [key: string]: any };
  export type ProblemsetScoreboardResponse = types.Scoreboard;
  export type ProblemsetScoreboardEventsRequest = { [key: string]: any };
  export type ProblemsetScoreboardEventsResponse = {
    events: {
      country?: string;
      delta: number;
      is_invited: boolean;
      total: { points: number; penalty: number };
      name?: string;
      username: string;
      problem: { alias: string; points: number; penalty: number };
    }[];
  };

  // QualityNomination
  export type QualityNominationCreateRequest = { [key: string]: any };
  export type QualityNominationCreateResponse = {
    qualitynomination_id: number;
  };
  export type QualityNominationDetailsRequest = { [key: string]: any };
  export type QualityNominationDetailsResponse = {
    author: { name?: string; username: string };
    contents: {
      before_ac: boolean;
      difficulty: number;
      quality: number;
      rationale: string;
      reason: string;
      statements: { [key: string]: string };
      tags: string[];
    };
    nomination: string;
    nomination_status: string;
    nominator: { name?: string; username: string };
    original_contents: {
      source?: string;
      statements: {
        [key: string]: {
          language: string;
          markdown: string;
          images: { [key: string]: string };
        };
      };
      tags: { source: string; name: string }[];
    };
    problem: { alias: string; title: string };
    qualitynomination_id: number;
    reviewer: boolean;
    time: number;
    votes: {
      time?: number;
      user: { name?: string; username: string };
      vote: number;
    }[];
  };
  export type QualityNominationListRequest = { [key: string]: any };
  export type QualityNominationListResponse = {
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: number;
            quality: number;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: number;
          status: string;
          time: number;
          votes: {
            time?: number;
            user: { name?: string; username: string };
            vote: number;
          }[];
        }
      | null[];
    pager_items: { class: string; label: string; page: number }[];
  };
  export type QualityNominationMyAssignedListRequest = { [key: string]: any };
  export type QualityNominationMyAssignedListResponse = {
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: number;
            quality: number;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: number;
          status: string;
          time: number;
          votes: {
            time?: number;
            user: { name?: string; username: string };
            vote: number;
          }[];
        }
      | null[];
  };
  export type QualityNominationMyListRequest = { [key: string]: any };
  export type QualityNominationMyListResponse = {
    nominations:
      | {
          author: { name?: string; username: string };
          contents: {
            before_ac: boolean;
            difficulty: number;
            quality: number;
            rationale: string;
            reason: string;
            statements: { [key: string]: string };
            tags: string[];
          };
          nomination: string;
          nominator: { name?: string; username: string };
          problem: { alias: string; title: string };
          qualitynomination_id: number;
          status: string;
          time: number;
          votes: {
            time?: number;
            user: { name?: string; username: string };
            vote: number;
          }[];
        }
      | null[];
    pager_items: { class: string; label: string; page: number }[];
  };
  export type QualityNominationResolveRequest = { [key: string]: any };
  export type QualityNominationResolveResponse = {};

  // Reset
  export type ResetCreateRequest = { [key: string]: any };
  export type ResetCreateResponse = { message: string; token: string };
  export type ResetGenerateTokenRequest = { [key: string]: any };
  export type ResetGenerateTokenResponse = { link: string; token: string };
  export type ResetUpdateRequest = { [key: string]: any };
  export type ResetUpdateResponse = { message: string };

  // Run
  export type RunCountsRequest = { [key: string]: any };
  export type RunCountsResponse = {
    total: { [key: string]: number };
    ac: { [key: string]: number };
  };
  export type RunCreateRequest = { [key: string]: any };
  export type RunCreateResponse = {
    guid: string;
    submission_deadline: number;
    nextSubmissionTimestamp: number;
  };
  export type RunDetailsRequest = { [key: string]: any };
  export type RunDetailsResponse = {
    admin: boolean;
    compile_error: string;
    details: {
      compile_meta: {
        [key: string]: {
          memory: number;
          sys_time: number;
          time: number;
          verdict: string;
          wall_time: number;
        };
      };
      contest_score: number;
      groups: {
        cases: {
          contest_score: number;
          max_score: number;
          meta: { verdict: string };
          name: string;
          score: number;
          verdict: string;
        }[];
        contest_score: number;
        group: string;
        max_score: number;
        score: number;
      }[];
      judged_by: string;
      max_score: number;
      memory: number;
      score: number;
      time: number;
      verdict: string;
      wall_time: number;
    };
    guid: string;
    judged_by: string;
    language: string;
    logs: string;
    source: string;
  };
  export type RunDisqualifyRequest = { [key: string]: any };
  export type RunDisqualifyResponse = {};
  export type RunListRequest = { [key: string]: any };
  export type _RunListServerResponse = any;
  export type RunListResponse = {
    runs: {
      alias: string;
      contest_alias?: string;
      contest_score?: number;
      country_id?: string;
      guid: string;
      judged_by?: string;
      language: string;
      memory: number;
      penalty: number;
      run_id: number;
      runtime: number;
      score: number;
      submit_delay: number;
      time: Date;
      type?: string;
      username: string;
      verdict: string;
    }[];
  };
  export type RunRejudgeRequest = { [key: string]: any };
  export type RunRejudgeResponse = {};
  export type RunSourceRequest = { [key: string]: any };
  export type RunSourceResponse = {
    compile_error: string;
    details: {
      compile_meta: {
        [key: string]: {
          memory: number;
          sys_time: number;
          time: number;
          verdict: string;
          wall_time: number;
        };
      };
      contest_score: number;
      groups: {
        cases: {
          contest_score: number;
          max_score: number;
          meta: { verdict: string };
          name: string;
          score: number;
          verdict: string;
        }[];
        contest_score: number;
        group: string;
        max_score: number;
        score: number;
      }[];
      judged_by: string;
      max_score: number;
      memory: number;
      score: number;
      time: number;
      verdict: string;
      wall_time: number;
    };
    source: string;
  };
  export type RunStatusRequest = { [key: string]: any };
  export type _RunStatusServerResponse = any;
  export type RunStatusResponse = {
    contest_score?: number;
    memory: number;
    penalty: number;
    runtime: number;
    score: number;
    submit_delay: number;
    time: Date;
  };

  // School
  export type SchoolCreateRequest = { [key: string]: any };
  export type SchoolCreateResponse = { school_id: number };
  export type SchoolListRequest = { [key: string]: any };
  export type SchoolListResponse = {
    id: number;
    label: string;
    value: string;
  }[];
  export type SchoolMonthlySolvedProblemsCountRequest = { [key: string]: any };
  export type SchoolMonthlySolvedProblemsCountResponse = {
    distinct_problems_solved: {
      month: number;
      problems_solved: number;
      year: number;
    }[];
  };
  export type SchoolRankRequest = { [key: string]: any };
  export type SchoolRankResponse = {
    rank: {
      country_id?: string;
      name: string;
      ranking?: number;
      school_id: number;
      score: number;
    }[];
    totalRows: number;
  };
  export type SchoolSchoolCodersOfTheMonthRequest = { [key: string]: any };
  export type SchoolSchoolCodersOfTheMonthResponse = {
    coders: { time: string; username: string; classname: string }[];
  };
  export type SchoolSelectSchoolOfTheMonthRequest = { [key: string]: any };
  export type SchoolSelectSchoolOfTheMonthResponse = {};
  export type SchoolUsersRequest = { [key: string]: any };
  export type SchoolUsersResponse = {
    users: {
      username: string;
      classname: string;
      created_problems: number;
      solved_problems: number;
      organized_contests: number;
    }[];
  };

  // Scoreboard
  export type ScoreboardRefreshRequest = { [key: string]: any };
  export type ScoreboardRefreshResponse = {};

  // Session
  export type SessionCurrentSessionRequest = { [key: string]: any };
  export type SessionCurrentSessionResponse = {
    session?: {
      valid: boolean;
      email?: string;
      user?: dao.Users;
      identity?: dao.Identities;
      auth_token?: string;
      is_admin: boolean;
    };
    time: number;
  };
  export type SessionGoogleLoginRequest = { [key: string]: any };
  export type SessionGoogleLoginResponse = { [key: string]: string };

  // Submission
  export type SubmissionLatestSubmissionsRequest = { [key: string]: any };
  export type SubmissionLatestSubmissionsResponse = {
    submissions: {
      time: number;
      username: string;
      school_id?: number;
      school_name?: string;
      alias: string;
      title: string;
      language: string;
      verdict: string;
      runtime: number;
      memory: number;
    }[];
    totalRows: number;
  };

  // Tag
  export type TagListRequest = { [key: string]: any };
  export type TagListResponse = { name: string }[];

  // Time
  export type TimeGetRequest = { [key: string]: any };
  export type TimeGetResponse = { time: number };

  // User
  export type UserAcceptPrivacyPolicyRequest = { [key: string]: any };
  export type UserAcceptPrivacyPolicyResponse = {};
  export type UserAddExperimentRequest = { [key: string]: any };
  export type UserAddExperimentResponse = {};
  export type UserAddGroupRequest = { [key: string]: any };
  export type UserAddGroupResponse = {};
  export type UserAddRoleRequest = { [key: string]: any };
  export type UserAddRoleResponse = {};
  export type UserAssociateIdentityRequest = { [key: string]: any };
  export type UserAssociateIdentityResponse = {};
  export type UserChangePasswordRequest = { [key: string]: any };
  export type UserChangePasswordResponse = {};
  export type UserCoderOfTheMonthRequest = { [key: string]: any };
  export type UserCoderOfTheMonthResponse = {
    coderinfo?: {
      birth_date?: number;
      country?: string;
      country_id?: string;
      email?: string;
      gender?: string;
      graduation_date?: number;
      gravatar_92: string;
      hide_problem_tags?: boolean;
      is_private: boolean;
      locale: string;
      name?: string;
      preferred_language?: string;
      scholar_degree?: string;
      school?: string;
      school_id?: number;
      state?: string;
      state_id?: string;
      username?: string;
      verified: boolean;
    };
  };
  export type UserCoderOfTheMonthListRequest = { [key: string]: any };
  export type UserCoderOfTheMonthListResponse = {
    coders: {
      username: string;
      country_id: string;
      gravatar_32: string;
      date: string;
      classname: string;
    }[];
  };
  export type UserContestStatsRequest = { [key: string]: any };
  export type _UserContestStatsServerResponse = any;
  export type UserContestStatsResponse = {
    contests: {
      [key: string]: {
        data: {
          alias: string;
          title: string;
          start_time: Date;
          finish_time: Date;
          last_updated: Date;
        };
        place?: number;
      };
    };
  };
  export type UserCreateRequest = { [key: string]: any };
  export type UserCreateResponse = { username: string };
  export type UserExtraInformationRequest = { [key: string]: any };
  export type UserExtraInformationResponse = {
    within_last_day: boolean;
    verified: boolean;
    username: string;
    last_login?: number;
  };
  export type UserGenerateGitTokenRequest = { [key: string]: any };
  export type UserGenerateGitTokenResponse = { token: string };
  export type UserGenerateOmiUsersRequest = { [key: string]: any };
  export type UserGenerateOmiUsersResponse = { [key: string]: string };
  export type UserInterviewStatsRequest = { [key: string]: any };
  export type UserInterviewStatsResponse = {
    user_verified: boolean;
    interview_url: string;
    name_or_username?: string;
    opened_interview: boolean;
    finished: boolean;
  };
  export type UserLastPrivacyPolicyAcceptedRequest = { [key: string]: any };
  export type UserLastPrivacyPolicyAcceptedResponse = { hasAccepted: boolean };
  export type UserListRequest = { [key: string]: any };
  export type UserListResponse = types.UserListItem[];
  export type UserListAssociatedIdentitiesRequest = { [key: string]: any };
  export type UserListAssociatedIdentitiesResponse = {
    identities: { username: string; default: boolean }[];
  };
  export type UserListUnsolvedProblemsRequest = { [key: string]: any };
  export type UserListUnsolvedProblemsResponse = { problems: types.Problem[] };
  export type UserLoginRequest = { [key: string]: any };
  export type UserLoginResponse = { auth_token: string };
  export type UserMailingListBackfillRequest = { [key: string]: any };
  export type UserMailingListBackfillResponse = {
    users: { [key: string]: boolean };
  };
  export type UserProblemsCreatedRequest = { [key: string]: any };
  export type UserProblemsCreatedResponse = { problems: types.Problem[] };
  export type UserProblemsSolvedRequest = { [key: string]: any };
  export type UserProblemsSolvedResponse = { problems: types.Problem[] };
  export type UserProfileRequest = { [key: string]: any };
  export type UserProfileResponse = {
    birth_date?: number;
    classname: string;
    country?: string;
    country_id?: string;
    email?: string;
    gender?: string;
    graduation_date?: number;
    gravatar_92?: string;
    hide_problem_tags?: boolean;
    is_private: boolean;
    locale?: string;
    name?: string;
    preferred_language?: string;
    rankinfo: { name?: string; problems_solved?: number; rank?: number };
    scholar_degree?: string;
    school?: string;
    school_id?: number;
    state?: string;
    state_id?: string;
    username?: string;
    verified?: boolean;
  };
  export type UserRankByProblemsSolvedRequest = { [key: string]: any };
  export type UserRankByProblemsSolvedResponse = {
    rank:
      | {
          classname: string;
          country_id?: string;
          name?: string;
          problems_solved: number;
          ranking: number;
          score: number;
          user_id: number;
          username: string;
        }[]
      | number;
    total: number;
    name: string;
    problems_solved: number;
  };
  export type UserRemoveExperimentRequest = { [key: string]: any };
  export type UserRemoveExperimentResponse = {};
  export type UserRemoveGroupRequest = { [key: string]: any };
  export type UserRemoveGroupResponse = {};
  export type UserRemoveRoleRequest = { [key: string]: any };
  export type UserRemoveRoleResponse = {};
  export type UserSelectCoderOfTheMonthRequest = { [key: string]: any };
  export type UserSelectCoderOfTheMonthResponse = {};
  export type UserStatsRequest = { [key: string]: any };
  export type UserStatsResponse = {
    runs: { date?: string; runs: number; verdict: string }[];
  };
  export type UserStatusVerifiedRequest = { [key: string]: any };
  export type UserStatusVerifiedResponse = {
    username: string;
    verified: boolean;
  };
  export type UserUpdateRequest = { [key: string]: any };
  export type UserUpdateResponse = {};
  export type UserUpdateBasicInfoRequest = { [key: string]: any };
  export type UserUpdateBasicInfoResponse = {};
  export type UserUpdateMainEmailRequest = { [key: string]: any };
  export type UserUpdateMainEmailResponse = {};
  export type UserValidateFilterRequest = { [key: string]: any };
  export type UserValidateFilterResponse = {
    user?: string;
    admin: boolean;
    problem_admin: string[];
    contest_admin: string[];
    problemset_admin: number[];
  };
  export type UserVerifyEmailRequest = { [key: string]: any };
  export type UserVerifyEmailResponse = {};
}

// Controller interfaces
export namespace controllers {
  export interface Admin {
    platformReportStats: (
      params?: messages.AdminPlatformReportStatsRequest,
    ) => Promise<messages.AdminPlatformReportStatsResponse>;
  }

  export interface Authorization {
    problem: (
      params?: messages.AuthorizationProblemRequest,
    ) => Promise<messages.AuthorizationProblemResponse>;
  }

  export interface Badge {
    badgeDetails: (
      params?: messages.BadgeBadgeDetailsRequest,
    ) => Promise<messages.BadgeBadgeDetailsResponse>;
    list: (
      params?: messages.BadgeListRequest,
    ) => Promise<messages.BadgeListResponse>;
    myBadgeAssignationTime: (
      params?: messages.BadgeMyBadgeAssignationTimeRequest,
    ) => Promise<messages.BadgeMyBadgeAssignationTimeResponse>;
    myList: (
      params?: messages.BadgeMyListRequest,
    ) => Promise<messages.BadgeMyListResponse>;
    userList: (
      params?: messages.BadgeUserListRequest,
    ) => Promise<messages.BadgeUserListResponse>;
  }

  export interface Clarification {
    create: (
      params?: messages.ClarificationCreateRequest,
    ) => Promise<messages.ClarificationCreateResponse>;
    details: (
      params?: messages.ClarificationDetailsRequest,
    ) => Promise<messages.ClarificationDetailsResponse>;
    update: (
      params?: messages.ClarificationUpdateRequest,
    ) => Promise<messages.ClarificationUpdateResponse>;
  }

  export interface Contest {
    activityReport: (
      params?: messages.ContestActivityReportRequest,
    ) => Promise<messages.ContestActivityReportResponse>;
    addAdmin: (
      params?: messages.ContestAddAdminRequest,
    ) => Promise<messages.ContestAddAdminResponse>;
    addGroup: (
      params?: messages.ContestAddGroupRequest,
    ) => Promise<messages.ContestAddGroupResponse>;
    addGroupAdmin: (
      params?: messages.ContestAddGroupAdminRequest,
    ) => Promise<messages.ContestAddGroupAdminResponse>;
    addProblem: (
      params?: messages.ContestAddProblemRequest,
    ) => Promise<messages.ContestAddProblemResponse>;
    addUser: (
      params?: messages.ContestAddUserRequest,
    ) => Promise<messages.ContestAddUserResponse>;
    adminDetails: (
      params?: messages.ContestAdminDetailsRequest,
    ) => Promise<messages.ContestAdminDetailsResponse>;
    adminList: (
      params?: messages.ContestAdminListRequest,
    ) => Promise<messages.ContestAdminListResponse>;
    admins: (
      params?: messages.ContestAdminsRequest,
    ) => Promise<messages.ContestAdminsResponse>;
    arbitrateRequest: (
      params?: messages.ContestArbitrateRequestRequest,
    ) => Promise<messages.ContestArbitrateRequestResponse>;
    clarifications: (
      params?: messages.ContestClarificationsRequest,
    ) => Promise<messages.ContestClarificationsResponse>;
    clone: (
      params?: messages.ContestCloneRequest,
    ) => Promise<messages.ContestCloneResponse>;
    contestants: (
      params?: messages.ContestContestantsRequest,
    ) => Promise<messages.ContestContestantsResponse>;
    create: (
      params?: messages.ContestCreateRequest,
    ) => Promise<messages.ContestCreateResponse>;
    createVirtual: (
      params?: messages.ContestCreateVirtualRequest,
    ) => Promise<messages.ContestCreateVirtualResponse>;
    details: (
      params?: messages.ContestDetailsRequest,
    ) => Promise<messages.ContestDetailsResponse>;
    list: (
      params?: messages.ContestListRequest,
    ) => Promise<messages.ContestListResponse>;
    listParticipating: (
      params?: messages.ContestListParticipatingRequest,
    ) => Promise<messages.ContestListParticipatingResponse>;
    myList: (
      params?: messages.ContestMyListRequest,
    ) => Promise<messages.ContestMyListResponse>;
    open: (
      params?: messages.ContestOpenRequest,
    ) => Promise<messages.ContestOpenResponse>;
    problems: (
      params?: messages.ContestProblemsRequest,
    ) => Promise<messages.ContestProblemsResponse>;
    publicDetails: (
      params?: messages.ContestPublicDetailsRequest,
    ) => Promise<messages.ContestPublicDetailsResponse>;
    registerForContest: (
      params?: messages.ContestRegisterForContestRequest,
    ) => Promise<messages.ContestRegisterForContestResponse>;
    removeAdmin: (
      params?: messages.ContestRemoveAdminRequest,
    ) => Promise<messages.ContestRemoveAdminResponse>;
    removeGroup: (
      params?: messages.ContestRemoveGroupRequest,
    ) => Promise<messages.ContestRemoveGroupResponse>;
    removeGroupAdmin: (
      params?: messages.ContestRemoveGroupAdminRequest,
    ) => Promise<messages.ContestRemoveGroupAdminResponse>;
    removeProblem: (
      params?: messages.ContestRemoveProblemRequest,
    ) => Promise<messages.ContestRemoveProblemResponse>;
    removeUser: (
      params?: messages.ContestRemoveUserRequest,
    ) => Promise<messages.ContestRemoveUserResponse>;
    report: (
      params?: messages.ContestReportRequest,
    ) => Promise<messages.ContestReportResponse>;
    requests: (
      params?: messages.ContestRequestsRequest,
    ) => Promise<messages.ContestRequestsResponse>;
    role: (
      params?: messages.ContestRoleRequest,
    ) => Promise<messages.ContestRoleResponse>;
    runs: (
      params?: messages.ContestRunsRequest,
    ) => Promise<messages.ContestRunsResponse>;
    runsDiff: (
      params?: messages.ContestRunsDiffRequest,
    ) => Promise<messages.ContestRunsDiffResponse>;
    scoreboard: (
      params?: messages.ContestScoreboardRequest,
    ) => Promise<messages.ContestScoreboardResponse>;
    scoreboardEvents: (
      params?: messages.ContestScoreboardEventsRequest,
    ) => Promise<messages.ContestScoreboardEventsResponse>;
    scoreboardMerge: (
      params?: messages.ContestScoreboardMergeRequest,
    ) => Promise<messages.ContestScoreboardMergeResponse>;
    setRecommended: (
      params?: messages.ContestSetRecommendedRequest,
    ) => Promise<messages.ContestSetRecommendedResponse>;
    stats: (
      params?: messages.ContestStatsRequest,
    ) => Promise<messages.ContestStatsResponse>;
    update: (
      params?: messages.ContestUpdateRequest,
    ) => Promise<messages.ContestUpdateResponse>;
    updateEndTimeForIdentity: (
      params?: messages.ContestUpdateEndTimeForIdentityRequest,
    ) => Promise<messages.ContestUpdateEndTimeForIdentityResponse>;
    users: (
      params?: messages.ContestUsersRequest,
    ) => Promise<messages.ContestUsersResponse>;
  }

  export interface Course {
    activityReport: (
      params?: messages.CourseActivityReportRequest,
    ) => Promise<messages.CourseActivityReportResponse>;
    addAdmin: (
      params?: messages.CourseAddAdminRequest,
    ) => Promise<messages.CourseAddAdminResponse>;
    addGroupAdmin: (
      params?: messages.CourseAddGroupAdminRequest,
    ) => Promise<messages.CourseAddGroupAdminResponse>;
    addProblem: (
      params?: messages.CourseAddProblemRequest,
    ) => Promise<messages.CourseAddProblemResponse>;
    addStudent: (
      params?: messages.CourseAddStudentRequest,
    ) => Promise<messages.CourseAddStudentResponse>;
    adminDetails: (
      params?: messages.CourseAdminDetailsRequest,
    ) => Promise<messages.CourseAdminDetailsResponse>;
    admins: (
      params?: messages.CourseAdminsRequest,
    ) => Promise<messages.CourseAdminsResponse>;
    arbitrateRequest: (
      params?: messages.CourseArbitrateRequestRequest,
    ) => Promise<messages.CourseArbitrateRequestResponse>;
    assignmentDetails: (
      params?: messages.CourseAssignmentDetailsRequest,
    ) => Promise<messages.CourseAssignmentDetailsResponse>;
    assignmentScoreboard: (
      params?: messages.CourseAssignmentScoreboardRequest,
    ) => Promise<messages.CourseAssignmentScoreboardResponse>;
    assignmentScoreboardEvents: (
      params?: messages.CourseAssignmentScoreboardEventsRequest,
    ) => Promise<messages.CourseAssignmentScoreboardEventsResponse>;
    clone: (
      params?: messages.CourseCloneRequest,
    ) => Promise<messages.CourseCloneResponse>;
    create: (
      params?: messages.CourseCreateRequest,
    ) => Promise<messages.CourseCreateResponse>;
    createAssignment: (
      params?: messages.CourseCreateAssignmentRequest,
    ) => Promise<messages.CourseCreateAssignmentResponse>;
    details: (
      params?: messages.CourseDetailsRequest,
    ) => Promise<messages.CourseDetailsResponse>;
    getProblemUsers: (
      params?: messages.CourseGetProblemUsersRequest,
    ) => Promise<messages.CourseGetProblemUsersResponse>;
    introDetails: (
      params?: messages.CourseIntroDetailsRequest,
    ) => Promise<messages.CourseIntroDetailsResponse>;
    listAssignments: (
      params?: messages.CourseListAssignmentsRequest,
    ) => Promise<messages.CourseListAssignmentsResponse>;
    listCourses: (
      params?: messages.CourseListCoursesRequest,
    ) => Promise<messages.CourseListCoursesResponse>;
    listSolvedProblems: (
      params?: messages.CourseListSolvedProblemsRequest,
    ) => Promise<messages.CourseListSolvedProblemsResponse>;
    listStudents: (
      params?: messages.CourseListStudentsRequest,
    ) => Promise<messages.CourseListStudentsResponse>;
    listUnsolvedProblems: (
      params?: messages.CourseListUnsolvedProblemsRequest,
    ) => Promise<messages.CourseListUnsolvedProblemsResponse>;
    myProgress: (
      params?: messages.CourseMyProgressRequest,
    ) => Promise<messages.CourseMyProgressResponse>;
    registerForCourse: (
      params?: messages.CourseRegisterForCourseRequest,
    ) => Promise<messages.CourseRegisterForCourseResponse>;
    removeAdmin: (
      params?: messages.CourseRemoveAdminRequest,
    ) => Promise<messages.CourseRemoveAdminResponse>;
    removeGroupAdmin: (
      params?: messages.CourseRemoveGroupAdminRequest,
    ) => Promise<messages.CourseRemoveGroupAdminResponse>;
    removeProblem: (
      params?: messages.CourseRemoveProblemRequest,
    ) => Promise<messages.CourseRemoveProblemResponse>;
    removeStudent: (
      params?: messages.CourseRemoveStudentRequest,
    ) => Promise<messages.CourseRemoveStudentResponse>;
    requests: (
      params?: messages.CourseRequestsRequest,
    ) => Promise<messages.CourseRequestsResponse>;
    runs: (
      params?: messages.CourseRunsRequest,
    ) => Promise<messages.CourseRunsResponse>;
    studentProgress: (
      params?: messages.CourseStudentProgressRequest,
    ) => Promise<messages.CourseStudentProgressResponse>;
    update: (
      params?: messages.CourseUpdateRequest,
    ) => Promise<messages.CourseUpdateResponse>;
    updateAssignment: (
      params?: messages.CourseUpdateAssignmentRequest,
    ) => Promise<messages.CourseUpdateAssignmentResponse>;
    updateAssignmentsOrder: (
      params?: messages.CourseUpdateAssignmentsOrderRequest,
    ) => Promise<messages.CourseUpdateAssignmentsOrderResponse>;
    updateProblemsOrder: (
      params?: messages.CourseUpdateProblemsOrderRequest,
    ) => Promise<messages.CourseUpdateProblemsOrderResponse>;
  }

  export interface Grader {
    status: (
      params?: messages.GraderStatusRequest,
    ) => Promise<messages.GraderStatusResponse>;
  }

  export interface Group {
    addUser: (
      params?: messages.GroupAddUserRequest,
    ) => Promise<messages.GroupAddUserResponse>;
    create: (
      params?: messages.GroupCreateRequest,
    ) => Promise<messages.GroupCreateResponse>;
    createScoreboard: (
      params?: messages.GroupCreateScoreboardRequest,
    ) => Promise<messages.GroupCreateScoreboardResponse>;
    details: (
      params?: messages.GroupDetailsRequest,
    ) => Promise<messages.GroupDetailsResponse>;
    list: (
      params?: messages.GroupListRequest,
    ) => Promise<messages.GroupListResponse>;
    members: (
      params?: messages.GroupMembersRequest,
    ) => Promise<messages.GroupMembersResponse>;
    myList: (
      params?: messages.GroupMyListRequest,
    ) => Promise<messages.GroupMyListResponse>;
    removeUser: (
      params?: messages.GroupRemoveUserRequest,
    ) => Promise<messages.GroupRemoveUserResponse>;
  }

  export interface GroupScoreboard {
    addContest: (
      params?: messages.GroupScoreboardAddContestRequest,
    ) => Promise<messages.GroupScoreboardAddContestResponse>;
    details: (
      params?: messages.GroupScoreboardDetailsRequest,
    ) => Promise<messages.GroupScoreboardDetailsResponse>;
    list: (
      params?: messages.GroupScoreboardListRequest,
    ) => Promise<messages.GroupScoreboardListResponse>;
    removeContest: (
      params?: messages.GroupScoreboardRemoveContestRequest,
    ) => Promise<messages.GroupScoreboardRemoveContestResponse>;
  }

  export interface Identity {
    bulkCreate: (
      params?: messages.IdentityBulkCreateRequest,
    ) => Promise<messages.IdentityBulkCreateResponse>;
    changePassword: (
      params?: messages.IdentityChangePasswordRequest,
    ) => Promise<messages.IdentityChangePasswordResponse>;
    create: (
      params?: messages.IdentityCreateRequest,
    ) => Promise<messages.IdentityCreateResponse>;
    update: (
      params?: messages.IdentityUpdateRequest,
    ) => Promise<messages.IdentityUpdateResponse>;
  }

  export interface Interview {
    addUsers: (
      params?: messages.InterviewAddUsersRequest,
    ) => Promise<messages.InterviewAddUsersResponse>;
    create: (
      params?: messages.InterviewCreateRequest,
    ) => Promise<messages.InterviewCreateResponse>;
    details: (
      params?: messages.InterviewDetailsRequest,
    ) => Promise<messages.InterviewDetailsResponse>;
    list: (
      params?: messages.InterviewListRequest,
    ) => Promise<messages.InterviewListResponse>;
  }

  export interface Notification {
    myList: (
      params?: messages.NotificationMyListRequest,
    ) => Promise<messages.NotificationMyListResponse>;
    readNotifications: (
      params?: messages.NotificationReadNotificationsRequest,
    ) => Promise<messages.NotificationReadNotificationsResponse>;
  }

  export interface Problem {
    addAdmin: (
      params?: messages.ProblemAddAdminRequest,
    ) => Promise<messages.ProblemAddAdminResponse>;
    addGroupAdmin: (
      params?: messages.ProblemAddGroupAdminRequest,
    ) => Promise<messages.ProblemAddGroupAdminResponse>;
    addTag: (
      params?: messages.ProblemAddTagRequest,
    ) => Promise<messages.ProblemAddTagResponse>;
    adminList: (
      params?: messages.ProblemAdminListRequest,
    ) => Promise<messages.ProblemAdminListResponse>;
    admins: (
      params?: messages.ProblemAdminsRequest,
    ) => Promise<messages.ProblemAdminsResponse>;
    bestScore: (
      params?: messages.ProblemBestScoreRequest,
    ) => Promise<messages.ProblemBestScoreResponse>;
    clarifications: (
      params?: messages.ProblemClarificationsRequest,
    ) => Promise<messages.ProblemClarificationsResponse>;
    create: (
      params?: messages.ProblemCreateRequest,
    ) => Promise<messages.ProblemCreateResponse>;
    delete: (
      params?: messages.ProblemDeleteRequest,
    ) => Promise<messages.ProblemDeleteResponse>;
    details: (
      params?: messages.ProblemDetailsRequest,
    ) => Promise<messages.ProblemDetailsResponse>;
    list: (
      params?: messages.ProblemListRequest,
    ) => Promise<messages.ProblemListResponse>;
    myList: (
      params?: messages.ProblemMyListRequest,
    ) => Promise<messages.ProblemMyListResponse>;
    rejudge: (
      params?: messages.ProblemRejudgeRequest,
    ) => Promise<messages.ProblemRejudgeResponse>;
    removeAdmin: (
      params?: messages.ProblemRemoveAdminRequest,
    ) => Promise<messages.ProblemRemoveAdminResponse>;
    removeGroupAdmin: (
      params?: messages.ProblemRemoveGroupAdminRequest,
    ) => Promise<messages.ProblemRemoveGroupAdminResponse>;
    removeTag: (
      params?: messages.ProblemRemoveTagRequest,
    ) => Promise<messages.ProblemRemoveTagResponse>;
    runs: (
      params?: messages.ProblemRunsRequest,
    ) => Promise<messages.ProblemRunsResponse>;
    runsDiff: (
      params?: messages.ProblemRunsDiffRequest,
    ) => Promise<messages.ProblemRunsDiffResponse>;
    selectVersion: (
      params?: messages.ProblemSelectVersionRequest,
    ) => Promise<messages.ProblemSelectVersionResponse>;
    solution: (
      params?: messages.ProblemSolutionRequest,
    ) => Promise<messages.ProblemSolutionResponse>;
    stats: (
      params?: messages.ProblemStatsRequest,
    ) => Promise<messages.ProblemStatsResponse>;
    tags: (
      params?: messages.ProblemTagsRequest,
    ) => Promise<messages.ProblemTagsResponse>;
    update: (
      params?: messages.ProblemUpdateRequest,
    ) => Promise<messages.ProblemUpdateResponse>;
    updateSolution: (
      params?: messages.ProblemUpdateSolutionRequest,
    ) => Promise<messages.ProblemUpdateSolutionResponse>;
    updateStatement: (
      params?: messages.ProblemUpdateStatementRequest,
    ) => Promise<messages.ProblemUpdateStatementResponse>;
    versions: (
      params?: messages.ProblemVersionsRequest,
    ) => Promise<messages.ProblemVersionsResponse>;
  }

  export interface ProblemForfeited {
    getCounts: (
      params?: messages.ProblemForfeitedGetCountsRequest,
    ) => Promise<messages.ProblemForfeitedGetCountsResponse>;
  }

  export interface Problemset {
    details: (
      params?: messages.ProblemsetDetailsRequest,
    ) => Promise<messages.ProblemsetDetailsResponse>;
    scoreboard: (
      params?: messages.ProblemsetScoreboardRequest,
    ) => Promise<messages.ProblemsetScoreboardResponse>;
    scoreboardEvents: (
      params?: messages.ProblemsetScoreboardEventsRequest,
    ) => Promise<messages.ProblemsetScoreboardEventsResponse>;
  }

  export interface QualityNomination {
    create: (
      params?: messages.QualityNominationCreateRequest,
    ) => Promise<messages.QualityNominationCreateResponse>;
    details: (
      params?: messages.QualityNominationDetailsRequest,
    ) => Promise<messages.QualityNominationDetailsResponse>;
    list: (
      params?: messages.QualityNominationListRequest,
    ) => Promise<messages.QualityNominationListResponse>;
    myAssignedList: (
      params?: messages.QualityNominationMyAssignedListRequest,
    ) => Promise<messages.QualityNominationMyAssignedListResponse>;
    myList: (
      params?: messages.QualityNominationMyListRequest,
    ) => Promise<messages.QualityNominationMyListResponse>;
    resolve: (
      params?: messages.QualityNominationResolveRequest,
    ) => Promise<messages.QualityNominationResolveResponse>;
  }

  export interface Reset {
    create: (
      params?: messages.ResetCreateRequest,
    ) => Promise<messages.ResetCreateResponse>;
    generateToken: (
      params?: messages.ResetGenerateTokenRequest,
    ) => Promise<messages.ResetGenerateTokenResponse>;
    update: (
      params?: messages.ResetUpdateRequest,
    ) => Promise<messages.ResetUpdateResponse>;
  }

  export interface Run {
    counts: (
      params?: messages.RunCountsRequest,
    ) => Promise<messages.RunCountsResponse>;
    create: (
      params?: messages.RunCreateRequest,
    ) => Promise<messages.RunCreateResponse>;
    details: (
      params?: messages.RunDetailsRequest,
    ) => Promise<messages.RunDetailsResponse>;
    disqualify: (
      params?: messages.RunDisqualifyRequest,
    ) => Promise<messages.RunDisqualifyResponse>;
    list: (
      params?: messages.RunListRequest,
    ) => Promise<messages.RunListResponse>;
    rejudge: (
      params?: messages.RunRejudgeRequest,
    ) => Promise<messages.RunRejudgeResponse>;
    source: (
      params?: messages.RunSourceRequest,
    ) => Promise<messages.RunSourceResponse>;
    status: (
      params?: messages.RunStatusRequest,
    ) => Promise<messages.RunStatusResponse>;
  }

  export interface School {
    create: (
      params?: messages.SchoolCreateRequest,
    ) => Promise<messages.SchoolCreateResponse>;
    list: (
      params?: messages.SchoolListRequest,
    ) => Promise<messages.SchoolListResponse>;
    monthlySolvedProblemsCount: (
      params?: messages.SchoolMonthlySolvedProblemsCountRequest,
    ) => Promise<messages.SchoolMonthlySolvedProblemsCountResponse>;
    rank: (
      params?: messages.SchoolRankRequest,
    ) => Promise<messages.SchoolRankResponse>;
    schoolCodersOfTheMonth: (
      params?: messages.SchoolSchoolCodersOfTheMonthRequest,
    ) => Promise<messages.SchoolSchoolCodersOfTheMonthResponse>;
    selectSchoolOfTheMonth: (
      params?: messages.SchoolSelectSchoolOfTheMonthRequest,
    ) => Promise<messages.SchoolSelectSchoolOfTheMonthResponse>;
    users: (
      params?: messages.SchoolUsersRequest,
    ) => Promise<messages.SchoolUsersResponse>;
  }

  export interface Scoreboard {
    refresh: (
      params?: messages.ScoreboardRefreshRequest,
    ) => Promise<messages.ScoreboardRefreshResponse>;
  }

  export interface Session {
    currentSession: (
      params?: messages.SessionCurrentSessionRequest,
    ) => Promise<messages.SessionCurrentSessionResponse>;
    googleLogin: (
      params?: messages.SessionGoogleLoginRequest,
    ) => Promise<messages.SessionGoogleLoginResponse>;
  }

  export interface Submission {
    latestSubmissions: (
      params?: messages.SubmissionLatestSubmissionsRequest,
    ) => Promise<messages.SubmissionLatestSubmissionsResponse>;
  }

  export interface Tag {
    list: (
      params?: messages.TagListRequest,
    ) => Promise<messages.TagListResponse>;
  }

  export interface Time {
    get: (
      params?: messages.TimeGetRequest,
    ) => Promise<messages.TimeGetResponse>;
  }

  export interface User {
    acceptPrivacyPolicy: (
      params?: messages.UserAcceptPrivacyPolicyRequest,
    ) => Promise<messages.UserAcceptPrivacyPolicyResponse>;
    addExperiment: (
      params?: messages.UserAddExperimentRequest,
    ) => Promise<messages.UserAddExperimentResponse>;
    addGroup: (
      params?: messages.UserAddGroupRequest,
    ) => Promise<messages.UserAddGroupResponse>;
    addRole: (
      params?: messages.UserAddRoleRequest,
    ) => Promise<messages.UserAddRoleResponse>;
    associateIdentity: (
      params?: messages.UserAssociateIdentityRequest,
    ) => Promise<messages.UserAssociateIdentityResponse>;
    changePassword: (
      params?: messages.UserChangePasswordRequest,
    ) => Promise<messages.UserChangePasswordResponse>;
    coderOfTheMonth: (
      params?: messages.UserCoderOfTheMonthRequest,
    ) => Promise<messages.UserCoderOfTheMonthResponse>;
    coderOfTheMonthList: (
      params?: messages.UserCoderOfTheMonthListRequest,
    ) => Promise<messages.UserCoderOfTheMonthListResponse>;
    contestStats: (
      params?: messages.UserContestStatsRequest,
    ) => Promise<messages.UserContestStatsResponse>;
    create: (
      params?: messages.UserCreateRequest,
    ) => Promise<messages.UserCreateResponse>;
    extraInformation: (
      params?: messages.UserExtraInformationRequest,
    ) => Promise<messages.UserExtraInformationResponse>;
    generateGitToken: (
      params?: messages.UserGenerateGitTokenRequest,
    ) => Promise<messages.UserGenerateGitTokenResponse>;
    generateOmiUsers: (
      params?: messages.UserGenerateOmiUsersRequest,
    ) => Promise<messages.UserGenerateOmiUsersResponse>;
    interviewStats: (
      params?: messages.UserInterviewStatsRequest,
    ) => Promise<messages.UserInterviewStatsResponse>;
    lastPrivacyPolicyAccepted: (
      params?: messages.UserLastPrivacyPolicyAcceptedRequest,
    ) => Promise<messages.UserLastPrivacyPolicyAcceptedResponse>;
    list: (
      params?: messages.UserListRequest,
    ) => Promise<messages.UserListResponse>;
    listAssociatedIdentities: (
      params?: messages.UserListAssociatedIdentitiesRequest,
    ) => Promise<messages.UserListAssociatedIdentitiesResponse>;
    listUnsolvedProblems: (
      params?: messages.UserListUnsolvedProblemsRequest,
    ) => Promise<messages.UserListUnsolvedProblemsResponse>;
    login: (
      params?: messages.UserLoginRequest,
    ) => Promise<messages.UserLoginResponse>;
    mailingListBackfill: (
      params?: messages.UserMailingListBackfillRequest,
    ) => Promise<messages.UserMailingListBackfillResponse>;
    problemsCreated: (
      params?: messages.UserProblemsCreatedRequest,
    ) => Promise<messages.UserProblemsCreatedResponse>;
    problemsSolved: (
      params?: messages.UserProblemsSolvedRequest,
    ) => Promise<messages.UserProblemsSolvedResponse>;
    profile: (
      params?: messages.UserProfileRequest,
    ) => Promise<messages.UserProfileResponse>;
    rankByProblemsSolved: (
      params?: messages.UserRankByProblemsSolvedRequest,
    ) => Promise<messages.UserRankByProblemsSolvedResponse>;
    removeExperiment: (
      params?: messages.UserRemoveExperimentRequest,
    ) => Promise<messages.UserRemoveExperimentResponse>;
    removeGroup: (
      params?: messages.UserRemoveGroupRequest,
    ) => Promise<messages.UserRemoveGroupResponse>;
    removeRole: (
      params?: messages.UserRemoveRoleRequest,
    ) => Promise<messages.UserRemoveRoleResponse>;
    selectCoderOfTheMonth: (
      params?: messages.UserSelectCoderOfTheMonthRequest,
    ) => Promise<messages.UserSelectCoderOfTheMonthResponse>;
    stats: (
      params?: messages.UserStatsRequest,
    ) => Promise<messages.UserStatsResponse>;
    statusVerified: (
      params?: messages.UserStatusVerifiedRequest,
    ) => Promise<messages.UserStatusVerifiedResponse>;
    update: (
      params?: messages.UserUpdateRequest,
    ) => Promise<messages.UserUpdateResponse>;
    updateBasicInfo: (
      params?: messages.UserUpdateBasicInfoRequest,
    ) => Promise<messages.UserUpdateBasicInfoResponse>;
    updateMainEmail: (
      params?: messages.UserUpdateMainEmailRequest,
    ) => Promise<messages.UserUpdateMainEmailResponse>;
    validateFilter: (
      params?: messages.UserValidateFilterRequest,
    ) => Promise<messages.UserValidateFilterResponse>;
    verifyEmail: (
      params?: messages.UserVerifyEmailRequest,
    ) => Promise<messages.UserVerifyEmailResponse>;
  }
}
