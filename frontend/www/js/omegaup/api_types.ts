// generated by frontend/server/cmd/APITool.php. DO NOT EDIT.

// DAO types
export namespace dao {
  export interface Identities {
    country_id?: string;
    current_identity_school_id?: number;
    gender?: string;
    identity_id?: number;
    language_id?: number;
    name?: string;
    password?: string;
    state_id?: string;
    user_id?: number;
    username?: string;
  }

  export interface Users {
    birth_date?: string;
    facebook_user_id?: string;
    git_token?: string;
    hide_problem_tags?: boolean;
    in_mailing_list?: boolean;
    is_private?: boolean;
    main_email_id?: number;
    main_identity_id?: number;
    preferred_language?: string;
    reset_digest?: string;
    reset_sent_at?: Date;
    scholar_degree?: string;
    user_id?: number;
    verification_id?: string;
    verified?: boolean;
  }
}

// Type aliases
export namespace types {
  export namespace payloadParsers {
    export function AuthorRankTablePayload(
      elementId: string = 'payload',
    ): types.AuthorRankTablePayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function BadgeDetailsPayload(
      elementId: string = 'payload',
    ): types.BadgeDetailsPayload {
      return ((x) => {
        x.badge = ((x) => {
          if (x.assignation_time)
            x.assignation_time = ((x: number) => new Date(x * 1000))(
              x.assignation_time,
            );
          if (x.first_assignation)
            x.first_assignation = ((x: number) => new Date(x * 1000))(
              x.first_assignation,
            );
          return x;
        })(x.badge);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function BadgeListPayload(
      elementId: string = 'payload',
    ): types.BadgeListPayload {
      return ((x) => {
        x.ownedBadges = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.assignation_time)
              x.assignation_time = ((x: number) => new Date(x * 1000))(
                x.assignation_time,
              );
            if (x.first_assignation)
              x.first_assignation = ((x: number) => new Date(x * 1000))(
                x.first_assignation,
              );
            return x;
          });
        })(x.ownedBadges);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CoderOfTheMonthPayload(
      elementId: string = 'payload',
    ): types.CoderOfTheMonthPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function CommonPayload(
      elementId: string = 'payload',
    ): types.CommonPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ContestEditPayload(
      elementId: string = 'payload',
    ): types.ContestEditPayload {
      return ((x) => {
        x.details = ((x) => {
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.details);
        x.requests = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.last_update)
              x.last_update = ((x: number) => new Date(x * 1000))(
                x.last_update,
              );
            x.request_time = ((x: number) => new Date(x * 1000))(
              x.request_time,
            );
            return x;
          });
        })(x.requests);
        x.users = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.access_time)
              x.access_time = ((x: number) => new Date(x * 1000))(
                x.access_time,
              );
            if (x.end_time)
              x.end_time = ((x: number) => new Date(x * 1000))(x.end_time);
            return x;
          });
        })(x.users);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ContestIntroPayload(
      elementId: string = 'payload',
    ): types.ContestIntroPayload {
      return ((x) => {
        x.contest = ((x) => {
          x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.contest);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ContestListMinePayload(
      elementId: string = 'payload',
    ): types.ContestListMinePayload {
      return ((x) => {
        x.contests = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
            x.last_updated = ((x: number) => new Date(x * 1000))(
              x.last_updated,
            );
            if (x.original_finish_time)
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          });
        })(x.contests);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ContestListPayload(
      elementId: string = 'payload',
    ): types.ContestListPayload {
      return ((x) => {
        x.contests = ((x) => {
          x.current = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.current);
          x.future = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.future);
          if (x.participating)
            x.participating = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                x.finish_time = ((x: number) => new Date(x * 1000))(
                  x.finish_time,
                );
                x.last_updated = ((x: number) => new Date(x * 1000))(
                  x.last_updated,
                );
                x.original_finish_time = ((x: number) => new Date(x * 1000))(
                  x.original_finish_time,
                );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.participating);
          x.past = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.past);
          x.public = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.public);
          x.recommended_current = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.recommended_current);
          x.recommended_past = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
              x.last_updated = ((x: number) => new Date(x * 1000))(
                x.last_updated,
              );
              x.original_finish_time = ((x: number) => new Date(x * 1000))(
                x.original_finish_time,
              );
              x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
              return x;
            });
          })(x.recommended_past);
          return x;
        })(x.contests);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ContestNewPayload(
      elementId: string = 'payload',
    ): types.ContestNewPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function CourseAssignmentEditPayload(
      elementId: string = 'payload',
    ): types.CourseAssignmentEditPayload {
      return ((x) => {
        if (x.assignment)
          x.assignment = ((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          })(x.assignment);
        x.course = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.course);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseDetailsPayload(
      elementId: string = 'payload',
    ): types.CourseDetailsPayload {
      return ((x) => {
        x.details = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.details);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseEditPayload(
      elementId: string = 'payload',
    ): types.CourseEditPayload {
      return ((x) => {
        x.course = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.course);
        x.identityRequests = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.last_update)
              x.last_update = ((x: number) => new Date(x * 1000))(
                x.last_update,
              );
            x.request_time = ((x: number) => new Date(x * 1000))(
              x.request_time,
            );
            return x;
          });
        })(x.identityRequests);
        if (x.selectedAssignment)
          x.selectedAssignment = ((x) => {
            if (x.finish_time)
              x.finish_time = ((x: number) => new Date(x * 1000))(
                x.finish_time,
              );
            x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
            return x;
          })(x.selectedAssignment);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseListMinePayload(
      elementId: string = 'payload',
    ): types.CourseListMinePayload {
      return ((x) => {
        x.courses = ((x) => {
          x.admin = ((x) => {
            x.filteredCourses = ((x) => {
              x.current = ((x) => {
                x.courses = ((x) => {
                  if (!Array.isArray(x)) {
                    return x;
                  }
                  return x.map((x) => {
                    x.assignments = ((x) => {
                      if (!Array.isArray(x)) {
                        return x;
                      }
                      return x.map((x) => {
                        if (x.finish_time)
                          x.finish_time = ((x: number) => new Date(x * 1000))(
                            x.finish_time,
                          );
                        x.start_time = ((x: number) => new Date(x * 1000))(
                          x.start_time,
                        );
                        return x;
                      });
                    })(x.assignments);
                    if (x.finish_time)
                      x.finish_time = ((x: number) => new Date(x * 1000))(
                        x.finish_time,
                      );
                    x.start_time = ((x: number) => new Date(x * 1000))(
                      x.start_time,
                    );
                    return x;
                  });
                })(x.courses);
                return x;
              })(x.current);
              x.past = ((x) => {
                x.courses = ((x) => {
                  if (!Array.isArray(x)) {
                    return x;
                  }
                  return x.map((x) => {
                    x.assignments = ((x) => {
                      if (!Array.isArray(x)) {
                        return x;
                      }
                      return x.map((x) => {
                        if (x.finish_time)
                          x.finish_time = ((x: number) => new Date(x * 1000))(
                            x.finish_time,
                          );
                        x.start_time = ((x: number) => new Date(x * 1000))(
                          x.start_time,
                        );
                        return x;
                      });
                    })(x.assignments);
                    if (x.finish_time)
                      x.finish_time = ((x: number) => new Date(x * 1000))(
                        x.finish_time,
                      );
                    x.start_time = ((x: number) => new Date(x * 1000))(
                      x.start_time,
                    );
                    return x;
                  });
                })(x.courses);
                return x;
              })(x.past);
              return x;
            })(x.filteredCourses);
            return x;
          })(x.admin);
          return x;
        })(x.courses);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseListPayload(
      elementId: string = 'payload',
    ): types.CourseListPayload {
      return ((x) => {
        x.courses = ((x) => {
          if (x instanceof Object) {
            Object.keys(x).forEach(
              (y) =>
                (x[y] = ((x) => {
                  x.filteredCourses = ((x) => {
                    x.current = ((x) => {
                      x.courses = ((x) => {
                        if (!Array.isArray(x)) {
                          return x;
                        }
                        return x.map((x) => {
                          x.assignments = ((x) => {
                            if (!Array.isArray(x)) {
                              return x;
                            }
                            return x.map((x) => {
                              if (x.finish_time)
                                x.finish_time = ((x: number) =>
                                  new Date(x * 1000))(x.finish_time);
                              x.start_time = ((x: number) =>
                                new Date(x * 1000))(x.start_time);
                              return x;
                            });
                          })(x.assignments);
                          if (x.finish_time)
                            x.finish_time = ((x: number) => new Date(x * 1000))(
                              x.finish_time,
                            );
                          x.start_time = ((x: number) => new Date(x * 1000))(
                            x.start_time,
                          );
                          return x;
                        });
                      })(x.courses);
                      return x;
                    })(x.current);
                    x.past = ((x) => {
                      x.courses = ((x) => {
                        if (!Array.isArray(x)) {
                          return x;
                        }
                        return x.map((x) => {
                          x.assignments = ((x) => {
                            if (!Array.isArray(x)) {
                              return x;
                            }
                            return x.map((x) => {
                              if (x.finish_time)
                                x.finish_time = ((x: number) =>
                                  new Date(x * 1000))(x.finish_time);
                              x.start_time = ((x: number) =>
                                new Date(x * 1000))(x.start_time);
                              return x;
                            });
                          })(x.assignments);
                          if (x.finish_time)
                            x.finish_time = ((x: number) => new Date(x * 1000))(
                              x.finish_time,
                            );
                          x.start_time = ((x: number) => new Date(x * 1000))(
                            x.start_time,
                          );
                          return x;
                        });
                      })(x.courses);
                      return x;
                    })(x.past);
                    return x;
                  })(x.filteredCourses);
                  return x;
                })(x[y])),
            );
          }
          return x;
        })(x.courses);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseNewPayload(
      elementId: string = 'payload',
    ): types.CourseNewPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function CourseStatisticsPayload(
      elementId: string = 'payload',
    ): types.CourseStatisticsPayload {
      return ((x) => {
        x.course = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.course);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function CourseSubmissionsListPayload(
      elementId: string = 'payload',
    ): types.CourseSubmissionsListPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function IndexPayload(
      elementId: string = 'payload',
    ): types.IndexPayload {
      return ((x) => {
        x.coderOfTheMonthData = ((x) => {
          if (x.all)
            x.all = ((x) => {
              if (x.birth_date)
                x.birth_date = ((x: number) => new Date(x * 1000))(
                  x.birth_date,
                );
              if (x.graduation_date)
                x.graduation_date = ((x: number) => new Date(x * 1000))(
                  x.graduation_date,
                );
              return x;
            })(x.all);
          if (x.female)
            x.female = ((x) => {
              if (x.birth_date)
                x.birth_date = ((x: number) => new Date(x * 1000))(
                  x.birth_date,
                );
              if (x.graduation_date)
                x.graduation_date = ((x: number) => new Date(x * 1000))(
                  x.graduation_date,
                );
              return x;
            })(x.female);
          return x;
        })(x.coderOfTheMonthData);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function IntroDetailsPayload(
      elementId: string = 'payload',
    ): types.IntroDetailsPayload {
      return ((x) => {
        x.details = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.details);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ProblemDetailsPayload(
      elementId: string = 'payload',
    ): types.ProblemDetailsPayload {
      return ((x) => {
        x.creation_date = ((x: number) => new Date(x * 1000))(x.creation_date);
        if (x.problemsetter)
          x.problemsetter = ((x) => {
            if (x.creation_date)
              x.creation_date = ((x: number) => new Date(x * 1000))(
                x.creation_date,
              );
            return x;
          })(x.problemsetter);
        if (x.runs)
          x.runs = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            });
          })(x.runs);
        if (x.solvers)
          x.solvers = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            });
          })(x.solvers);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ProblemDetailsv2Payload(
      elementId: string = 'payload',
    ): types.ProblemDetailsv2Payload {
      return ((x) => {
        if (x.allRuns)
          x.allRuns = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            });
          })(x.allRuns);
        if (x.clarifications)
          x.clarifications = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            });
          })(x.clarifications);
        x.problem = ((x) => {
          if (x.problemsetter)
            x.problemsetter = ((x) => {
              if (x.creation_date)
                x.creation_date = ((x: number) => new Date(x * 1000))(
                  x.creation_date,
                );
              return x;
            })(x.problemsetter);
          return x;
        })(x.problem);
        if (x.runs)
          x.runs = ((x) => {
            if (!Array.isArray(x)) {
              return x;
            }
            return x.map((x) => {
              x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            });
          })(x.runs);
        x.solvers = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.solvers);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ProblemEditPayload(
      elementId: string = 'payload',
    ): types.ProblemEditPayload {
      return ((x) => {
        x.log = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            x.author = ((x) => {
              if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            })(x.author);
            x.committer = ((x) => {
              if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            })(x.committer);
            return x;
          });
        })(x.log);
        if (x.problemsetter)
          x.problemsetter = ((x) => {
            if (x.creation_date)
              x.creation_date = ((x: number) => new Date(x * 1000))(
                x.creation_date,
              );
            return x;
          })(x.problemsetter);
        if (x.publishedRevision)
          x.publishedRevision = ((x) => {
            x.author = ((x) => {
              if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            })(x.author);
            x.committer = ((x) => {
              if (x.time) x.time = ((x: number) => new Date(x * 1000))(x.time);
              return x;
            })(x.committer);
            return x;
          })(x.publishedRevision);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ProblemFormPayload(
      elementId: string = 'payload',
    ): types.ProblemFormPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ProblemListPayload(
      elementId: string = 'payload',
    ): types.ProblemListPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ProblemQualityPayload(
      elementId: string = 'payload',
    ): types.ProblemQualityPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function ProblemSettingsSummaryPayload(
      elementId: string = 'payload',
    ): types.ProblemSettingsSummaryPayload {
      return ((x) => {
        x.problem = ((x) => {
          if (x.problemsetter)
            x.problemsetter = ((x) => {
              if (x.creation_date)
                x.creation_date = ((x: number) => new Date(x * 1000))(
                  x.creation_date,
                );
              return x;
            })(x.problemsetter);
          if (x.runs)
            x.runs = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                x.time = ((x: number) => new Date(x * 1000))(x.time);
                return x;
              });
            })(x.runs);
          return x;
        })(x.problem);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function ProblemsMineInfoPayload(
      elementId: string = 'payload',
    ): types.ProblemsMineInfoPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function SchoolOfTheMonthPayload(
      elementId: string = 'payload',
    ): types.SchoolOfTheMonthPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function SchoolProfileDetailsPayload(
      elementId: string = 'payload',
    ): types.SchoolProfileDetailsPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function SchoolRankPayload(
      elementId: string = 'payload',
    ): types.SchoolRankPayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }

    export function StatsPayload(
      elementId: string = 'payload',
    ): types.StatsPayload {
      return ((x) => {
        if (x.max_wait_time)
          x.max_wait_time = ((x: number) => new Date(x * 1000))(
            x.max_wait_time,
          );
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function StudentProgressPayload(
      elementId: string = 'payload',
    ): types.StudentProgressPayload {
      return ((x) => {
        x.course = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.course);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function StudentsProgressPayload(
      elementId: string = 'payload',
    ): types.StudentsProgressPayload {
      return ((x) => {
        x.course = ((x) => {
          if (x.assignments)
            x.assignments = ((x) => {
              if (!Array.isArray(x)) {
                return x;
              }
              return x.map((x) => {
                if (x.finish_time)
                  x.finish_time = ((x: number) => new Date(x * 1000))(
                    x.finish_time,
                  );
                x.start_time = ((x: number) => new Date(x * 1000))(
                  x.start_time,
                );
                return x;
              });
            })(x.assignments);
          if (x.finish_time)
            x.finish_time = ((x: number) => new Date(x * 1000))(x.finish_time);
          x.start_time = ((x: number) => new Date(x * 1000))(x.start_time);
          return x;
        })(x.course);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function SubmissionsListPayload(
      elementId: string = 'payload',
    ): types.SubmissionsListPayload {
      return ((x) => {
        x.submissions = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            x.time = ((x: number) => new Date(x * 1000))(x.time);
            return x;
          });
        })(x.submissions);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function UserProfileDetailsPayload(
      elementId: string = 'payload',
    ): types.UserProfileDetailsPayload {
      return ((x) => {
        x.contests = ((x) => {
          if (x instanceof Object) {
            Object.keys(x).forEach(
              (y) =>
                (x[y] = ((x) => {
                  x.data = ((x) => {
                    x.finish_time = ((x: number) => new Date(x * 1000))(
                      x.finish_time,
                    );
                    x.last_updated = ((x: number) => new Date(x * 1000))(
                      x.last_updated,
                    );
                    x.start_time = ((x: number) => new Date(x * 1000))(
                      x.start_time,
                    );
                    return x;
                  })(x.data);
                  return x;
                })(x[y])),
            );
          }
          return x;
        })(x.contests);
        x.ownedBadges = ((x) => {
          if (!Array.isArray(x)) {
            return x;
          }
          return x.map((x) => {
            if (x.assignation_time)
              x.assignation_time = ((x: number) => new Date(x * 1000))(
                x.assignation_time,
              );
            if (x.first_assignation)
              x.first_assignation = ((x: number) => new Date(x * 1000))(
                x.first_assignation,
              );
            return x;
          });
        })(x.ownedBadges);
        x.profile = ((x) => {
          if (x.birth_date)
            x.birth_date = ((x: number) => new Date(x * 1000))(x.birth_date);
          if (x.graduation_date)
            x.graduation_date = ((x: number) => new Date(x * 1000))(
              x.graduation_date,
            );
          return x;
        })(x.profile);
        return x;
      })(
        JSON.parse((<HTMLElement>document.getElementById(elementId)).innerText),
      );
    }

    export function UserRankTablePayload(
      elementId: string = 'payload',
    ): types.UserRankTablePayload {
      return JSON.parse(
        (<HTMLElement>document.getElementById(elementId)).innerText,
      );
    }
  }

  export interface AddedProblem {
    alias: string;
    commit?: string;
    points: number;
  }

  export interface AdminCourses {
    admin: types.CoursesByAccessMode;
  }

  export interface ArenaProblemDetails {
    accepts_submissions: boolean;
    alias: string;
    commit: string;
    input_limit: number;
    languages: string[];
    letter?: string;
    points: number;
    problem_id?: number;
    problemsetter?: types.ProblemsetterInfo;
    quality_seal: boolean;
    runs?: types.Run[];
    settings?: types.ProblemSettings;
    source?: string;
    statement?: types.ProblemStatement;
    title: string;
    visibility: number;
  }

  export interface AssignmentProgress {
    [key: string]: types.Progress;
  }

  export interface AuthorRankTablePayload {
    length: number;
    page: number;
    pagerItems: types.PageItem[];
    ranking: types.AuthorsRank;
  }

  export interface AuthorsRank {
    ranking: {
      author_ranking?: number;
      author_score: number;
      classname: string;
      country_id?: string;
      name?: string;
      username: string;
    }[];
    total: number;
  }

  export interface Badge {
    assignation_time?: Date;
    badge_alias: string;
    first_assignation?: Date;
    owners_count: number;
    total_users: number;
  }

  export interface BadgeDetailsPayload {
    badge: types.Badge;
  }

  export interface BadgeListPayload {
    badges: string[];
    ownedBadges: types.Badge[];
  }

  export interface BestSolvers {
    classname: string;
    language: string;
    memory: number;
    runtime: number;
    time: Date;
    username: string;
  }

  export interface Clarification {
    answer?: string;
    author?: string;
    clarification_id: number;
    contest_alias?: string;
    message: string;
    problem_alias: string;
    public: boolean;
    receiver?: string;
    time: Date;
  }

  export interface CoderOfTheMonth {
    category: string;
    classname: string;
    coder_of_the_month_id: number;
    country_id: string;
    description?: string;
    interview_url?: string;
    problems_solved: number;
    ranking: number;
    school_id?: number;
    score: number;
    selected_by?: number;
    time: string;
    user_id: number;
    username: string;
  }

  export interface CoderOfTheMonthList {
    classname: string;
    country_id: string;
    date: string;
    gravatar_32: string;
    username: string;
  }
  [];

  export interface CoderOfTheMonthPayload {
    candidatesToCoderOfTheMonth: {
      category: string;
      classname: string;
      coder_of_the_month_id: number;
      country_id: string;
      description?: string;
      interview_url?: string;
      problems_solved: number;
      ranking: number;
      school_id?: number;
      score: number;
      selected_by?: number;
      time: string;
      username: string;
    }[];
    category: string;
    codersOfCurrentMonth: types.CoderOfTheMonthList;
    codersOfPreviousMonth: types.CoderOfTheMonthList;
    isMentor: boolean;
    options?: { canChooseCoder: boolean; coderIsSelected: boolean };
  }

  export interface CommitRunsDiff {
    [key: string]: types.RunsDiff[];
  }

  export interface CommonPayload {
    bootstrap4: boolean;
    currentUsername: string;
    gravatarURL51: string;
    inContest: boolean;
    isAdmin: boolean;
    isLoggedIn: boolean;
    isMainUserIdentity: boolean;
    isReviewer: boolean;
    lockDownImage: string;
    navbarSection: string;
    omegaUpLockDown: boolean;
    profileProgress: number;
    userClassname: string;
    userCountry: string;
  }

  export interface ConsentStatement {
    contest_alias: string;
    privacy_git_object_id?: string;
    share_user_information?: boolean;
    statement_type?: string;
  }

  export interface Contest {
    acl_id?: number;
    admission_mode: string;
    alias: string;
    contest_id: number;
    description: string;
    feedback?: string;
    finish_time: Date;
    languages?: string;
    last_updated: Date;
    original_finish_time?: Date;
    partial_score: boolean;
    penalty?: number;
    penalty_calc_policy?: string;
    penalty_type?: string;
    points_decay_factor?: number;
    problemset_id: number;
    recommended: boolean;
    rerun_id: number;
    scoreboard?: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    show_scoreboard_after?: number;
    start_time: Date;
    submissions_gap?: number;
    title: string;
    urgent?: number;
    window_length?: number;
  }

  export interface ContestAdmin {
    role: string;
    username: string;
  }

  export interface ContestAdminDetails {
    admin: boolean;
    admission_mode: string;
    alias: string;
    available_languages: { [key: string]: string };
    description: string;
    director?: string;
    feedback: string;
    finish_time: Date;
    languages: string[];
    needs_basic_information: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problems: {
      accepted: number;
      accepts_submissions: boolean;
      alias: string;
      commit: string;
      difficulty: number;
      input_limit: number;
      languages: string;
      letter: string;
      order: number;
      points: number;
      problem_id: number;
      quality_seal: boolean;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
    problemset_id: number;
    requests_user_information: string;
    rerun_id: number;
    scoreboard: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    show_penalty: boolean;
    show_scoreboard_after: boolean;
    start_time: Date;
    submissions_gap: number;
    title: string;
    window_length?: number;
  }

  export interface ContestDetails {
    admission_mode: string;
    alias: string;
    description: string;
    director?: string;
    feedback: string;
    finish_time: Date;
    languages: string[];
    needs_basic_information: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problems: {
      accepted: number;
      accepts_submissions: boolean;
      alias: string;
      commit: string;
      difficulty: number;
      input_limit: number;
      languages: string;
      letter: string;
      order: number;
      points: number;
      problem_id: number;
      quality_seal: boolean;
      submissions: number;
      title: string;
      version: string;
      visibility: number;
      visits: number;
    }[];
    problemset_id: number;
    requests_user_information: string;
    rerun_id: number;
    scoreboard: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    show_penalty: boolean;
    show_scoreboard_after: boolean;
    start_time: Date;
    submissions_gap: number;
    title: string;
    window_length?: number;
  }

  export interface ContestEditPayload {
    admins: types.ContestAdmin[];
    details: types.ContestAdminDetails;
    group_admins: types.ContestGroupAdmin[];
    groups: types.ContestGroup[];
    problems: types.ContestProblem[];
    requests: types.ContestRequest[];
    users: types.ContestUser[];
  }

  export interface ContestGroup {
    alias: string;
    name: string;
  }

  export interface ContestGroupAdmin {
    alias: string;
    name: string;
    role: string;
  }

  export interface ContestIntroPayload {
    contest: types.ContestPublicDetails;
    needsBasicInformation?: boolean;
    privacyStatement?: types.PrivacyStatement;
    requestsUserInformation?: string;
    shouldShowFirstAssociatedIdentityRunWarning: boolean;
  }

  export interface ContestListItem {
    admission_mode: string;
    alias: string;
    contest_id: number;
    description: string;
    finish_time: Date;
    last_updated: Date;
    original_finish_time: Date;
    problemset_id: number;
    recommended: boolean;
    rerun_id: number;
    start_time: Date;
    title: string;
    window_length?: number;
  }

  export interface ContestListMinePayload {
    contests: types.Contest[];
    privateContestsAlert: boolean;
  }

  export interface ContestListPayload {
    contests: {
      current: types.ContestListItem[];
      future: types.ContestListItem[];
      participating?: types.ContestListItem[];
      past: types.ContestListItem[];
      public: types.ContestListItem[];
      recommended_current: types.ContestListItem[];
      recommended_past: types.ContestListItem[];
    };
    isLogged: boolean;
    query: string;
  }

  export interface ContestNewPayload {
    languages: { [key: string]: string };
  }

  export interface ContestProblem {
    accepted: number;
    alias: string;
    commit: string;
    difficulty: number;
    languages: string;
    order: number;
    points: number;
    problem_id: number;
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  }

  export interface ContestPublicDetails {
    admission_mode: string;
    alias: string;
    description: string;
    feedback: string;
    finish_time: Date;
    languages: string;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problemset_id: number;
    rerun_id: number;
    scoreboard: number;
    show_penalty: boolean;
    show_scoreboard_after: boolean;
    start_time: Date;
    submissions_gap: number;
    title: string;
    user_registration_accepted?: boolean;
    user_registration_answered?: boolean;
    user_registration_requested?: boolean;
    window_length?: number;
  }

  export interface ContestRequest {
    accepted?: boolean;
    admin?: { username?: string };
    country?: string;
    last_update?: Date;
    request_time: Date;
    username: string;
  }

  export interface ContestUser {
    access_time?: Date;
    country_id?: string;
    end_time?: Date;
    is_owner?: number;
    username: string;
  }

  export interface CourseAdmin {
    role: string;
    username: string;
  }

  export interface CourseAssignment {
    alias: string;
    assignment_type: string;
    description: string;
    finish_time?: Date;
    has_runs: boolean;
    max_points: number;
    name: string;
    order: number;
    problemset_id: number;
    publish_time_delay?: number;
    scoreboard_url: string;
    scoreboard_url_admin: string;
    start_time: Date;
  }

  export interface CourseAssignmentEditPayload {
    assignment?: types.CourseAssignment;
    course: types.CourseDetails;
  }

  export interface CourseDetails {
    admission_mode?: string;
    alias: string;
    assignments?: types.CourseAssignment[];
    description: string;
    finish_time?: Date;
    is_admin: boolean;
    is_curator: boolean;
    name: string;
    needs_basic_information: boolean;
    requests_user_information: string;
    school_id?: number;
    school_name?: string;
    show_scoreboard: boolean;
    start_time: Date;
    student_count?: number;
    unlimited_duration: boolean;
  }

  export interface CourseDetailsPayload {
    details: types.CourseDetails;
    progress: types.AssignmentProgress;
  }

  export interface CourseEditPayload {
    admins: types.CourseAdmin[];
    assignmentProblems: types.ProblemsetProblem[];
    course: types.CourseDetails;
    groupsAdmins: types.CourseGroupAdmin[];
    identityRequests: types.IdentityRequest[];
    selectedAssignment?: types.CourseAssignment;
    students: types.CourseStudent[];
    tags: string[];
  }

  export interface CourseGroupAdmin {
    alias: string;
    name: string;
    role: string;
  }

  export interface CourseListMinePayload {
    courses: types.AdminCourses;
  }

  export interface CourseListPayload {
    course_type?: string;
    courses: types.StudentCourses;
  }

  export interface CourseNewPayload {
    is_admin: boolean;
    is_curator: boolean;
  }

  export interface CourseProblem {
    accepted: number;
    alias: string;
    commit: string;
    difficulty: number;
    languages: string;
    letter: string;
    order: number;
    points: number;
    runs: {
      contest_score?: number;
      guid: string;
      language: string;
      memory: number;
      penalty: number;
      runtime: number;
      score: number;
      source?: string;
      status: string;
      submit_delay: number;
      time: Date;
      verdict: string;
    }[];
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  }

  export interface CourseProblemStatistics {
    assignment_alias: string;
    average?: number;
    avg_runs?: number;
    high_score_percentage?: number;
    low_score_percentage?: number;
    max_points: number;
    maximum?: number;
    minimum?: number;
    problem_alias: string;
    variance?: number;
  }

  export interface CourseProblemTried {
    alias: string;
    title: string;
    username: string;
  }

  export interface CourseStatisticsPayload {
    course: types.CourseDetails;
    problemStats: types.CourseProblemStatistics[];
  }

  export interface CourseStudent {
    name?: string;
    username: string;
  }

  export interface CourseSubmissionsListPayload {
    solvedProblems: { [key: string]: types.CourseProblemTried[] };
    unsolvedProblems: { [key: string]: types.CourseProblemTried[] };
  }

  export interface CoursesByAccessMode {
    accessMode: string;
    activeTab: string;
    filteredCourses: {
      current: types.CoursesByTimeType;
      past: types.CoursesByTimeType;
    };
  }

  export interface CoursesByTimeType {
    courses: types.FilteredCourse[];
    timeType: string;
  }

  export interface CoursesList {
    admin: types.FilteredCourse[];
    public: types.FilteredCourse[];
    student: types.FilteredCourse[];
  }

  export interface FilteredCourse {
    accept_teacher?: boolean;
    admission_mode: string;
    alias: string;
    assignments: types.CourseAssignment[];
    counts: { [key: string]: number };
    finish_time?: Date;
    is_open: boolean;
    name: string;
    progress?: number;
    school_name?: string;
    start_time: Date;
  }

  export interface GraderStatus {
    broadcaster_sockets: number;
    embedded_runner: boolean;
    queue: {
      run_queue_length: number;
      runner_queue_length: number;
      runners: string[];
      running: { id: number; name: string }[];
    };
    status: string;
  }

  export interface Histogram {
    difficulty: number;
    difficultyHistogram?: string;
    quality: number;
    qualityHistogram?: string;
  }

  export interface IdentityRequest {
    accepted?: boolean;
    admin?: { name?: string; username: string };
    country?: string;
    country_id?: string;
    last_update?: Date;
    request_time: Date;
    username: string;
  }

  export interface IndexPayload {
    coderOfTheMonthData: {
      all?: types.UserProfile;
      female?: types.UserProfile;
    };
    currentUserInfo: { username?: string };
    schoolOfTheMonthData?: {
      country?: string;
      country_id?: string;
      name: string;
      school_id: number;
      state?: string;
    };
    schoolRank: {
      name: string;
      ranking: number;
      school_id: number;
      school_of_the_month_id: number;
      score: number;
    }[];
    userRank: types.CoderOfTheMonth[];
  }

  export interface InteractiveSettings {
    idl: string;
    language: string;
    main_source: string;
    module_name: string;
    templates: { [key: string]: string };
  }

  export interface IntroDetailsPayload {
    details: types.CourseDetails;
    progress?: types.AssignmentProgress;
    shouldShowFirstAssociatedIdentityRunWarning: boolean;
  }

  export interface LimitsSettings {
    ExtraWallTime: string;
    MemoryLimit: number | string;
    OutputLimit: number | string;
    OverallWallTimeLimit: string;
    TimeLimit: string;
  }

  export interface NominationListItem {
    author: { name?: string; username: string };
    contents?: {
      before_ac?: boolean;
      difficulty?: number;
      quality?: number;
      rationale?: string;
      reason?: string;
      statements?: { [key: string]: string };
      tags?: string[];
    };
    nomination: string;
    nominator: { name?: string; username: string };
    problem: { alias: string; title: string };
    qualitynomination_id: number;
    status: string;
    time: Date;
    votes: {
      time?: Date;
      user: { name?: string; username: string };
      vote: number;
    }[];
  }

  export interface NominationStatus {
    alreadyReviewed: boolean;
    canNominateProblem: boolean;
    dismissed: boolean;
    dismissedBeforeAC: boolean;
    language: string;
    nominated: boolean;
    nominatedBeforeAC: boolean;
    solved: boolean;
    tried: boolean;
  }

  export interface Notification {
    contents: types.NotificationContents;
    notification_id: number;
    timestamp: Date;
  }

  export interface NotificationContents {
    badge?: string;
    body?: {
      iconUrl: string;
      localizationParams: string[];
      localizationString: string;
      url: string;
    };
    message?: string;
    status?: string;
    type: string;
    url?: string;
  }

  export interface PageItem {
    class: string;
    label: string;
    page: number;
    url?: string;
  }

  export interface PrivacyStatement {
    gitObjectId?: string;
    markdown: string;
    statementType: string;
  }

  export interface Problem {
    accepted: number;
    alias: string;
    difficulty: number;
    submissions: number;
    title: string;
  }

  export interface ProblemAdmin {
    role: string;
    username: string;
  }

  export interface ProblemCasesContents {
    [key: string]: { contestantOutput?: string; in: string; out: string };
  }

  export interface ProblemDetails {
    accepted: number;
    accepts_submissions: boolean;
    admin?: boolean;
    alias: string;
    allow_user_add_tags: boolean;
    commit: string;
    creation_date: Date;
    difficulty?: number;
    email_clarifications: boolean;
    input_limit: number;
    languages: string[];
    letter?: string;
    order: string;
    points: number;
    preferred_language?: string;
    problem_id: number;
    problemsetter?: types.ProblemsetterInfo;
    quality_seal: boolean;
    runs?: types.Run[];
    score: number;
    settings: types.ProblemSettings;
    show_diff: string;
    solvers?: types.BestSolvers[];
    source?: string;
    statement: types.ProblemStatement;
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  }

  export interface ProblemDetailsPayload {
    accepted: number;
    accepts_submissions: boolean;
    admin?: boolean;
    alias: string;
    allow_user_add_tags: boolean;
    commit: string;
    creation_date: Date;
    difficulty?: number;
    email_clarifications: boolean;
    histogram: {
      difficulty: number;
      difficulty_histogram?: string;
      quality: number;
      quality_histogram?: string;
    };
    input_limit: number;
    languages: string[];
    letter?: string;
    order: string;
    points: number;
    preferred_language?: string;
    problem_id: number;
    problemsetter?: types.ProblemsetterInfo;
    quality_seal: boolean;
    runs?: types.Run[];
    score: number;
    settings: types.ProblemSettings;
    shouldShowFirstAssociatedIdentityRunWarning: boolean;
    solution_status?: string;
    solvers?: types.BestSolvers[];
    source?: string;
    statement: types.ProblemStatement;
    submissions: number;
    title: string;
    user: { admin: boolean; logged_in: boolean; reviewer: boolean };
    version: string;
    visibility: number;
    visits: number;
  }

  export interface ProblemDetailsv2Payload {
    allRuns?: types.Run[];
    clarifications?: types.Clarification[];
    histogram: types.Histogram;
    nominationStatus?: types.NominationStatus;
    problem: types.ProblemInfo;
    runs?: types.Run[];
    solutionStatus?: string;
    solvers: types.BestSolvers[];
    user: types.UserInfoForProblem;
  }

  export interface ProblemEditPayload {
    admins: types.ProblemAdmin[];
    alias: string;
    allowUserAddTags: boolean;
    emailClarifications: boolean;
    extraWallTime: number;
    groupAdmins: types.ProblemGroupAdmin[];
    inputLimit: number;
    languages: string;
    levelTags: string[];
    log: types.ProblemVersion[];
    memoryLimit: number;
    outputLimit: number;
    overallWallTimeLimit: number;
    problemLevel?: string;
    problemsetter?: types.ProblemsetterInfo;
    publicTags: string[];
    publishedRevision?: types.ProblemVersion;
    selectedPrivateTags: string[];
    selectedPublicTags: string[];
    showDiff: string;
    solution?: types.ProblemStatement;
    source: string;
    statement: types.ProblemStatement;
    statusError?: string;
    statusSuccess: boolean;
    timeLimit: number;
    title: string;
    validLanguages: { [key: string]: string };
    validator: string;
    validatorTimeLimit: number | number;
    validatorTypes: { [key: string]: null | string };
    visibility: number;
    visibilityStatuses: { [key: string]: number };
  }

  export interface ProblemFormPayload {
    alias: string;
    allowUserAddTags: boolean;
    emailClarifications: boolean;
    extraWallTime: number | string;
    inputLimit: number | string;
    languages: string;
    levelTags: string[];
    memoryLimit: number | string;
    message?: string;
    outputLimit: number | string;
    overallWallTimeLimit: number | string;
    parameter?: string;
    problem_level: string;
    publicTags: string[];
    selectedTags?: types.SelectedTag[];
    showDiff: string;
    source: string;
    statusError: string;
    tags: { name?: string }[];
    timeLimit: number | string;
    title: string;
    validLanguages: { [key: string]: string };
    validator: string;
    validatorTimeLimit: number | string;
    validatorTypes: { [key: string]: null | string };
    visibility: number;
    visibilityStatuses: { [key: string]: number };
  }

  export interface ProblemGroupAdmin {
    alias: string;
    name: string;
    role: string;
  }

  export interface ProblemInfo {
    accepts_submissions: boolean;
    alias: string;
    commit: string;
    input_limit: number;
    karel_problem: boolean;
    languages: string[];
    letter?: string;
    limits: {
      input_limit: string;
      memory_limit: string;
      overall_wall_time_limit: string;
      time_limit: string;
    };
    points: number;
    problem_id: number;
    problemsetter?: types.ProblemsetterInfo;
    quality_seal: boolean;
    sample_input?: string;
    settings: types.ProblemSettings;
    source?: string;
    statement: types.ProblemStatement;
    title: string;
    visibility: number;
  }

  export interface ProblemListItem {
    alias: string;
    difficulty?: number;
    difficulty_histogram: number[];
    points: number;
    problem_id: number;
    quality?: number;
    quality_histogram: number[];
    quality_seal: boolean;
    ratio: number;
    score: number;
    tags: { name: string; source: string }[];
    title: string;
    visibility: number;
  }

  export interface ProblemListPayload {
    column: string;
    columns: string[];
    currentTags: string[];
    keyword: string;
    language: string;
    languages: string[];
    loggedIn: boolean;
    mode: string;
    modes: string[];
    pagerItems: types.PageItem[];
    problems: types.ProblemListItem[];
    tagData: { name?: string }[];
    tags: string[];
  }

  export interface ProblemQualityPayload {
    canNominateProblem: boolean;
    dismissed: boolean;
    dismissedBeforeAC: boolean;
    language?: string;
    nominated: boolean;
    nominatedBeforeAC: boolean;
    problemAlias: string;
    solved: boolean;
    tried: boolean;
  }

  export interface ProblemSettings {
    cases: { [key: string]: { in: string; out: string; weight?: number } };
    interactive?: types.InteractiveSettings;
    limits: types.LimitsSettings;
    validator: {
      custom_validator?: {
        language: string;
        limits?: types.LimitsSettings;
        source: string;
      };
      name: string;
      tolerance?: number;
    };
  }

  export interface ProblemSettingsSummaryPayload {
    problem: types.ArenaProblemDetails;
    problem_admin: boolean;
  }

  export interface ProblemStatement {
    images: { [key: string]: string };
    language: string;
    markdown: string;
  }

  export interface ProblemVersion {
    author: { email?: string; name?: string; time?: Date };
    commit: string;
    committer: { email?: string; name?: string; time?: Date };
    message?: string;
    parents?: string[];
    tree?: { [key: string]: string };
    version?: string;
  }

  export interface ProblemsMineInfoPayload {
    isSysadmin: boolean;
    privateProblemsAlert: boolean;
    visibilityStatuses: { [key: string]: number };
  }

  export interface Problemset {
    admin?: boolean;
    admission_mode?: string;
    alias?: string;
    assignment_type?: string;
    contest_alias?: string;
    courseAssignments?: {
      alias: string;
      assignment_type: string;
      description: string;
      finish_time?: Date;
      has_runs: boolean;
      max_points: number;
      name: string;
      order: number;
      problemset_id: number;
      publish_time_delay?: number;
      scoreboard_url: string;
      scoreboard_url_admin: string;
      start_time: Date;
    }[];
    description?: string;
    director?: string;
    feedback?: string;
    finish_time?: Date;
    languages?: string[];
    name?: string;
    needs_basic_information?: boolean;
    opened?: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    partial_score?: boolean;
    penalty?: number;
    penalty_calc_policy?: string;
    penalty_type?: string;
    points_decay_factor?: number;
    problems?: types.ProblemsetProblem[];
    problemset_id?: number;
    requests_user_information?: string;
    scoreboard?: number;
    show_penalty?: boolean;
    show_scoreboard_after?: boolean;
    start_time?: Date;
    submission_deadline?: Date;
    submissions_gap?: number;
    title?: string;
    users?: {
      access_time?: Date;
      country?: string;
      email?: string;
      opened_interview: boolean;
      user_id?: number;
      username: string;
    }[];
    window_length?: number;
  }

  export interface ProblemsetProblem {
    accepted: number;
    accepts_submissions: boolean;
    alias: string;
    commit: string;
    difficulty: number;
    input_limit: number;
    languages: string;
    letter: string;
    order: number;
    points: number;
    quality_payload?: types.ProblemQualityPayload;
    quality_seal: boolean;
    submissions: number;
    title: string;
    version: string;
    visibility: number;
    visits: number;
  }

  export interface ProblemsetterInfo {
    classname: string;
    creation_date?: Date;
    name: string;
    username: string;
  }

  export interface Progress {
    max_score: number;
    score: number;
  }

  export interface Run {
    alias: string;
    classname: string;
    contest_alias?: string;
    contest_score?: number;
    country: string;
    guid: string;
    language: string;
    memory: number;
    penalty: number;
    runtime: number;
    score: number;
    status: string;
    submit_delay: number;
    time: Date;
    type?: string;
    username: string;
    verdict: string;
  }

  export interface RunDetails {
    admin: boolean;
    alias: string;
    cases: types.ProblemCasesContents;
    compile_error?: string;
    details?: {
      compile_meta?: { [key: string]: types.RunMetadata };
      contest_score: number;
      groups?: {
        cases: {
          contest_score: number;
          max_score: number;
          meta: types.RunMetadata;
          name: string;
          score: number;
          verdict: string;
        }[];
        contest_score: number;
        group: string;
        max_score: number;
        score: number;
        verdict?: string;
      }[];
      judged_by: string;
      max_score?: number;
      memory?: number;
      score: number;
      time?: number;
      verdict: string;
      wall_time?: number;
    };
    feedback?: string;
    guid: string;
    judged_by?: string;
    language: string;
    logs?: string;
    show_diff: string;
    source?: string;
    source_link?: boolean;
    source_name?: string;
    source_url?: string;
  }

  export interface RunMetadata {
    memory: number;
    sys_time: number;
    time: number;
    verdict: string;
    wall_time: number;
  }

  export interface RunsDiff {
    guid: string;
    new_score?: number;
    new_status?: string;
    new_verdict?: string;
    old_score?: number;
    old_status?: string;
    old_verdict?: string;
    problemset_id?: number;
    username: string;
  }

  export interface School {
    country_id?: string;
    name: string;
    ranking?: number;
    school_id: number;
    score: number;
  }

  export interface SchoolCoderOfTheMonth {
    classname: string;
    time: string;
    username: string;
  }

  export interface SchoolOfTheMonthPayload {
    candidatesToSchoolOfTheMonth: {
      country_id: string;
      name: string;
      ranking: number;
      school_id: number;
      school_of_the_month_id: number;
      score: number;
    }[];
    isMentor: boolean;
    options?: { canChooseSchool: boolean; schoolIsSelected: boolean };
    schoolsOfPreviousMonth: {
      country_id: string;
      name: string;
      ranking: number;
      school_id: number;
    }[];
    schoolsOfPreviousMonths: {
      country_id: string;
      name: string;
      school_id: number;
      time: string;
    }[];
  }

  export interface SchoolProblemsSolved {
    month: number;
    problems_solved: number;
    year: number;
  }

  export interface SchoolProfileDetailsPayload {
    coders_of_the_month: types.SchoolCoderOfTheMonth[];
    country?: { id: string; name: string };
    monthly_solved_problems: types.SchoolProblemsSolved[];
    ranking: number;
    school_id: number;
    school_name: string;
    school_users: types.SchoolUser[];
    state_name?: string;
  }

  export interface SchoolRankPayload {
    length: number;
    page: number;
    pagerItems: types.PageItem[];
    rank: types.School[];
    showHeader: boolean;
    totalRows: number;
  }

  export interface SchoolUser {
    classname: string;
    created_problems: number;
    organized_contests: number;
    solved_problems: number;
    username: string;
  }

  export interface Scoreboard {
    finish_time?: Date;
    problems: { alias: string; order: number }[];
    ranking: types.ScoreboardRankingEntry[];
    start_time: Date;
    time: Date;
    title: string;
  }

  export interface ScoreboardEvent {
    classname: string;
    country: string;
    delta: number;
    is_invited: boolean;
    name?: string;
    problem: { alias: string; penalty: number; points: number };
    total: { penalty: number; points: number };
    username: string;
  }

  export interface ScoreboardRankingEntry {
    classname: string;
    country: string;
    is_invited: boolean;
    name?: string;
    place?: number;
    problems: types.ScoreboardRankingProblem[];
    total: { penalty: number; points: number };
    username: string;
  }

  export interface ScoreboardRankingProblem {
    alias: string;
    penalty: number;
    pending?: number;
    percent: number;
    place?: number;
    points: number;
    run_details?: {
      cases?: {
        contest_score: number;
        max_score: number;
        meta: types.RunMetadata;
        name?: string;
        out_diff: string;
        score: number;
        verdict: string;
      }[];
      details: { groups: { cases: { meta: types.RunMetadata }[] }[] };
    };
    runs: number;
  }

  export interface SelectedTag {
    public: boolean;
    tagname: string;
  }

  export interface Statements {
    [key: string]: string;
  }

  export interface StatsPayload {
    alias: string;
    cases_stats?: { [key: string]: number };
    distribution?: { [key: number]: number };
    entity_type: string;
    max_wait_time?: Date;
    max_wait_time_guid?: string;
    pending_runs: string[];
    size_of_bucket?: number;
    total_points?: number;
    total_runs: number;
    verdict_counts: { [key: string]: number };
  }

  export interface StudentCourses {
    [key: string]: types.CoursesByAccessMode;
  }

  export interface StudentProgress {
    name?: string;
    progress: { [key: string]: { [key: string]: number } };
    username: string;
  }

  export interface StudentProgressPayload {
    course: types.CourseDetails;
    student: string;
    students: types.StudentProgress[];
  }

  export interface StudentsProgressPayload {
    course: types.CourseDetails;
    students: types.StudentProgress[];
  }

  export interface Submission {
    alias: string;
    language: string;
    memory: number;
    runtime: number;
    school_id?: number;
    school_name?: string;
    time: Date;
    title: string;
    username: string;
    verdict: string;
  }

  export interface SubmissionsListPayload {
    includeUser: boolean;
    length: number;
    page: number;
    pagerItems: types.PageItem[];
    submissions: types.Submission[];
    totalRows: number;
  }

  export interface UserInfoForProblem {
    admin: boolean;
    loggedIn: boolean;
    reviewer: boolean;
  }

  export interface UserListItem {
    label: string;
    value: string;
  }

  export interface UserProfile {
    birth_date?: Date;
    classname: string;
    country: string;
    country_id?: string;
    email?: string;
    gender?: string;
    graduation_date?: Date;
    gravatar_92: string;
    hide_problem_tags: boolean;
    is_private: boolean;
    locale: string;
    name?: string;
    preferred_language?: string;
    scholar_degree?: string;
    school?: string;
    school_id?: number;
    state?: string;
    state_id?: string;
    username?: string;
    verified: boolean;
  }

  export interface UserProfileContests {
    [key: string]: {
      data: {
        alias: string;
        finish_time: Date;
        last_updated: Date;
        start_time: Date;
        title: string;
      };
      place: number;
    };
  }

  export interface UserProfileDetailsPayload {
    badges: string[];
    contests: types.UserProfileContests;
    createdProblems: types.Problem[];
    ownedBadges: types.Badge[];
    profile: types.UserProfileInfo;
    programmingLanguages: { [key: string]: string };
    solvedProblems: types.Problem[];
    stats: types.UserProfileStats[];
    statusError?: string;
    unsolvedProblems: types.Problem[];
  }

  export interface UserProfileInfo {
    birth_date?: Date;
    classname: string;
    country?: string;
    country_id?: string;
    email?: string;
    gender?: string;
    graduation_date?: Date | string;
    gravatar_92?: string;
    hide_problem_tags: boolean;
    is_private: boolean;
    locale?: string;
    name?: string;
    preferred_language?: string;
    programming_languages: { [key: string]: string };
    rankinfo: {
      author_ranking?: number;
      name?: string;
      problems_solved?: number;
      rank?: number;
    };
    scholar_degree?: string;
    school?: string;
    school_id?: number;
    state?: string;
    state_id?: string;
    username?: string;
    verified?: boolean;
  }

  export interface UserProfileStats {
    date?: string;
    runs: number;
    verdict: string;
  }

  export interface UserRank {
    rank: {
      classname: string;
      country_id?: string;
      name?: string;
      problems_solved: number;
      ranking?: number;
      score: number;
      user_id: number;
      username: string;
    }[];
    total: number;
  }

  export interface UserRankInfo {
    author_ranking?: number;
    name: string;
    problems_solved: number;
    rank: number;
  }

  export interface UserRankTablePayload {
    availableFilters: { country?: string; school?: string; state?: string };
    filter: string;
    isIndex: boolean;
    isLogged: boolean;
    length: number;
    page: number;
    pagerItems: types.PageItem[];
    ranking: types.UserRank;
  }
}

// API messages
export namespace messages {
  // Admin
  export type AdminPlatformReportStatsRequest = { [key: string]: any };
  export type AdminPlatformReportStatsResponse = {
    report: {
      acceptedSubmissions: number;
      activeSchools: number;
      activeUsers: { [key: string]: number };
      courses: number;
      omiCourse: {
        attemptedUsers: number;
        completedUsers: number;
        passedUsers: number;
      };
    };
  };

  // Authorization
  export type AuthorizationProblemRequest = { [key: string]: any };
  export type AuthorizationProblemResponse = {
    can_edit: boolean;
    can_view: boolean;
    has_solved: boolean;
    is_admin: boolean;
  };

  // Badge
  export type BadgeBadgeDetailsRequest = { [key: string]: any };
  export type _BadgeBadgeDetailsServerResponse = any;
  export type BadgeBadgeDetailsResponse = types.Badge;
  export type BadgeListRequest = { [key: string]: any };
  export type BadgeListResponse = string[];
  export type BadgeMyBadgeAssignationTimeRequest = { [key: string]: any };
  export type _BadgeMyBadgeAssignationTimeServerResponse = any;
  export type BadgeMyBadgeAssignationTimeResponse = { assignation_time?: Date };
  export type BadgeMyListRequest = { [key: string]: any };
  export type _BadgeMyListServerResponse = any;
  export type BadgeMyListResponse = { badges: types.Badge[] };
  export type BadgeUserListRequest = { [key: string]: any };
  export type _BadgeUserListServerResponse = any;
  export type BadgeUserListResponse = { badges: types.Badge[] };

  // Clarification
  export type ClarificationCreateRequest = { [key: string]: any };
  export type ClarificationCreateResponse = { clarification_id: number };
  export type ClarificationDetailsRequest = { [key: string]: any };
  export type ClarificationDetailsResponse = {
    answer?: string;
    message: string;
    problem_id: number;
    problemset_id?: number;
    time: number;
  };
  export type ClarificationUpdateRequest = { [key: string]: any };
  export type ClarificationUpdateResponse = {};

  // Contest
  export type ContestActivityReportRequest = { [key: string]: any };
  export type _ContestActivityReportServerResponse = any;
  export type ContestActivityReportResponse = {
    events: {
      alias?: string;
      classname?: string;
      ip: number;
      time: Date;
      username: string;
    }[];
  };
  export type ContestAddAdminRequest = { [key: string]: any };
  export type ContestAddAdminResponse = {};
  export type ContestAddGroupRequest = { [key: string]: any };
  export type ContestAddGroupResponse = {};
  export type ContestAddGroupAdminRequest = { [key: string]: any };
  export type ContestAddGroupAdminResponse = {};
  export type ContestAddProblemRequest = { [key: string]: any };
  export type ContestAddProblemResponse = {};
  export type ContestAddUserRequest = { [key: string]: any };
  export type ContestAddUserResponse = {};
  export type ContestAdminDetailsRequest = { [key: string]: any };
  export type _ContestAdminDetailsServerResponse = any;
  export type ContestAdminDetailsResponse = types.ContestAdminDetails;
  export type ContestAdminListRequest = { [key: string]: any };
  export type _ContestAdminListServerResponse = any;
  export type ContestAdminListResponse = { contests: types.Contest[] };
  export type ContestAdminsRequest = { [key: string]: any };
  export type ContestAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  export type ContestArbitrateRequestRequest = { [key: string]: any };
  export type ContestArbitrateRequestResponse = {};
  export type ContestClarificationsRequest = { [key: string]: any };
  export type _ContestClarificationsServerResponse = any;
  export type ContestClarificationsResponse = {
    clarifications: types.Clarification[];
  };
  export type ContestCloneRequest = { [key: string]: any };
  export type ContestCloneResponse = { alias: string };
  export type ContestContestantsRequest = { [key: string]: any };
  export type ContestContestantsResponse = {
    contestants: {
      country?: string;
      email?: string;
      name?: string;
      school?: string;
      state?: string;
      username: string;
    }[];
  };
  export type ContestCreateRequest = { [key: string]: any };
  export type ContestCreateResponse = {};
  export type ContestCreateVirtualRequest = { [key: string]: any };
  export type ContestCreateVirtualResponse = { alias: string };
  export type ContestDetailsRequest = { [key: string]: any };
  export type _ContestDetailsServerResponse = any;
  export type ContestDetailsResponse = {
    admin: boolean;
    admission_mode: string;
    alias: string;
    description: string;
    director?: string;
    feedback: string;
    finish_time: Date;
    languages: string[];
    needs_basic_information: boolean;
    opened: boolean;
    original_contest_alias?: string;
    original_problemset_id?: number;
    partial_score: boolean;
    penalty: number;
    penalty_calc_policy: string;
    penalty_type: string;
    points_decay_factor: number;
    problems: types.ProblemsetProblem[];
    problemset_id: number;
    requests_user_information: string;
    scoreboard: number;
    show_penalty: boolean;
    show_scoreboard_after: boolean;
    start_time: Date;
    submission_deadline?: Date;
    submissions_gap: number;
    title: string;
    window_length?: number;
  };
  export type ContestListRequest = { [key: string]: any };
  export type _ContestListServerResponse = any;
  export type ContestListResponse = {
    number_of_results: number;
    results: {
      admission_mode: string;
      alias: string;
      contest_id: number;
      description: string;
      finish_time: Date;
      last_updated: Date;
      original_finish_time: Date;
      problemset_id: number;
      recommended: boolean;
      rerun_id: number;
      start_time: Date;
      title: string;
      window_length?: number;
    }[];
  };
  export type ContestListParticipatingRequest = { [key: string]: any };
  export type _ContestListParticipatingServerResponse = any;
  export type ContestListParticipatingResponse = { contests: types.Contest[] };
  export type ContestMyListRequest = { [key: string]: any };
  export type _ContestMyListServerResponse = any;
  export type ContestMyListResponse = { contests: types.Contest[] };
  export type ContestOpenRequest = { [key: string]: any };
  export type ContestOpenResponse = {};
  export type ContestProblemsRequest = { [key: string]: any };
  export type ContestProblemsResponse = { problems: types.ContestProblem[] };
  export type ContestPublicDetailsRequest = { [key: string]: any };
  export type _ContestPublicDetailsServerResponse = any;
  export type ContestPublicDetailsResponse = types.ContestPublicDetails;
  export type ContestRegisterForContestRequest = { [key: string]: any };
  export type ContestRegisterForContestResponse = {};
  export type ContestRemoveAdminRequest = { [key: string]: any };
  export type ContestRemoveAdminResponse = {};
  export type ContestRemoveGroupRequest = { [key: string]: any };
  export type ContestRemoveGroupResponse = {};
  export type ContestRemoveGroupAdminRequest = { [key: string]: any };
  export type ContestRemoveGroupAdminResponse = {};
  export type ContestRemoveProblemRequest = { [key: string]: any };
  export type ContestRemoveProblemResponse = {};
  export type ContestRemoveUserRequest = { [key: string]: any };
  export type ContestRemoveUserResponse = {};
  export type ContestReportRequest = { [key: string]: any };
  export type _ContestReportServerResponse = any;
  export type ContestReportResponse = {
    finish_time?: Date;
    problems: { alias: string; order: number }[];
    ranking: {
      country?: string;
      is_invited: boolean;
      name?: string;
      place?: number;
      problems: {
        alias: string;
        penalty: number;
        percent: number;
        place?: number;
        points: number;
        run_details?: {
          cases?: {
            contest_score: number;
            max_score: number;
            meta: types.RunMetadata;
            name?: string;
            out_diff: string;
            score: number;
            verdict: string;
          }[];
          details: { groups: { cases: { meta: types.RunMetadata }[] }[] };
        };
        runs: number;
      }[];
      total: { penalty: number; points: number };
      username: string;
    }[];
    start_time: Date;
    time: Date;
    title: string;
  };
  export type ContestRequestsRequest = { [key: string]: any };
  export type _ContestRequestsServerResponse = any;
  export type ContestRequestsResponse = {
    contest_alias: string;
    users: {
      accepted?: boolean;
      admin?: { username?: string };
      country?: string;
      last_update?: Date;
      request_time: Date;
      username: string;
    }[];
  };
  export type ContestRoleRequest = { [key: string]: any };
  export type ContestRoleResponse = { admin: boolean };
  export type ContestRunsRequest = { [key: string]: any };
  export type _ContestRunsServerResponse = any;
  export type ContestRunsResponse = { runs: types.Run[] };
  export type ContestRunsDiffRequest = { [key: string]: any };
  export type ContestRunsDiffResponse = {
    diff: {
      guid: string;
      new_score?: number;
      new_status?: string;
      new_verdict?: string;
      old_score?: number;
      old_status?: string;
      old_verdict?: string;
      problemset_id?: number;
      username: string;
    }[];
  };
  export type ContestScoreboardRequest = { [key: string]: any };
  export type _ContestScoreboardServerResponse = any;
  export type ContestScoreboardResponse = types.Scoreboard;
  export type ContestScoreboardEventsRequest = { [key: string]: any };
  export type ContestScoreboardEventsResponse = {
    events: types.ScoreboardEvent[];
  };
  export type ContestScoreboardMergeRequest = { [key: string]: any };
  export type ContestScoreboardMergeResponse = {
    ranking: {
      contests: { [key: string]: { penalty: number; points: number } };
      name?: string;
      total: { penalty: number; points: number };
      username: string;
    }[];
  };
  export type ContestSearchUsersRequest = { [key: string]: any };
  export type ContestSearchUsersResponse = { label: string; value: string }[];
  export type ContestSetRecommendedRequest = { [key: string]: any };
  export type ContestSetRecommendedResponse = {};
  export type ContestStatsRequest = { [key: string]: any };
  export type _ContestStatsServerResponse = any;
  export type ContestStatsResponse = {
    distribution: { [key: number]: number };
    max_wait_time?: Date;
    max_wait_time_guid?: string;
    pending_runs: string[];
    size_of_bucket: number;
    total_points: number;
    total_runs: number;
    verdict_counts: { [key: string]: number };
  };
  export type ContestUpdateRequest = { [key: string]: any };
  export type ContestUpdateResponse = {};
  export type ContestUpdateEndTimeForIdentityRequest = { [key: string]: any };
  export type ContestUpdateEndTimeForIdentityResponse = {};
  export type ContestUsersRequest = { [key: string]: any };
  export type _ContestUsersServerResponse = any;
  export type ContestUsersResponse = {
    groups: { alias: string; name: string }[];
    users: types.ContestUser[];
  };

  // Course
  export type CourseActivityReportRequest = { [key: string]: any };
  export type _CourseActivityReportServerResponse = any;
  export type CourseActivityReportResponse = {
    events: {
      alias?: string;
      classname?: string;
      ip: number;
      time: Date;
      username: string;
    }[];
  };
  export type CourseAddAdminRequest = { [key: string]: any };
  export type CourseAddAdminResponse = {};
  export type CourseAddGroupAdminRequest = { [key: string]: any };
  export type CourseAddGroupAdminResponse = {};
  export type CourseAddProblemRequest = { [key: string]: any };
  export type CourseAddProblemResponse = {};
  export type CourseAddStudentRequest = { [key: string]: any };
  export type CourseAddStudentResponse = {};
  export type CourseAdminDetailsRequest = { [key: string]: any };
  export type _CourseAdminDetailsServerResponse = any;
  export type CourseAdminDetailsResponse = types.CourseDetails;
  export type CourseAdminsRequest = { [key: string]: any };
  export type CourseAdminsResponse = {
    admins: { role: string; username: string }[];
    group_admins: { alias: string; name: string; role: string }[];
  };
  export type CourseArbitrateRequestRequest = { [key: string]: any };
  export type CourseArbitrateRequestResponse = {};
  export type CourseAssignmentDetailsRequest = { [key: string]: any };
  export type _CourseAssignmentDetailsServerResponse = any;
  export type CourseAssignmentDetailsResponse = {
    admin: boolean;
    alias: string;
    assignment_type?: string;
    courseAssignments: types.CourseAssignment[];
    description?: string;
    director: string;
    finish_time?: Date;
    name: string;
    problems: types.ProblemsetProblem[];
    problemset_id: number;
    start_time: Date;
  };
  export type CourseAssignmentScoreboardRequest = { [key: string]: any };
  export type _CourseAssignmentScoreboardServerResponse = any;
  export type CourseAssignmentScoreboardResponse = types.Scoreboard;
  export type CourseAssignmentScoreboardEventsRequest = { [key: string]: any };
  export type CourseAssignmentScoreboardEventsResponse = {
    events: types.ScoreboardEvent[];
  };
  export type CourseCloneRequest = { [key: string]: any };
  export type CourseCloneResponse = { alias: string };
  export type CourseCreateRequest = { [key: string]: any };
  export type CourseCreateResponse = {};
  export type CourseCreateAssignmentRequest = { [key: string]: any };
  export type CourseCreateAssignmentResponse = {};
  export type CourseDetailsRequest = { [key: string]: any };
  export type _CourseDetailsServerResponse = any;
  export type CourseDetailsResponse = types.CourseDetails;
  export type CourseGenerateTokenForCloneCourseRequest = { [key: string]: any };
  export type CourseGenerateTokenForCloneCourseResponse = { token: string };
  export type CourseGetProblemUsersRequest = { [key: string]: any };
  export type CourseGetProblemUsersResponse = { identities: string[] };
  export type CourseIntroDetailsRequest = { [key: string]: any };
  export type CourseIntroDetailsResponse = {
    alias: string;
    currentUsername: string;
    description: string;
    isFirstTimeAccess: boolean;
    name: string;
    needsBasicInformation: boolean;
    requestsUserInformation: string;
    shouldShowAcceptTeacher: boolean;
    shouldShowResults: boolean;
    statements: {
      acceptTeacher: {
        gitObjectId?: string;
        markdown: string;
        statementType: string;
      };
      privacy: {
        gitObjectId?: string;
        markdown?: string;
        statementType?: string;
      };
    };
  };
  export type CourseListAssignmentsRequest = { [key: string]: any };
  export type _CourseListAssignmentsServerResponse = any;
  export type CourseListAssignmentsResponse = {
    assignments: types.CourseAssignment[];
  };
  export type CourseListCoursesRequest = { [key: string]: any };
  export type _CourseListCoursesServerResponse = any;
  export type CourseListCoursesResponse = types.CoursesList;
  export type CourseListSolvedProblemsRequest = { [key: string]: any };
  export type CourseListSolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  export type CourseListStudentsRequest = { [key: string]: any };
  export type CourseListStudentsResponse = { students: types.CourseStudent[] };
  export type CourseListUnsolvedProblemsRequest = { [key: string]: any };
  export type CourseListUnsolvedProblemsResponse = {
    user_problems: {
      [key: string]: { alias: string; title: string; username: string }[];
    };
  };
  export type CourseMyProgressRequest = { [key: string]: any };
  export type CourseMyProgressResponse = {
    assignments: types.AssignmentProgress;
  };
  export type CourseRegisterForCourseRequest = { [key: string]: any };
  export type CourseRegisterForCourseResponse = {};
  export type CourseRemoveAdminRequest = { [key: string]: any };
  export type CourseRemoveAdminResponse = {};
  export type CourseRemoveAssignmentRequest = { [key: string]: any };
  export type CourseRemoveAssignmentResponse = {};
  export type CourseRemoveGroupAdminRequest = { [key: string]: any };
  export type CourseRemoveGroupAdminResponse = {};
  export type CourseRemoveProblemRequest = { [key: string]: any };
  export type CourseRemoveProblemResponse = {};
  export type CourseRemoveStudentRequest = { [key: string]: any };
  export type CourseRemoveStudentResponse = {};
  export type CourseRequestsRequest = { [key: string]: any };
  export type _CourseRequestsServerResponse = any;
  export type CourseRequestsResponse = { users: types.IdentityRequest[] };
  export type CourseRunsRequest = { [key: string]: any };
  export type _CourseRunsServerResponse = any;
  export type CourseRunsResponse = { runs: types.Run[] };
  export type CourseStudentProgressRequest = { [key: string]: any };
  export type _CourseStudentProgressServerResponse = any;
  export type CourseStudentProgressResponse = {
    problems: types.CourseProblem[];
  };
  export type CourseUpdateRequest = { [key: string]: any };
  export type CourseUpdateResponse = {};
  export type CourseUpdateAssignmentRequest = { [key: string]: any };
  export type CourseUpdateAssignmentResponse = {};
  export type CourseUpdateAssignmentsOrderRequest = { [key: string]: any };
  export type CourseUpdateAssignmentsOrderResponse = {};
  export type CourseUpdateProblemsOrderRequest = { [key: string]: any };
  export type CourseUpdateProblemsOrderResponse = {};

  // Grader
  export type GraderStatusRequest = { [key: string]: any };
  export type GraderStatusResponse = { grader: types.GraderStatus };

  // Group
  export type GroupAddUserRequest = { [key: string]: any };
  export type GroupAddUserResponse = {};
  export type GroupCreateRequest = { [key: string]: any };
  export type GroupCreateResponse = {};
  export type GroupCreateScoreboardRequest = { [key: string]: any };
  export type GroupCreateScoreboardResponse = {};
  export type GroupDetailsRequest = { [key: string]: any };
  export type GroupDetailsResponse = {
    group: {
      alias?: string;
      create_time: number;
      description?: string;
      name?: string;
    };
    scoreboards: {
      alias: string;
      create_time: string;
      description?: string;
      name: string;
    }[];
  };
  export type GroupListRequest = { [key: string]: any };
  export type GroupListResponse = { label: string; value: string }[];
  export type GroupMembersRequest = { [key: string]: any };
  export type GroupMembersResponse = {
    identities: {
      classname: string;
      country?: string;
      country_id?: string;
      name?: string;
      school?: string;
      school_id?: number;
      state?: string;
      state_id?: string;
      username: string;
    }[];
  };
  export type GroupMyListRequest = { [key: string]: any };
  export type _GroupMyListServerResponse = any;
  export type GroupMyListResponse = {
    groups: {
      alias: string;
      create_time: Date;
      description?: string;
      name: string;
    }[];
  };
  export type GroupRemoveUserRequest = { [key: string]: any };
  export type GroupRemoveUserResponse = {};

  // GroupScoreboard
  export type GroupScoreboardAddContestRequest = { [key: string]: any };
  export type GroupScoreboardAddContestResponse = {};
  export type GroupScoreboardDetailsRequest = { [key: string]: any };
  export type _GroupScoreboardDetailsServerResponse = any;
  export type GroupScoreboardDetailsResponse = {
    contests: {
      acl_id: number;
      admission_mode: string;
      alias: string;
      contest_id: number;
      description: string;
      feedback: string;
      finish_time: Date;
      languages: string;
      last_updated: number;
      only_ac?: boolean;
      partial_score: boolean;
      penalty: string;
      penalty_calc_policy: string;
      points_decay_factor: number;
      problemset_id: number;
      recommended: boolean;
      rerun_id: number;
      scoreboard: number;
      show_scoreboard_after: boolean;
      start_time: Date;
      submissions_gap: number;
      title: string;
      urgent: boolean;
      weight?: number;
      window_length?: number;
    }[];
    ranking: {
      contests: { [key: string]: { penalty: number; points: number } };
      name?: string;
      total: { penalty: number; points: number };
      username: string;
    }[];
    scoreboard: {
      alias: string;
      create_time: number;
      description: string;
      group_id: number;
      group_scoreboard_id: number;
      name: string;
    };
  };
  export type GroupScoreboardListRequest = { [key: string]: any };
  export type GroupScoreboardListResponse = {
    scoreboards: {
      alias: string;
      create_time: number;
      description: string;
      group_id: number;
      group_scoreboard_id: number;
      name: string;
    }[];
  };
  export type GroupScoreboardRemoveContestRequest = { [key: string]: any };
  export type GroupScoreboardRemoveContestResponse = {};

  // Identity
  export type IdentityBulkCreateRequest = { [key: string]: any };
  export type IdentityBulkCreateResponse = {};
  export type IdentityChangePasswordRequest = { [key: string]: any };
  export type IdentityChangePasswordResponse = {};
  export type IdentityCreateRequest = { [key: string]: any };
  export type IdentityCreateResponse = { username: string };
  export type IdentityUpdateRequest = { [key: string]: any };
  export type IdentityUpdateResponse = {};

  // Interview
  export type InterviewAddUsersRequest = { [key: string]: any };
  export type InterviewAddUsersResponse = {};
  export type InterviewCreateRequest = { [key: string]: any };
  export type InterviewCreateResponse = {};
  export type InterviewDetailsRequest = { [key: string]: any };
  export type _InterviewDetailsServerResponse = any;
  export type InterviewDetailsResponse = {
    contest_alias?: string;
    description?: string;
    problemset_id?: number;
    users: {
      access_time?: Date;
      country?: string;
      email?: string;
      opened_interview: boolean;
      user_id?: number;
      username: string;
    }[];
  };
  export type InterviewListRequest = { [key: string]: any };
  export type InterviewListResponse = {
    result: {
      acl_id: number;
      alias: string;
      description: string;
      interview_id: number;
      problemset_id: number;
      title: string;
      window_length: number;
    }[];
  };

  // Notification
  export type NotificationMyListRequest = { [key: string]: any };
  export type _NotificationMyListServerResponse = any;
  export type NotificationMyListResponse = {
    notifications: types.Notification[];
  };
  export type NotificationReadNotificationsRequest = { [key: string]: any };
  export type NotificationReadNotificationsResponse = {};

  // Problem
  export type ProblemAddAdminRequest = { [key: string]: any };
  export type ProblemAddAdminResponse = {};
  export type ProblemAddGroupAdminRequest = { [key: string]: any };
  export type ProblemAddGroupAdminResponse = {};
  export type ProblemAddTagRequest = { [key: string]: any };
  export type ProblemAddTagResponse = { name: string };
  export type ProblemAdminListRequest = { [key: string]: any };
  export type ProblemAdminListResponse = {
    pagerItems: types.PageItem[];
    problems: types.ProblemListItem[];
  };
  export type ProblemAdminsRequest = { [key: string]: any };
  export type ProblemAdminsResponse = {
    admins: types.ProblemAdmin[];
    group_admins: types.ProblemGroupAdmin[];
  };
  export type ProblemBestScoreRequest = { [key: string]: any };
  export type ProblemBestScoreResponse = { score: number };
  export type ProblemClarificationsRequest = { [key: string]: any };
  export type _ProblemClarificationsServerResponse = any;
  export type ProblemClarificationsResponse = {
    clarifications: types.Clarification[];
  };
  export type ProblemCreateRequest = { [key: string]: any };
  export type ProblemCreateResponse = {};
  export type ProblemDeleteRequest = { [key: string]: any };
  export type ProblemDeleteResponse = {};
  export type ProblemDetailsRequest = { [key: string]: any };
  export type _ProblemDetailsServerResponse = any;
  export type ProblemDetailsResponse = types.ProblemDetails;
  export type ProblemListRequest = { [key: string]: any };
  export type ProblemListResponse = {
    results: types.ProblemListItem[];
    total: number;
  };
  export type ProblemMyListRequest = { [key: string]: any };
  export type ProblemMyListResponse = {
    pagerItems: types.PageItem[];
    problems: types.ProblemListItem[];
  };
  export type ProblemRejudgeRequest = { [key: string]: any };
  export type ProblemRejudgeResponse = {};
  export type ProblemRemoveAdminRequest = { [key: string]: any };
  export type ProblemRemoveAdminResponse = {};
  export type ProblemRemoveGroupAdminRequest = { [key: string]: any };
  export type ProblemRemoveGroupAdminResponse = {};
  export type ProblemRemoveTagRequest = { [key: string]: any };
  export type ProblemRemoveTagResponse = {};
  export type ProblemRunsRequest = { [key: string]: any };
  export type _ProblemRunsServerResponse = any;
  export type ProblemRunsResponse = { runs: types.Run[] };
  export type ProblemRunsDiffRequest = { [key: string]: any };
  export type ProblemRunsDiffResponse = { diff: types.RunsDiff[] };
  export type ProblemSelectVersionRequest = { [key: string]: any };
  export type ProblemSelectVersionResponse = {};
  export type ProblemSolutionRequest = { [key: string]: any };
  export type ProblemSolutionResponse = { solution?: types.ProblemStatement };
  export type ProblemStatsRequest = { [key: string]: any };
  export type ProblemStatsResponse = {
    cases_stats: { [key: string]: number };
    pending_runs: string[];
    total_runs: number;
    verdict_counts: { [key: string]: number };
  };
  export type ProblemTagsRequest = { [key: string]: any };
  export type ProblemTagsResponse = {
    tags: { name: string; public: boolean }[];
  };
  export type ProblemUpdateRequest = { [key: string]: any };
  export type ProblemUpdateResponse = { rejudged: boolean };
  export type ProblemUpdateProblemLevelRequest = { [key: string]: any };
  export type ProblemUpdateProblemLevelResponse = {};
  export type ProblemUpdateSolutionRequest = { [key: string]: any };
  export type ProblemUpdateSolutionResponse = {};
  export type ProblemUpdateStatementRequest = { [key: string]: any };
  export type ProblemUpdateStatementResponse = {};
  export type ProblemVersionsRequest = { [key: string]: any };
  export type _ProblemVersionsServerResponse = any;
  export type ProblemVersionsResponse = {
    log: types.ProblemVersion[];
    published?: string;
  };

  // ProblemForfeited
  export type ProblemForfeitedGetCountsRequest = { [key: string]: any };
  export type ProblemForfeitedGetCountsResponse = {
    allowed: number;
    seen: number;
  };

  // Problemset
  export type ProblemsetDetailsRequest = { [key: string]: any };
  export type _ProblemsetDetailsServerResponse = any;
  export type ProblemsetDetailsResponse = types.Problemset;
  export type ProblemsetScoreboardRequest = { [key: string]: any };
  export type _ProblemsetScoreboardServerResponse = any;
  export type ProblemsetScoreboardResponse = types.Scoreboard;
  export type ProblemsetScoreboardEventsRequest = { [key: string]: any };
  export type ProblemsetScoreboardEventsResponse = {
    events: types.ScoreboardEvent[];
  };

  // QualityNomination
  export type QualityNominationCreateRequest = { [key: string]: any };
  export type QualityNominationCreateResponse = {
    qualitynomination_id: number;
  };
  export type QualityNominationDetailsRequest = { [key: string]: any };
  export type _QualityNominationDetailsServerResponse = any;
  export type QualityNominationDetailsResponse = {
    author: { name?: string; username: string };
    contents?: {
      before_ac?: boolean;
      difficulty?: number;
      quality?: number;
      rationale?: string;
      reason?: string;
      statements?: { [key: string]: string };
      tags?: string[];
    };
    nomination: string;
    nomination_status: string;
    nominator: { name?: string; username: string };
    original_contents?: {
      source?: string;
      statements: { [key: string]: types.ProblemStatement };
      tags?: { name: string; source: string }[];
    };
    problem: { alias: string; title: string };
    qualitynomination_id: number;
    reviewer: boolean;
    time: Date;
    votes: {
      time?: Date;
      user: { name?: string; username: string };
      vote: number;
    }[];
  };
  export type QualityNominationListRequest = { [key: string]: any };
  export type _QualityNominationListServerResponse = any;
  export type QualityNominationListResponse = {
    nominations: types.NominationListItem[];
    pager_items: types.PageItem[];
  };
  export type QualityNominationMyAssignedListRequest = { [key: string]: any };
  export type _QualityNominationMyAssignedListServerResponse = any;
  export type QualityNominationMyAssignedListResponse = {
    nominations: {
      author: { name?: string; username: string };
      contents?: {
        before_ac?: boolean;
        difficulty?: number;
        quality?: number;
        rationale?: string;
        reason?: string;
        statements?: { [key: string]: string };
        tags?: string[];
      };
      nomination: string;
      nominator: { name?: string; username: string };
      problem: { alias: string; title: string };
      qualitynomination_id: number;
      status: string;
      time: Date;
      votes: {
        time?: Date;
        user: { name?: string; username: string };
        vote: number;
      }[];
    }[];
  };
  export type QualityNominationMyListRequest = { [key: string]: any };
  export type _QualityNominationMyListServerResponse = any;
  export type QualityNominationMyListResponse = {
    nominations: types.NominationListItem[];
    pager_items: types.PageItem[];
  };
  export type QualityNominationResolveRequest = { [key: string]: any };
  export type QualityNominationResolveResponse = {};

  // Reset
  export type ResetCreateRequest = { [key: string]: any };
  export type ResetCreateResponse = { message?: string; token?: string };
  export type ResetGenerateTokenRequest = { [key: string]: any };
  export type ResetGenerateTokenResponse = { link: string; token: string };
  export type ResetUpdateRequest = { [key: string]: any };
  export type ResetUpdateResponse = { message: string };

  // Run
  export type RunCountsRequest = { [key: string]: any };
  export type RunCountsResponse = {
    ac: { [key: string]: number };
    total: { [key: string]: number };
  };
  export type RunCreateRequest = { [key: string]: any };
  export type _RunCreateServerResponse = any;
  export type RunCreateResponse = {
    guid: string;
    nextSubmissionTimestamp: Date;
    submission_deadline: Date;
    submit_delay: number;
  };
  export type RunDetailsRequest = { [key: string]: any };
  export type RunDetailsResponse = types.RunDetails;
  export type RunDisqualifyRequest = { [key: string]: any };
  export type RunDisqualifyResponse = {};
  export type RunListRequest = { [key: string]: any };
  export type _RunListServerResponse = any;
  export type RunListResponse = { runs: types.Run[] };
  export type RunRejudgeRequest = { [key: string]: any };
  export type RunRejudgeResponse = {};
  export type RunSourceRequest = { [key: string]: any };
  export type RunSourceResponse = {
    compile_error?: string;
    details?: {
      compile_meta?: { [key: string]: types.RunMetadata };
      contest_score: number;
      groups?: {
        cases: {
          contest_score: number;
          max_score: number;
          meta: types.RunMetadata;
          name: string;
          score: number;
          verdict: string;
        }[];
        contest_score: number;
        group: string;
        max_score: number;
        score: number;
      }[];
      judged_by: string;
      max_score?: number;
      memory?: number;
      score: number;
      time?: number;
      verdict: string;
      wall_time?: number;
    };
    source: string;
  };
  export type RunStatusRequest = { [key: string]: any };
  export type _RunStatusServerResponse = any;
  export type RunStatusResponse = types.Run;

  // School
  export type SchoolCreateRequest = { [key: string]: any };
  export type SchoolCreateResponse = { school_id: number };
  export type SchoolListRequest = { [key: string]: any };
  export type SchoolListResponse = {
    id: number;
    label: string;
    value: string;
  }[];
  export type SchoolSelectSchoolOfTheMonthRequest = { [key: string]: any };
  export type SchoolSelectSchoolOfTheMonthResponse = {};

  // Scoreboard
  export type ScoreboardRefreshRequest = { [key: string]: any };
  export type ScoreboardRefreshResponse = {};

  // Session
  export type SessionCurrentSessionRequest = { [key: string]: any };
  export type SessionCurrentSessionResponse = {
    session?: {
      auth_token?: string;
      classname: string;
      email?: string;
      identity?: dao.Identities;
      is_admin: boolean;
      user?: dao.Users;
      valid: boolean;
    };
    time: number;
  };
  export type SessionGoogleLoginRequest = { [key: string]: any };
  export type SessionGoogleLoginResponse = { [key: string]: string };

  // Tag
  export type TagListRequest = { [key: string]: any };
  export type TagListResponse = { name: string }[];

  // Time
  export type TimeGetRequest = { [key: string]: any };
  export type TimeGetResponse = { time: number };

  // User
  export type UserAcceptPrivacyPolicyRequest = { [key: string]: any };
  export type UserAcceptPrivacyPolicyResponse = {};
  export type UserAddExperimentRequest = { [key: string]: any };
  export type UserAddExperimentResponse = {};
  export type UserAddGroupRequest = { [key: string]: any };
  export type UserAddGroupResponse = {};
  export type UserAddRoleRequest = { [key: string]: any };
  export type UserAddRoleResponse = {};
  export type UserAssociateIdentityRequest = { [key: string]: any };
  export type UserAssociateIdentityResponse = {};
  export type UserChangePasswordRequest = { [key: string]: any };
  export type UserChangePasswordResponse = {};
  export type UserCoderOfTheMonthRequest = { [key: string]: any };
  export type _UserCoderOfTheMonthServerResponse = any;
  export type UserCoderOfTheMonthResponse = { coderinfo?: types.UserProfile };
  export type UserCoderOfTheMonthListRequest = { [key: string]: any };
  export type UserCoderOfTheMonthListResponse = {
    coders: types.CoderOfTheMonthList;
  };
  export type UserContestStatsRequest = { [key: string]: any };
  export type _UserContestStatsServerResponse = any;
  export type UserContestStatsResponse = {
    contests: {
      [key: string]: {
        data: {
          alias: string;
          finish_time: Date;
          last_updated: Date;
          start_time: Date;
          title: string;
        };
        place?: number;
      };
    };
  };
  export type UserCreateRequest = { [key: string]: any };
  export type UserCreateResponse = { username: string };
  export type UserExtraInformationRequest = { [key: string]: any };
  export type _UserExtraInformationServerResponse = any;
  export type UserExtraInformationResponse = {
    last_login?: Date;
    username: string;
    verified: boolean;
    within_last_day: boolean;
  };
  export type UserGenerateGitTokenRequest = { [key: string]: any };
  export type UserGenerateGitTokenResponse = { token: string };
  export type UserGenerateOmiUsersRequest = { [key: string]: any };
  export type UserGenerateOmiUsersResponse = { [key: string]: string };
  export type UserInterviewStatsRequest = { [key: string]: any };
  export type UserInterviewStatsResponse = {
    finished: boolean;
    interview_url: string;
    name_or_username?: string;
    opened_interview: boolean;
    user_verified: boolean;
  };
  export type UserLastPrivacyPolicyAcceptedRequest = { [key: string]: any };
  export type UserLastPrivacyPolicyAcceptedResponse = { hasAccepted: boolean };
  export type UserListRequest = { [key: string]: any };
  export type UserListResponse = types.UserListItem[];
  export type UserListAssociatedIdentitiesRequest = { [key: string]: any };
  export type UserListAssociatedIdentitiesResponse = {
    identities: { default: boolean; username: string }[];
  };
  export type UserListUnsolvedProblemsRequest = { [key: string]: any };
  export type UserListUnsolvedProblemsResponse = { problems: types.Problem[] };
  export type UserLoginRequest = { [key: string]: any };
  export type UserLoginResponse = { auth_token: string };
  export type UserMailingListBackfillRequest = { [key: string]: any };
  export type UserMailingListBackfillResponse = {
    users: { [key: string]: boolean };
  };
  export type UserProblemsCreatedRequest = { [key: string]: any };
  export type UserProblemsCreatedResponse = { problems: types.Problem[] };
  export type UserProblemsSolvedRequest = { [key: string]: any };
  export type UserProblemsSolvedResponse = { problems: types.Problem[] };
  export type UserProfileRequest = { [key: string]: any };
  export type _UserProfileServerResponse = any;
  export type UserProfileResponse = types.UserProfileInfo;
  export type UserRemoveExperimentRequest = { [key: string]: any };
  export type UserRemoveExperimentResponse = {};
  export type UserRemoveGroupRequest = { [key: string]: any };
  export type UserRemoveGroupResponse = {};
  export type UserRemoveRoleRequest = { [key: string]: any };
  export type UserRemoveRoleResponse = {};
  export type UserSelectCoderOfTheMonthRequest = { [key: string]: any };
  export type UserSelectCoderOfTheMonthResponse = {};
  export type UserStatsRequest = { [key: string]: any };
  export type UserStatsResponse = {
    runs: { date?: string; runs: number; verdict: string }[];
  };
  export type UserStatusVerifiedRequest = { [key: string]: any };
  export type UserStatusVerifiedResponse = {
    username: string;
    verified: boolean;
  };
  export type UserUpdateRequest = { [key: string]: any };
  export type UserUpdateResponse = {};
  export type UserUpdateBasicInfoRequest = { [key: string]: any };
  export type UserUpdateBasicInfoResponse = {};
  export type UserUpdateMainEmailRequest = { [key: string]: any };
  export type UserUpdateMainEmailResponse = {};
  export type UserValidateFilterRequest = { [key: string]: any };
  export type UserValidateFilterResponse = {
    admin: boolean;
    contest_admin: string[];
    problem_admin: string[];
    problemset_admin: number[];
    user?: string;
  };
  export type UserVerifyEmailRequest = { [key: string]: any };
  export type UserVerifyEmailResponse = {};
}

// Controller interfaces
export namespace controllers {
  export interface Admin {
    platformReportStats: (
      params?: messages.AdminPlatformReportStatsRequest,
    ) => Promise<messages.AdminPlatformReportStatsResponse>;
  }

  export interface Authorization {
    problem: (
      params?: messages.AuthorizationProblemRequest,
    ) => Promise<messages.AuthorizationProblemResponse>;
  }

  export interface Badge {
    badgeDetails: (
      params?: messages.BadgeBadgeDetailsRequest,
    ) => Promise<messages.BadgeBadgeDetailsResponse>;
    list: (
      params?: messages.BadgeListRequest,
    ) => Promise<messages.BadgeListResponse>;
    myBadgeAssignationTime: (
      params?: messages.BadgeMyBadgeAssignationTimeRequest,
    ) => Promise<messages.BadgeMyBadgeAssignationTimeResponse>;
    myList: (
      params?: messages.BadgeMyListRequest,
    ) => Promise<messages.BadgeMyListResponse>;
    userList: (
      params?: messages.BadgeUserListRequest,
    ) => Promise<messages.BadgeUserListResponse>;
  }

  export interface Clarification {
    create: (
      params?: messages.ClarificationCreateRequest,
    ) => Promise<messages.ClarificationCreateResponse>;
    details: (
      params?: messages.ClarificationDetailsRequest,
    ) => Promise<messages.ClarificationDetailsResponse>;
    update: (
      params?: messages.ClarificationUpdateRequest,
    ) => Promise<messages.ClarificationUpdateResponse>;
  }

  export interface Contest {
    activityReport: (
      params?: messages.ContestActivityReportRequest,
    ) => Promise<messages.ContestActivityReportResponse>;
    addAdmin: (
      params?: messages.ContestAddAdminRequest,
    ) => Promise<messages.ContestAddAdminResponse>;
    addGroup: (
      params?: messages.ContestAddGroupRequest,
    ) => Promise<messages.ContestAddGroupResponse>;
    addGroupAdmin: (
      params?: messages.ContestAddGroupAdminRequest,
    ) => Promise<messages.ContestAddGroupAdminResponse>;
    addProblem: (
      params?: messages.ContestAddProblemRequest,
    ) => Promise<messages.ContestAddProblemResponse>;
    addUser: (
      params?: messages.ContestAddUserRequest,
    ) => Promise<messages.ContestAddUserResponse>;
    adminDetails: (
      params?: messages.ContestAdminDetailsRequest,
    ) => Promise<messages.ContestAdminDetailsResponse>;
    adminList: (
      params?: messages.ContestAdminListRequest,
    ) => Promise<messages.ContestAdminListResponse>;
    admins: (
      params?: messages.ContestAdminsRequest,
    ) => Promise<messages.ContestAdminsResponse>;
    arbitrateRequest: (
      params?: messages.ContestArbitrateRequestRequest,
    ) => Promise<messages.ContestArbitrateRequestResponse>;
    clarifications: (
      params?: messages.ContestClarificationsRequest,
    ) => Promise<messages.ContestClarificationsResponse>;
    clone: (
      params?: messages.ContestCloneRequest,
    ) => Promise<messages.ContestCloneResponse>;
    contestants: (
      params?: messages.ContestContestantsRequest,
    ) => Promise<messages.ContestContestantsResponse>;
    create: (
      params?: messages.ContestCreateRequest,
    ) => Promise<messages.ContestCreateResponse>;
    createVirtual: (
      params?: messages.ContestCreateVirtualRequest,
    ) => Promise<messages.ContestCreateVirtualResponse>;
    details: (
      params?: messages.ContestDetailsRequest,
    ) => Promise<messages.ContestDetailsResponse>;
    list: (
      params?: messages.ContestListRequest,
    ) => Promise<messages.ContestListResponse>;
    listParticipating: (
      params?: messages.ContestListParticipatingRequest,
    ) => Promise<messages.ContestListParticipatingResponse>;
    myList: (
      params?: messages.ContestMyListRequest,
    ) => Promise<messages.ContestMyListResponse>;
    open: (
      params?: messages.ContestOpenRequest,
    ) => Promise<messages.ContestOpenResponse>;
    problems: (
      params?: messages.ContestProblemsRequest,
    ) => Promise<messages.ContestProblemsResponse>;
    publicDetails: (
      params?: messages.ContestPublicDetailsRequest,
    ) => Promise<messages.ContestPublicDetailsResponse>;
    registerForContest: (
      params?: messages.ContestRegisterForContestRequest,
    ) => Promise<messages.ContestRegisterForContestResponse>;
    removeAdmin: (
      params?: messages.ContestRemoveAdminRequest,
    ) => Promise<messages.ContestRemoveAdminResponse>;
    removeGroup: (
      params?: messages.ContestRemoveGroupRequest,
    ) => Promise<messages.ContestRemoveGroupResponse>;
    removeGroupAdmin: (
      params?: messages.ContestRemoveGroupAdminRequest,
    ) => Promise<messages.ContestRemoveGroupAdminResponse>;
    removeProblem: (
      params?: messages.ContestRemoveProblemRequest,
    ) => Promise<messages.ContestRemoveProblemResponse>;
    removeUser: (
      params?: messages.ContestRemoveUserRequest,
    ) => Promise<messages.ContestRemoveUserResponse>;
    report: (
      params?: messages.ContestReportRequest,
    ) => Promise<messages.ContestReportResponse>;
    requests: (
      params?: messages.ContestRequestsRequest,
    ) => Promise<messages.ContestRequestsResponse>;
    role: (
      params?: messages.ContestRoleRequest,
    ) => Promise<messages.ContestRoleResponse>;
    runs: (
      params?: messages.ContestRunsRequest,
    ) => Promise<messages.ContestRunsResponse>;
    runsDiff: (
      params?: messages.ContestRunsDiffRequest,
    ) => Promise<messages.ContestRunsDiffResponse>;
    scoreboard: (
      params?: messages.ContestScoreboardRequest,
    ) => Promise<messages.ContestScoreboardResponse>;
    scoreboardEvents: (
      params?: messages.ContestScoreboardEventsRequest,
    ) => Promise<messages.ContestScoreboardEventsResponse>;
    scoreboardMerge: (
      params?: messages.ContestScoreboardMergeRequest,
    ) => Promise<messages.ContestScoreboardMergeResponse>;
    searchUsers: (
      params?: messages.ContestSearchUsersRequest,
    ) => Promise<messages.ContestSearchUsersResponse>;
    setRecommended: (
      params?: messages.ContestSetRecommendedRequest,
    ) => Promise<messages.ContestSetRecommendedResponse>;
    stats: (
      params?: messages.ContestStatsRequest,
    ) => Promise<messages.ContestStatsResponse>;
    update: (
      params?: messages.ContestUpdateRequest,
    ) => Promise<messages.ContestUpdateResponse>;
    updateEndTimeForIdentity: (
      params?: messages.ContestUpdateEndTimeForIdentityRequest,
    ) => Promise<messages.ContestUpdateEndTimeForIdentityResponse>;
    users: (
      params?: messages.ContestUsersRequest,
    ) => Promise<messages.ContestUsersResponse>;
  }

  export interface Course {
    activityReport: (
      params?: messages.CourseActivityReportRequest,
    ) => Promise<messages.CourseActivityReportResponse>;
    addAdmin: (
      params?: messages.CourseAddAdminRequest,
    ) => Promise<messages.CourseAddAdminResponse>;
    addGroupAdmin: (
      params?: messages.CourseAddGroupAdminRequest,
    ) => Promise<messages.CourseAddGroupAdminResponse>;
    addProblem: (
      params?: messages.CourseAddProblemRequest,
    ) => Promise<messages.CourseAddProblemResponse>;
    addStudent: (
      params?: messages.CourseAddStudentRequest,
    ) => Promise<messages.CourseAddStudentResponse>;
    adminDetails: (
      params?: messages.CourseAdminDetailsRequest,
    ) => Promise<messages.CourseAdminDetailsResponse>;
    admins: (
      params?: messages.CourseAdminsRequest,
    ) => Promise<messages.CourseAdminsResponse>;
    arbitrateRequest: (
      params?: messages.CourseArbitrateRequestRequest,
    ) => Promise<messages.CourseArbitrateRequestResponse>;
    assignmentDetails: (
      params?: messages.CourseAssignmentDetailsRequest,
    ) => Promise<messages.CourseAssignmentDetailsResponse>;
    assignmentScoreboard: (
      params?: messages.CourseAssignmentScoreboardRequest,
    ) => Promise<messages.CourseAssignmentScoreboardResponse>;
    assignmentScoreboardEvents: (
      params?: messages.CourseAssignmentScoreboardEventsRequest,
    ) => Promise<messages.CourseAssignmentScoreboardEventsResponse>;
    clone: (
      params?: messages.CourseCloneRequest,
    ) => Promise<messages.CourseCloneResponse>;
    create: (
      params?: messages.CourseCreateRequest,
    ) => Promise<messages.CourseCreateResponse>;
    createAssignment: (
      params?: messages.CourseCreateAssignmentRequest,
    ) => Promise<messages.CourseCreateAssignmentResponse>;
    details: (
      params?: messages.CourseDetailsRequest,
    ) => Promise<messages.CourseDetailsResponse>;
    generateTokenForCloneCourse: (
      params?: messages.CourseGenerateTokenForCloneCourseRequest,
    ) => Promise<messages.CourseGenerateTokenForCloneCourseResponse>;
    getProblemUsers: (
      params?: messages.CourseGetProblemUsersRequest,
    ) => Promise<messages.CourseGetProblemUsersResponse>;
    introDetails: (
      params?: messages.CourseIntroDetailsRequest,
    ) => Promise<messages.CourseIntroDetailsResponse>;
    listAssignments: (
      params?: messages.CourseListAssignmentsRequest,
    ) => Promise<messages.CourseListAssignmentsResponse>;
    listCourses: (
      params?: messages.CourseListCoursesRequest,
    ) => Promise<messages.CourseListCoursesResponse>;
    listSolvedProblems: (
      params?: messages.CourseListSolvedProblemsRequest,
    ) => Promise<messages.CourseListSolvedProblemsResponse>;
    listStudents: (
      params?: messages.CourseListStudentsRequest,
    ) => Promise<messages.CourseListStudentsResponse>;
    listUnsolvedProblems: (
      params?: messages.CourseListUnsolvedProblemsRequest,
    ) => Promise<messages.CourseListUnsolvedProblemsResponse>;
    myProgress: (
      params?: messages.CourseMyProgressRequest,
    ) => Promise<messages.CourseMyProgressResponse>;
    registerForCourse: (
      params?: messages.CourseRegisterForCourseRequest,
    ) => Promise<messages.CourseRegisterForCourseResponse>;
    removeAdmin: (
      params?: messages.CourseRemoveAdminRequest,
    ) => Promise<messages.CourseRemoveAdminResponse>;
    removeAssignment: (
      params?: messages.CourseRemoveAssignmentRequest,
    ) => Promise<messages.CourseRemoveAssignmentResponse>;
    removeGroupAdmin: (
      params?: messages.CourseRemoveGroupAdminRequest,
    ) => Promise<messages.CourseRemoveGroupAdminResponse>;
    removeProblem: (
      params?: messages.CourseRemoveProblemRequest,
    ) => Promise<messages.CourseRemoveProblemResponse>;
    removeStudent: (
      params?: messages.CourseRemoveStudentRequest,
    ) => Promise<messages.CourseRemoveStudentResponse>;
    requests: (
      params?: messages.CourseRequestsRequest,
    ) => Promise<messages.CourseRequestsResponse>;
    runs: (
      params?: messages.CourseRunsRequest,
    ) => Promise<messages.CourseRunsResponse>;
    studentProgress: (
      params?: messages.CourseStudentProgressRequest,
    ) => Promise<messages.CourseStudentProgressResponse>;
    update: (
      params?: messages.CourseUpdateRequest,
    ) => Promise<messages.CourseUpdateResponse>;
    updateAssignment: (
      params?: messages.CourseUpdateAssignmentRequest,
    ) => Promise<messages.CourseUpdateAssignmentResponse>;
    updateAssignmentsOrder: (
      params?: messages.CourseUpdateAssignmentsOrderRequest,
    ) => Promise<messages.CourseUpdateAssignmentsOrderResponse>;
    updateProblemsOrder: (
      params?: messages.CourseUpdateProblemsOrderRequest,
    ) => Promise<messages.CourseUpdateProblemsOrderResponse>;
  }

  export interface Grader {
    status: (
      params?: messages.GraderStatusRequest,
    ) => Promise<messages.GraderStatusResponse>;
  }

  export interface Group {
    addUser: (
      params?: messages.GroupAddUserRequest,
    ) => Promise<messages.GroupAddUserResponse>;
    create: (
      params?: messages.GroupCreateRequest,
    ) => Promise<messages.GroupCreateResponse>;
    createScoreboard: (
      params?: messages.GroupCreateScoreboardRequest,
    ) => Promise<messages.GroupCreateScoreboardResponse>;
    details: (
      params?: messages.GroupDetailsRequest,
    ) => Promise<messages.GroupDetailsResponse>;
    list: (
      params?: messages.GroupListRequest,
    ) => Promise<messages.GroupListResponse>;
    members: (
      params?: messages.GroupMembersRequest,
    ) => Promise<messages.GroupMembersResponse>;
    myList: (
      params?: messages.GroupMyListRequest,
    ) => Promise<messages.GroupMyListResponse>;
    removeUser: (
      params?: messages.GroupRemoveUserRequest,
    ) => Promise<messages.GroupRemoveUserResponse>;
  }

  export interface GroupScoreboard {
    addContest: (
      params?: messages.GroupScoreboardAddContestRequest,
    ) => Promise<messages.GroupScoreboardAddContestResponse>;
    details: (
      params?: messages.GroupScoreboardDetailsRequest,
    ) => Promise<messages.GroupScoreboardDetailsResponse>;
    list: (
      params?: messages.GroupScoreboardListRequest,
    ) => Promise<messages.GroupScoreboardListResponse>;
    removeContest: (
      params?: messages.GroupScoreboardRemoveContestRequest,
    ) => Promise<messages.GroupScoreboardRemoveContestResponse>;
  }

  export interface Identity {
    bulkCreate: (
      params?: messages.IdentityBulkCreateRequest,
    ) => Promise<messages.IdentityBulkCreateResponse>;
    changePassword: (
      params?: messages.IdentityChangePasswordRequest,
    ) => Promise<messages.IdentityChangePasswordResponse>;
    create: (
      params?: messages.IdentityCreateRequest,
    ) => Promise<messages.IdentityCreateResponse>;
    update: (
      params?: messages.IdentityUpdateRequest,
    ) => Promise<messages.IdentityUpdateResponse>;
  }

  export interface Interview {
    addUsers: (
      params?: messages.InterviewAddUsersRequest,
    ) => Promise<messages.InterviewAddUsersResponse>;
    create: (
      params?: messages.InterviewCreateRequest,
    ) => Promise<messages.InterviewCreateResponse>;
    details: (
      params?: messages.InterviewDetailsRequest,
    ) => Promise<messages.InterviewDetailsResponse>;
    list: (
      params?: messages.InterviewListRequest,
    ) => Promise<messages.InterviewListResponse>;
  }

  export interface Notification {
    myList: (
      params?: messages.NotificationMyListRequest,
    ) => Promise<messages.NotificationMyListResponse>;
    readNotifications: (
      params?: messages.NotificationReadNotificationsRequest,
    ) => Promise<messages.NotificationReadNotificationsResponse>;
  }

  export interface Problem {
    addAdmin: (
      params?: messages.ProblemAddAdminRequest,
    ) => Promise<messages.ProblemAddAdminResponse>;
    addGroupAdmin: (
      params?: messages.ProblemAddGroupAdminRequest,
    ) => Promise<messages.ProblemAddGroupAdminResponse>;
    addTag: (
      params?: messages.ProblemAddTagRequest,
    ) => Promise<messages.ProblemAddTagResponse>;
    adminList: (
      params?: messages.ProblemAdminListRequest,
    ) => Promise<messages.ProblemAdminListResponse>;
    admins: (
      params?: messages.ProblemAdminsRequest,
    ) => Promise<messages.ProblemAdminsResponse>;
    bestScore: (
      params?: messages.ProblemBestScoreRequest,
    ) => Promise<messages.ProblemBestScoreResponse>;
    clarifications: (
      params?: messages.ProblemClarificationsRequest,
    ) => Promise<messages.ProblemClarificationsResponse>;
    create: (
      params?: messages.ProblemCreateRequest,
    ) => Promise<messages.ProblemCreateResponse>;
    delete: (
      params?: messages.ProblemDeleteRequest,
    ) => Promise<messages.ProblemDeleteResponse>;
    details: (
      params?: messages.ProblemDetailsRequest,
    ) => Promise<messages.ProblemDetailsResponse>;
    list: (
      params?: messages.ProblemListRequest,
    ) => Promise<messages.ProblemListResponse>;
    myList: (
      params?: messages.ProblemMyListRequest,
    ) => Promise<messages.ProblemMyListResponse>;
    rejudge: (
      params?: messages.ProblemRejudgeRequest,
    ) => Promise<messages.ProblemRejudgeResponse>;
    removeAdmin: (
      params?: messages.ProblemRemoveAdminRequest,
    ) => Promise<messages.ProblemRemoveAdminResponse>;
    removeGroupAdmin: (
      params?: messages.ProblemRemoveGroupAdminRequest,
    ) => Promise<messages.ProblemRemoveGroupAdminResponse>;
    removeTag: (
      params?: messages.ProblemRemoveTagRequest,
    ) => Promise<messages.ProblemRemoveTagResponse>;
    runs: (
      params?: messages.ProblemRunsRequest,
    ) => Promise<messages.ProblemRunsResponse>;
    runsDiff: (
      params?: messages.ProblemRunsDiffRequest,
    ) => Promise<messages.ProblemRunsDiffResponse>;
    selectVersion: (
      params?: messages.ProblemSelectVersionRequest,
    ) => Promise<messages.ProblemSelectVersionResponse>;
    solution: (
      params?: messages.ProblemSolutionRequest,
    ) => Promise<messages.ProblemSolutionResponse>;
    stats: (
      params?: messages.ProblemStatsRequest,
    ) => Promise<messages.ProblemStatsResponse>;
    tags: (
      params?: messages.ProblemTagsRequest,
    ) => Promise<messages.ProblemTagsResponse>;
    update: (
      params?: messages.ProblemUpdateRequest,
    ) => Promise<messages.ProblemUpdateResponse>;
    updateProblemLevel: (
      params?: messages.ProblemUpdateProblemLevelRequest,
    ) => Promise<messages.ProblemUpdateProblemLevelResponse>;
    updateSolution: (
      params?: messages.ProblemUpdateSolutionRequest,
    ) => Promise<messages.ProblemUpdateSolutionResponse>;
    updateStatement: (
      params?: messages.ProblemUpdateStatementRequest,
    ) => Promise<messages.ProblemUpdateStatementResponse>;
    versions: (
      params?: messages.ProblemVersionsRequest,
    ) => Promise<messages.ProblemVersionsResponse>;
  }

  export interface ProblemForfeited {
    getCounts: (
      params?: messages.ProblemForfeitedGetCountsRequest,
    ) => Promise<messages.ProblemForfeitedGetCountsResponse>;
  }

  export interface Problemset {
    details: (
      params?: messages.ProblemsetDetailsRequest,
    ) => Promise<messages.ProblemsetDetailsResponse>;
    scoreboard: (
      params?: messages.ProblemsetScoreboardRequest,
    ) => Promise<messages.ProblemsetScoreboardResponse>;
    scoreboardEvents: (
      params?: messages.ProblemsetScoreboardEventsRequest,
    ) => Promise<messages.ProblemsetScoreboardEventsResponse>;
  }

  export interface QualityNomination {
    create: (
      params?: messages.QualityNominationCreateRequest,
    ) => Promise<messages.QualityNominationCreateResponse>;
    details: (
      params?: messages.QualityNominationDetailsRequest,
    ) => Promise<messages.QualityNominationDetailsResponse>;
    list: (
      params?: messages.QualityNominationListRequest,
    ) => Promise<messages.QualityNominationListResponse>;
    myAssignedList: (
      params?: messages.QualityNominationMyAssignedListRequest,
    ) => Promise<messages.QualityNominationMyAssignedListResponse>;
    myList: (
      params?: messages.QualityNominationMyListRequest,
    ) => Promise<messages.QualityNominationMyListResponse>;
    resolve: (
      params?: messages.QualityNominationResolveRequest,
    ) => Promise<messages.QualityNominationResolveResponse>;
  }

  export interface Reset {
    create: (
      params?: messages.ResetCreateRequest,
    ) => Promise<messages.ResetCreateResponse>;
    generateToken: (
      params?: messages.ResetGenerateTokenRequest,
    ) => Promise<messages.ResetGenerateTokenResponse>;
    update: (
      params?: messages.ResetUpdateRequest,
    ) => Promise<messages.ResetUpdateResponse>;
  }

  export interface Run {
    counts: (
      params?: messages.RunCountsRequest,
    ) => Promise<messages.RunCountsResponse>;
    create: (
      params?: messages.RunCreateRequest,
    ) => Promise<messages.RunCreateResponse>;
    details: (
      params?: messages.RunDetailsRequest,
    ) => Promise<messages.RunDetailsResponse>;
    disqualify: (
      params?: messages.RunDisqualifyRequest,
    ) => Promise<messages.RunDisqualifyResponse>;
    list: (
      params?: messages.RunListRequest,
    ) => Promise<messages.RunListResponse>;
    rejudge: (
      params?: messages.RunRejudgeRequest,
    ) => Promise<messages.RunRejudgeResponse>;
    source: (
      params?: messages.RunSourceRequest,
    ) => Promise<messages.RunSourceResponse>;
    status: (
      params?: messages.RunStatusRequest,
    ) => Promise<messages.RunStatusResponse>;
  }

  export interface School {
    create: (
      params?: messages.SchoolCreateRequest,
    ) => Promise<messages.SchoolCreateResponse>;
    list: (
      params?: messages.SchoolListRequest,
    ) => Promise<messages.SchoolListResponse>;
    selectSchoolOfTheMonth: (
      params?: messages.SchoolSelectSchoolOfTheMonthRequest,
    ) => Promise<messages.SchoolSelectSchoolOfTheMonthResponse>;
  }

  export interface Scoreboard {
    refresh: (
      params?: messages.ScoreboardRefreshRequest,
    ) => Promise<messages.ScoreboardRefreshResponse>;
  }

  export interface Session {
    currentSession: (
      params?: messages.SessionCurrentSessionRequest,
    ) => Promise<messages.SessionCurrentSessionResponse>;
    googleLogin: (
      params?: messages.SessionGoogleLoginRequest,
    ) => Promise<messages.SessionGoogleLoginResponse>;
  }

  export interface Tag {
    list: (
      params?: messages.TagListRequest,
    ) => Promise<messages.TagListResponse>;
  }

  export interface Time {
    get: (
      params?: messages.TimeGetRequest,
    ) => Promise<messages.TimeGetResponse>;
  }

  export interface User {
    acceptPrivacyPolicy: (
      params?: messages.UserAcceptPrivacyPolicyRequest,
    ) => Promise<messages.UserAcceptPrivacyPolicyResponse>;
    addExperiment: (
      params?: messages.UserAddExperimentRequest,
    ) => Promise<messages.UserAddExperimentResponse>;
    addGroup: (
      params?: messages.UserAddGroupRequest,
    ) => Promise<messages.UserAddGroupResponse>;
    addRole: (
      params?: messages.UserAddRoleRequest,
    ) => Promise<messages.UserAddRoleResponse>;
    associateIdentity: (
      params?: messages.UserAssociateIdentityRequest,
    ) => Promise<messages.UserAssociateIdentityResponse>;
    changePassword: (
      params?: messages.UserChangePasswordRequest,
    ) => Promise<messages.UserChangePasswordResponse>;
    coderOfTheMonth: (
      params?: messages.UserCoderOfTheMonthRequest,
    ) => Promise<messages.UserCoderOfTheMonthResponse>;
    coderOfTheMonthList: (
      params?: messages.UserCoderOfTheMonthListRequest,
    ) => Promise<messages.UserCoderOfTheMonthListResponse>;
    contestStats: (
      params?: messages.UserContestStatsRequest,
    ) => Promise<messages.UserContestStatsResponse>;
    create: (
      params?: messages.UserCreateRequest,
    ) => Promise<messages.UserCreateResponse>;
    extraInformation: (
      params?: messages.UserExtraInformationRequest,
    ) => Promise<messages.UserExtraInformationResponse>;
    generateGitToken: (
      params?: messages.UserGenerateGitTokenRequest,
    ) => Promise<messages.UserGenerateGitTokenResponse>;
    generateOmiUsers: (
      params?: messages.UserGenerateOmiUsersRequest,
    ) => Promise<messages.UserGenerateOmiUsersResponse>;
    interviewStats: (
      params?: messages.UserInterviewStatsRequest,
    ) => Promise<messages.UserInterviewStatsResponse>;
    lastPrivacyPolicyAccepted: (
      params?: messages.UserLastPrivacyPolicyAcceptedRequest,
    ) => Promise<messages.UserLastPrivacyPolicyAcceptedResponse>;
    list: (
      params?: messages.UserListRequest,
    ) => Promise<messages.UserListResponse>;
    listAssociatedIdentities: (
      params?: messages.UserListAssociatedIdentitiesRequest,
    ) => Promise<messages.UserListAssociatedIdentitiesResponse>;
    listUnsolvedProblems: (
      params?: messages.UserListUnsolvedProblemsRequest,
    ) => Promise<messages.UserListUnsolvedProblemsResponse>;
    login: (
      params?: messages.UserLoginRequest,
    ) => Promise<messages.UserLoginResponse>;
    mailingListBackfill: (
      params?: messages.UserMailingListBackfillRequest,
    ) => Promise<messages.UserMailingListBackfillResponse>;
    problemsCreated: (
      params?: messages.UserProblemsCreatedRequest,
    ) => Promise<messages.UserProblemsCreatedResponse>;
    problemsSolved: (
      params?: messages.UserProblemsSolvedRequest,
    ) => Promise<messages.UserProblemsSolvedResponse>;
    profile: (
      params?: messages.UserProfileRequest,
    ) => Promise<messages.UserProfileResponse>;
    removeExperiment: (
      params?: messages.UserRemoveExperimentRequest,
    ) => Promise<messages.UserRemoveExperimentResponse>;
    removeGroup: (
      params?: messages.UserRemoveGroupRequest,
    ) => Promise<messages.UserRemoveGroupResponse>;
    removeRole: (
      params?: messages.UserRemoveRoleRequest,
    ) => Promise<messages.UserRemoveRoleResponse>;
    selectCoderOfTheMonth: (
      params?: messages.UserSelectCoderOfTheMonthRequest,
    ) => Promise<messages.UserSelectCoderOfTheMonthResponse>;
    stats: (
      params?: messages.UserStatsRequest,
    ) => Promise<messages.UserStatsResponse>;
    statusVerified: (
      params?: messages.UserStatusVerifiedRequest,
    ) => Promise<messages.UserStatusVerifiedResponse>;
    update: (
      params?: messages.UserUpdateRequest,
    ) => Promise<messages.UserUpdateResponse>;
    updateBasicInfo: (
      params?: messages.UserUpdateBasicInfoRequest,
    ) => Promise<messages.UserUpdateBasicInfoResponse>;
    updateMainEmail: (
      params?: messages.UserUpdateMainEmailRequest,
    ) => Promise<messages.UserUpdateMainEmailResponse>;
    validateFilter: (
      params?: messages.UserValidateFilterRequest,
    ) => Promise<messages.UserValidateFilterResponse>;
    verifyEmail: (
      params?: messages.UserVerifyEmailRequest,
    ) => Promise<messages.UserVerifyEmailResponse>;
  }
}
