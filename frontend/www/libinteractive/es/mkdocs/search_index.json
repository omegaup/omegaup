{
    "docs": [
        {
            "location": "/",
            "text": "libinteractive\n\n\nUn peque\u00f1o traductor de IDL que crea adaptadores que hacen llamadas entre\nprocesos para crear problemas interactivos f\u00e1cilmente.\n\n\nPara evitar tener que escribir un programa en cada uno de los lenguajes\nsoportados y asegurarse que no tengan bugs y no tengan comportamiento\nindefinido que pueda hacer que se emita un veredicto incorrecto, libinteractive\nte permite tener ambas implementaciones en procesos (y lenguajes) separados.\n\n\nEjemplo\n\n\nDigamos que tienes un problema llamado \nsumas\n. T\u00fa como juez implementas un\nvalidador en un archivo \nMain.cpp\n y el competidor codifica la soluci\u00f3n en\n\nsumas.py\n, puedes hacer:\n\n\n$ ls\nMain.cpp sumas.py sumas.idl input\n\n$ cat Main.cpp\n#include <stdio.h>\n#include \"sumas.h\"\n\nint main(int argc, char* argv[]) {\n    int a, b;\n    scanf(\"%d %d\\n\", &a, &b);\n    printf(\"%d\\n\", sumas(a, b));\n}\n\n$ cat sumas.py\ndef sumas(a, b):\n    print 'Hola, mundo!'\n    return a + b\n\n$ cat sumas.idl\ninterface Main {\n};\n\ninterface sumas {\n    int sumas(int a, int b);\n};\n\n$ java -jar libinteractive.jar generate sumas.idl cpp py --makefile\n$ make run < input\n[Main] 3\n[ sum] Hola, mundo!\n\nMemory:   5.023 MB\nTime:     0.011 s\n\n\n\n\nTambi\u00e9n puedes agregar la bandera \n--verbose\n a libinteractive para imprimir\nmensajes de depuraci\u00f3n cada vez que se realiza una llamada entre los procesos.\n\n\nDescarga\n\n\nPuedes descargar el .jar m\u00e1s reciente de la \np\u00e1gina de descargas\n.",
            "title": "\u00cdndice"
        },
        {
            "location": "/#libinteractive",
            "text": "Un peque\u00f1o traductor de IDL que crea adaptadores que hacen llamadas entre\nprocesos para crear problemas interactivos f\u00e1cilmente.  Para evitar tener que escribir un programa en cada uno de los lenguajes\nsoportados y asegurarse que no tengan bugs y no tengan comportamiento\nindefinido que pueda hacer que se emita un veredicto incorrecto, libinteractive\nte permite tener ambas implementaciones en procesos (y lenguajes) separados.  Ejemplo  Digamos que tienes un problema llamado  sumas . T\u00fa como juez implementas un\nvalidador en un archivo  Main.cpp  y el competidor codifica la soluci\u00f3n en sumas.py , puedes hacer:  $ ls\nMain.cpp sumas.py sumas.idl input\n\n$ cat Main.cpp\n#include <stdio.h>\n#include \"sumas.h\"\n\nint main(int argc, char* argv[]) {\n    int a, b;\n    scanf(\"%d %d\\n\", &a, &b);\n    printf(\"%d\\n\", sumas(a, b));\n}\n\n$ cat sumas.py\ndef sumas(a, b):\n    print 'Hola, mundo!'\n    return a + b\n\n$ cat sumas.idl\ninterface Main {\n};\n\ninterface sumas {\n    int sumas(int a, int b);\n};\n\n$ java -jar libinteractive.jar generate sumas.idl cpp py --makefile\n$ make run < input\n[Main] 3\n[ sum] Hola, mundo!\n\nMemory:   5.023 MB\nTime:     0.011 s  Tambi\u00e9n puedes agregar la bandera  --verbose  a libinteractive para imprimir\nmensajes de depuraci\u00f3n cada vez que se realiza una llamada entre los procesos.",
            "title": "libinteractive"
        },
        {
            "location": "/#descarga",
            "text": "Puedes descargar el .jar m\u00e1s reciente de la  p\u00e1gina de descargas .",
            "title": "Descarga"
        },
        {
            "location": "/writing/",
            "text": "C\u00f3mo escribir problemas\n\n\nPrimero debes escribir un archivo .idl con la descripci\u00f3n de las interfaces\n(funciones definidas en el programa del juez y concursante). Tambi\u00e9n debes\nescribir un programa (de preferencia en C/C++, por eficiencia) que lea el caso\nde entrada est\u00e1ndar, invoque las funciones que el concursante debe implementar\ny finalmente escriba en salida est\u00e1ndar ya sea la salida del programa o el\npuntaje final que el concursante obtuvo en ese caso (si se utiliza el validador\n\nliteral\n en omegaUp). Finalmente, es necesario correr libinteractive para que\ngenere todos los archivos necesarios para poder probar la soluci\u00f3n, de esta manera:\n\n\njava -jar libinteractive.jar generate <archivo.idl> <lenguaje del juez> <lenguaje de la soluci\u00f3n> --makefile\n\n\n\nDonde el lenguaje es uno de \nc\n, \ncpp\n, \npas\n, \npy\n, \njava\n. \npas\n\nno est\u00e1 soportado como lenguaje para el programa del juez, solo\ndel concursante.\n\n\nPara usuarios de Windows, es necesario agregar la bandera \n--windows\n para que\npuedas compilar correctamente desde Code::Blocks.\n\n\nEs necesario crear un directorio llamado \nexamples\n (en min\u00fasculas) y colocar\nun caso de ejemplo llamado \nsample.in\n en ese directorio. De ser necesario, es\nposible colocar m\u00e1s casos de ejemplo en ese directorio y se copiar\u00e1n\nautom\u00e1ticamente a las plantillas para que los concursantes puedan descargarlas.\n\n\nPor \u00faltimo, hay que implementar la soluci\u00f3n y correr \nmake test\n para verificar\nque todo funciona. De ser necesario generar una implementaci\u00f3n alternativa del\nprograma del juez que se pueda distribuir a los concursantes (por si el\nprograma del juez contiene la soluci\u00f3n o pistas que divulgan c\u00f3mo llegar a la\nsoluci\u00f3n), se puede agregar un segundo archivo con \n.distrib\n antes de la\nextensi\u00f3n. Por ejemplo, si el programa del juez est\u00e1 en el archivo \nMain.cpp\n,\nel programa p\u00fablico del juez se puede colocar en el archivo \nMain.distrib.cpp\n\ny \u00fanicamente este se distribuir\u00eda en las plantillas a los concursantes.\n\n\nUna vez que se est\u00e1 contento con el problema, se debe convertir a formato\nomegaUp para subirlo. Para hacerlo, deben existir las siguientes carpetas:\n\n\n\n\ncases\n, con los casos oficiales. Las entradas deben estar en archivos con\n  extensi\u00f3n \n.in\n y las salidas en archivos con el mismo nombre pero\n  terminaci\u00f3n \n.out\n.\n\n\nstatements\n con las redacciones. Las redacciones se deben escribir en formato\n  Markdown, y debe haber una por lenguaje. Por ejemplo, para un problema en\n  ingl\u00e9s y espa\u00f1ol, deben existir dos archivos: \nes.markdown\n y \nen.markdown\n.\n  Para incluir el control para descargar las plantillas, los archivos \n.markdown\n\n  deben contener la cadena \n{{libinteractive:download}}\n en un rengl\u00f3n, sin texto\n  extra.\n\n\ninteractive\n con el problema interactivo. Aqu\u00ed solo debe estar el archivo .idl,\n  el programa del juez (\nMain.cpp\n) y la carpeta \nexamples\n con \nsample.in\n y\n  cualquier otro caso de entrada necesario. Opcionalmente puede estar el\n  archivo \nMain.distrib.cpp\n si \nMain.cpp\n tiene parte de la soluci\u00f3n. No se debe\n  incluir el Makefile, la soluci\u00f3n de prueba o la carpeta libinteractive.\n\n\n\n\nPor \u00faltimo, esas tres carpetas deben guardarse en un archivo .zip sin carpetas\nintermedias. Las plantillas que se distribuir\u00e1n a los concursantes se generar\u00e1n\nde manera autom\u00e1tica.\n\n\nConvenciones\n\n\n\n\nLa primer interfaz en el .idl (el programa del juez) debe llamarse \nMain\n. El\n  programa del juez, entonces, debe estar en un archivo llamado \nMain.cpp\n (o\n  la extensi\u00f3n que utilice el lenguaje de programaci\u00f3n en el que se escribe).\n\n\nEl programa del concursante debe estar en un archivo con el mismo nombre que\n  el archivo .idl, pero con la extensi\u00f3n apropiada para ese lenguaje de\n  programaci\u00f3n. Por ejemplo, para el problema \nsumas\n, la soluci\u00f3n del\n  concursante en \nsumas.cpp\n.\n\n\nCada interfaz producir\u00e1 un ejecutable distinto, y se correr\u00e1n en procesos\n  separados. Eso quiere decir que ninguna variable se puede compartir, as\u00ed que\n  es necesario pasarlas como par\u00e1metros a funciones.\n\n\nTodas las interfaces se pueden comunicar con Main, y Main se puede comunicar\n  con todas las dem\u00e1s interfaces, pero dos interfaces del concursante no se\n  pueden comunicar entre s\u00ed.\n\n\nLos arreglos como tipos de par\u00e1metros de funci\u00f3n son permitidos, pero sus\n  dimensiones deben obedecer las reglas de los arreglos en C: todas las\n  dimensiones (excepto la primera) deben ser constantes enteras.\n\n\nLos arreglos pueden declarar su primera dimensi\u00f3n como una variable, pero\n  esta variable debe aparecer como par\u00e1metro en la misma funci\u00f3n, y debe\n  aparecer antes en la lista de par\u00e1metros.\n\n\nLos par\u00e1metros que sean utilizados como dimensiones de arreglos deben\n  declarar el atributo \nRange\n, con los valores m\u00ednimo y m\u00e1ximo que puede\n  tomar ese par\u00e1metro. Esto se utiliza para saber de antemano qu\u00e9 tan grande\n  puede ser la memoria que es necesario alojar para que quepa el arreglo\n  entero.\n\n\nSi experas que una funci\u00f3n pueda terminar el proceso leg\u00edtimamente (porque es\n  la funci\u00f3n que se debe llamar para reportar la respuesta correcta, o porque\n  es una funci\u00f3n del evaluador que puede terminar porque el concursante realiz\u00f3\n  una operaci\u00f3n inv\u00e1lida), la funci\u00f3n debe tener el atributo \nNoReturn\n para\n  evitar que el otro proceso se confunda cuando deje de recibir informaci\u00f3n a\n  media llamada.\n\n\nSi est\u00e1s utilizando el m\u00f3dulo de kernel \ntransact\n para hacer llamadas IPC\n  r\u00e1pidas, puedes agregar el atributo \nShmSize\n a las interfaces para\n  establecer expl\u00edcitamente el tama\u00f1o de la regi\u00f3n de memoria compartida si\n  necesitas un valor distinto del valor por defecto (64k).\n\n\n\n\nEjemplos de archivos .idl\n\n\nLas jarras de agua\n\n\ninterface Main {\n void verterAgua(int fuente, int destino);\n};\n\ninterface jarras {\n    void programa(int objetivo, int capacidadJarra1, int capacidadJarra2);\n};\n\n\n\nFactories\n\n\ninterface Main {\n};\n\ninterface factories {\n    void Init([Range(2, 500000)] int N, int[N] A, int[N] B, int[N] D);\n    long Query([Range(1, 499999)] int S, int[S] X, [Range(1, 499999)] int T, int[T] Y);\n};\n\n\n\nParrots\n\n\ninterface Main {\n    void send([Range(0, 65535)] int n);\n    void output([Range(0, 255)] int n);\n};\n\ninterface encoder {\n    void encode([Range(0, 64)] int N, int[N] M);\n};\n\ninterface decoder {\n    void decode([Range(0, 64)] int N, [Range(0, 320)] int L, int[L] X);\n};\n\n\n\nCave\n\n\ninterface Main {\n    [NoReturn] int tryCombination([Range(0, 5000)] int N, int[N] S);\n    [NoReturn] void answer([Range(0, 5000)] int N, int[N] S, int[N] D);\n};\n\ninterface cave {\n    void exploreCave(int N);\n};\n\n\n\nGram\u00e1tica IDL\n\n\nIDL es casi un subconjunto de WebIDL, pero con un poco de sintaxis extra para\nconcursos de programaci\u00f3n:\n\n\nletter\n    = \"a\" | \"b\" | ... | \"y\" | \"z\"\n    | \"A\" | \"B\" | ... | \"Y\" | \"Z\"\n    ;\n\ndigit\n    = \"0\" | \"1\" | ... | \"8\" | \"9\"\n    ;\n\nident\n    = (letter | \"_\"), { letter | digit | \"_\" }\n    ;\n\nnumber\n    = digit, { digit }\n    ;\n\ninterface-list\n    = interface, { interface }\n    ;\n\ninterface\n    = { interface-attribute }, \"interface\", ident, \"{\", { function }, \"}\", \";\"\n    ;\n\nfunction\n    = { function-attribute }, return-type, ident,\n      \"(\", param-list , \")\", \";\"\n    ;\n\nparam-list\n    = [ param, { \",\", param } ]\n    ;\n\ntype\n    = array | primitive\n    ;\n\nprimitive\n    = \"bool\" | \"int\" | \"short\" | \"float\"\n    | \"char\" | \"string\" | \"long\"\n    ;\n\narray\n    = primitive, \"[\", expr, \"]\", { \"[\", expr, \"]\" }\n    ;\n\nreturn-type\n    = primitive | \"void\"\n    ;\n\nexpr\n    = ident | number\n    ;\n\nparam\n    = { param-attribute }, type, ident\n    ;\n\ninterface-attribute\n    = \"[\", shmsize-attribute, \"]\"\n    ;\n\nshmsize-attribute\n    = \"ShmSize\", \"(\", number, \")\"\n    ;\n\nfunction-attribute\n    = \"[\", noreturn-attribute, \"]\"\n    ;\n\nnoreturn-attribute\n    = \"NoReturn\"\n    ;\n\nparam-attribute\n    = \"[\", range-attribute, \"]\"\n    ;\n\nrange-attribute\n    = \"Range\", \"(\", expression, \",\", expression, \")\"\n    ;",
            "title": "Escribiendo problemas"
        },
        {
            "location": "/writing/#como-escribir-problemas",
            "text": "Primero debes escribir un archivo .idl con la descripci\u00f3n de las interfaces\n(funciones definidas en el programa del juez y concursante). Tambi\u00e9n debes\nescribir un programa (de preferencia en C/C++, por eficiencia) que lea el caso\nde entrada est\u00e1ndar, invoque las funciones que el concursante debe implementar\ny finalmente escriba en salida est\u00e1ndar ya sea la salida del programa o el\npuntaje final que el concursante obtuvo en ese caso (si se utiliza el validador literal  en omegaUp). Finalmente, es necesario correr libinteractive para que\ngenere todos los archivos necesarios para poder probar la soluci\u00f3n, de esta manera:  java -jar libinteractive.jar generate <archivo.idl> <lenguaje del juez> <lenguaje de la soluci\u00f3n> --makefile  Donde el lenguaje es uno de  c ,  cpp ,  pas ,  py ,  java .  pas \nno est\u00e1 soportado como lenguaje para el programa del juez, solo\ndel concursante.  Para usuarios de Windows, es necesario agregar la bandera  --windows  para que\npuedas compilar correctamente desde Code::Blocks.  Es necesario crear un directorio llamado  examples  (en min\u00fasculas) y colocar\nun caso de ejemplo llamado  sample.in  en ese directorio. De ser necesario, es\nposible colocar m\u00e1s casos de ejemplo en ese directorio y se copiar\u00e1n\nautom\u00e1ticamente a las plantillas para que los concursantes puedan descargarlas.  Por \u00faltimo, hay que implementar la soluci\u00f3n y correr  make test  para verificar\nque todo funciona. De ser necesario generar una implementaci\u00f3n alternativa del\nprograma del juez que se pueda distribuir a los concursantes (por si el\nprograma del juez contiene la soluci\u00f3n o pistas que divulgan c\u00f3mo llegar a la\nsoluci\u00f3n), se puede agregar un segundo archivo con  .distrib  antes de la\nextensi\u00f3n. Por ejemplo, si el programa del juez est\u00e1 en el archivo  Main.cpp ,\nel programa p\u00fablico del juez se puede colocar en el archivo  Main.distrib.cpp \ny \u00fanicamente este se distribuir\u00eda en las plantillas a los concursantes.  Una vez que se est\u00e1 contento con el problema, se debe convertir a formato\nomegaUp para subirlo. Para hacerlo, deben existir las siguientes carpetas:   cases , con los casos oficiales. Las entradas deben estar en archivos con\n  extensi\u00f3n  .in  y las salidas en archivos con el mismo nombre pero\n  terminaci\u00f3n  .out .  statements  con las redacciones. Las redacciones se deben escribir en formato\n  Markdown, y debe haber una por lenguaje. Por ejemplo, para un problema en\n  ingl\u00e9s y espa\u00f1ol, deben existir dos archivos:  es.markdown  y  en.markdown .\n  Para incluir el control para descargar las plantillas, los archivos  .markdown \n  deben contener la cadena  {{libinteractive:download}}  en un rengl\u00f3n, sin texto\n  extra.  interactive  con el problema interactivo. Aqu\u00ed solo debe estar el archivo .idl,\n  el programa del juez ( Main.cpp ) y la carpeta  examples  con  sample.in  y\n  cualquier otro caso de entrada necesario. Opcionalmente puede estar el\n  archivo  Main.distrib.cpp  si  Main.cpp  tiene parte de la soluci\u00f3n. No se debe\n  incluir el Makefile, la soluci\u00f3n de prueba o la carpeta libinteractive.   Por \u00faltimo, esas tres carpetas deben guardarse en un archivo .zip sin carpetas\nintermedias. Las plantillas que se distribuir\u00e1n a los concursantes se generar\u00e1n\nde manera autom\u00e1tica.",
            "title": "C\u00f3mo escribir problemas"
        },
        {
            "location": "/writing/#convenciones",
            "text": "La primer interfaz en el .idl (el programa del juez) debe llamarse  Main . El\n  programa del juez, entonces, debe estar en un archivo llamado  Main.cpp  (o\n  la extensi\u00f3n que utilice el lenguaje de programaci\u00f3n en el que se escribe).  El programa del concursante debe estar en un archivo con el mismo nombre que\n  el archivo .idl, pero con la extensi\u00f3n apropiada para ese lenguaje de\n  programaci\u00f3n. Por ejemplo, para el problema  sumas , la soluci\u00f3n del\n  concursante en  sumas.cpp .  Cada interfaz producir\u00e1 un ejecutable distinto, y se correr\u00e1n en procesos\n  separados. Eso quiere decir que ninguna variable se puede compartir, as\u00ed que\n  es necesario pasarlas como par\u00e1metros a funciones.  Todas las interfaces se pueden comunicar con Main, y Main se puede comunicar\n  con todas las dem\u00e1s interfaces, pero dos interfaces del concursante no se\n  pueden comunicar entre s\u00ed.  Los arreglos como tipos de par\u00e1metros de funci\u00f3n son permitidos, pero sus\n  dimensiones deben obedecer las reglas de los arreglos en C: todas las\n  dimensiones (excepto la primera) deben ser constantes enteras.  Los arreglos pueden declarar su primera dimensi\u00f3n como una variable, pero\n  esta variable debe aparecer como par\u00e1metro en la misma funci\u00f3n, y debe\n  aparecer antes en la lista de par\u00e1metros.  Los par\u00e1metros que sean utilizados como dimensiones de arreglos deben\n  declarar el atributo  Range , con los valores m\u00ednimo y m\u00e1ximo que puede\n  tomar ese par\u00e1metro. Esto se utiliza para saber de antemano qu\u00e9 tan grande\n  puede ser la memoria que es necesario alojar para que quepa el arreglo\n  entero.  Si experas que una funci\u00f3n pueda terminar el proceso leg\u00edtimamente (porque es\n  la funci\u00f3n que se debe llamar para reportar la respuesta correcta, o porque\n  es una funci\u00f3n del evaluador que puede terminar porque el concursante realiz\u00f3\n  una operaci\u00f3n inv\u00e1lida), la funci\u00f3n debe tener el atributo  NoReturn  para\n  evitar que el otro proceso se confunda cuando deje de recibir informaci\u00f3n a\n  media llamada.  Si est\u00e1s utilizando el m\u00f3dulo de kernel  transact  para hacer llamadas IPC\n  r\u00e1pidas, puedes agregar el atributo  ShmSize  a las interfaces para\n  establecer expl\u00edcitamente el tama\u00f1o de la regi\u00f3n de memoria compartida si\n  necesitas un valor distinto del valor por defecto (64k).",
            "title": "Convenciones"
        },
        {
            "location": "/writing/#ejemplos-de-archivos-idl",
            "text": "Las jarras de agua  interface Main {\n void verterAgua(int fuente, int destino);\n};\n\ninterface jarras {\n    void programa(int objetivo, int capacidadJarra1, int capacidadJarra2);\n};  Factories  interface Main {\n};\n\ninterface factories {\n    void Init([Range(2, 500000)] int N, int[N] A, int[N] B, int[N] D);\n    long Query([Range(1, 499999)] int S, int[S] X, [Range(1, 499999)] int T, int[T] Y);\n};  Parrots  interface Main {\n    void send([Range(0, 65535)] int n);\n    void output([Range(0, 255)] int n);\n};\n\ninterface encoder {\n    void encode([Range(0, 64)] int N, int[N] M);\n};\n\ninterface decoder {\n    void decode([Range(0, 64)] int N, [Range(0, 320)] int L, int[L] X);\n};  Cave  interface Main {\n    [NoReturn] int tryCombination([Range(0, 5000)] int N, int[N] S);\n    [NoReturn] void answer([Range(0, 5000)] int N, int[N] S, int[N] D);\n};\n\ninterface cave {\n    void exploreCave(int N);\n};",
            "title": "Ejemplos de archivos .idl"
        },
        {
            "location": "/writing/#gramatica-idl",
            "text": "IDL es casi un subconjunto de WebIDL, pero con un poco de sintaxis extra para\nconcursos de programaci\u00f3n:  letter\n    = \"a\" | \"b\" | ... | \"y\" | \"z\"\n    | \"A\" | \"B\" | ... | \"Y\" | \"Z\"\n    ;\n\ndigit\n    = \"0\" | \"1\" | ... | \"8\" | \"9\"\n    ;\n\nident\n    = (letter | \"_\"), { letter | digit | \"_\" }\n    ;\n\nnumber\n    = digit, { digit }\n    ;\n\ninterface-list\n    = interface, { interface }\n    ;\n\ninterface\n    = { interface-attribute }, \"interface\", ident, \"{\", { function }, \"}\", \";\"\n    ;\n\nfunction\n    = { function-attribute }, return-type, ident,\n      \"(\", param-list , \")\", \";\"\n    ;\n\nparam-list\n    = [ param, { \",\", param } ]\n    ;\n\ntype\n    = array | primitive\n    ;\n\nprimitive\n    = \"bool\" | \"int\" | \"short\" | \"float\"\n    | \"char\" | \"string\" | \"long\"\n    ;\n\narray\n    = primitive, \"[\", expr, \"]\", { \"[\", expr, \"]\" }\n    ;\n\nreturn-type\n    = primitive | \"void\"\n    ;\n\nexpr\n    = ident | number\n    ;\n\nparam\n    = { param-attribute }, type, ident\n    ;\n\ninterface-attribute\n    = \"[\", shmsize-attribute, \"]\"\n    ;\n\nshmsize-attribute\n    = \"ShmSize\", \"(\", number, \")\"\n    ;\n\nfunction-attribute\n    = \"[\", noreturn-attribute, \"]\"\n    ;\n\nnoreturn-attribute\n    = \"NoReturn\"\n    ;\n\nparam-attribute\n    = \"[\", range-attribute, \"]\"\n    ;\n\nrange-attribute\n    = \"Range\", \"(\", expression, \",\", expression, \")\"\n    ;",
            "title": "Gram\u00e1tica IDL"
        },
        {
            "location": "/internals/",
            "text": "C\u00f3mo funciona\n\n\nlibinteractive lee un archivo .idl, que es una descripci\u00f3n textual de las\nfunciones implementadas por el programa del juez y del concursante que se\npueden invocar uno desde el otro. A partir de este archivo, se pueden generar\ntodas las reglas necesarias para compilar los archivos y permitir que ambos\nprogramas se comuniquen entre s\u00ed como si hubieran sido compilados en un solo\nprograma.\n\n\nUna ventaja de libinteractive es que separa los c\u00f3digos del concursante y el\njuez en procesos distintos, as\u00ed que ya no es necesario proteger la memoria\ny la entrada est\u00e1ndar para evitar trampas. Tambi\u00e9n es posible escribir ambas\nimplementaciones en lenguajes de programaci\u00f3n distintos. Eso quiere decir que\nt\u00fa como juez solo necesitas escribir una implementaci\u00f3n y libinteractive se\nencarga del resto.\n\n\nDetalles de implementaci\u00f3n\n\n\nAl leer el archivo .idl, libinteractive genera un Makefile (o un archivo .bat\nen Windows) y el c\u00f3digo necesario para que los programas del juez y del\nconcursante puedan invocar las funciones del otro sin problemas. Las funciones\nque genera libinteractive serializan y deserializan los par\u00e1metros de la\nfunci\u00f3n, emite un mensaje dirigido al otro proceso, y espera la respuesta (si\nes que la funci\u00f3n regresa algo) para regresarla como resultado de la funci\u00f3n.\n\n\nlibinteractive utiliza \ntuber\u00edas nombradas\n\n(named pipes) para lograr la comunicaci\u00f3n entre procesos y la sincronizaci\u00f3n.\nLos mensajes se componen de un identificador de funci\u00f3n (autogenerado para cada\nuna de las funciones), los par\u00e1metros de la funci\u00f3n serializados, seguido de un\ncookie de verificaci\u00f3n que se debe regresar tal cual para validar que el\nmensaje fue transmitido correctamente. El formato binario espec\u00edfico que se\nutiliza se muestra a continuaci\u00f3n:\n\n\nmessage = function-id *field cookie\nfunction-id = int ; un entero de 32-bits que identifica la funci\u00f3n a llamar\ncookie = int ; un entero de 32-bits que se utiliza como sentinela\nfield = byte | short | int | float | long | double | array\nbyte = UNSIGNED_CHAR\nshort = SHORT\nint = INT\nfloat = INT ; IEEE-754 binary32\ndouble = LONG ; IEEE-754 binary64\nlong = LONG\narray = *byte ; tantos bytes como sea necesario para representar el arreglo\n\n\n\nTodos los enteros utilizan la codificaci\u00f3n little-endian (la nativa en x86),\npor lo que la implementaci\u00f3n en C simplemente necesita invocar la llamada de\nsistema \nwrite\n con un apuntador al par\u00e1metro a escribir con\n\nsizeof(parametro)\n como longitud.\n\n\nTodos los arreglos en el .idl deben ser arreglos v\u00e1lidos en C. Esto es, todas\nlas dimensiones del arreglo, excepto quiz\u00e1s la primera, deben ser constantes\nnum\u00e9ricas en tiempo de compilaci\u00f3n. La primer dimensi\u00f3n puede ser variable, en\ncuyo caso debe pasarse como uno de los par\u00e1metros de tipo \nint\n a la funci\u00f3n.\n\n\nComo el orden y el tipo de los par\u00e1metros est\u00e1 determinado en el .idl (y por\nende, en tiempo de compilaci\u00f3n), no es necesario escribir en el mensaje la\nlongitud del mismo, ya que el decodificador est\u00e1 generado de tal manera que\nsolo leer\u00e1 la cantidad correcta de bytes de la tuber\u00eda.\n\n\nFinalmente, libinteractive tambi\u00e9n genera un Makefile/.bat para que los\nconcursantes puedan compilar el c\u00f3digo sin preocuparse de los detalles, y\nprobar sus implementaciones con casos de ejemplo prove\u00eddos por el juez.\nUno de los archivos que compila el Makefile es un peque\u00f1o programa llamado\n\nrun\n, que genera los archivos necesarios para establecer las tuber\u00edas, ejecuta\nlos programas, redirige la entrada est\u00e1ndar al programa del juez (si es\nnecesario), y finalmente imprime la salida/error est\u00e1ndar de todos los\nprogramas de manera ordenada para poder identificar de qu\u00e9 proceso viene.\nPor \u00faltimo, al terminar todos los programas, imprime un resumen con la\ncantidad de memoria residente m\u00e1xima utilizada y el tiempo total consumido\npor el c\u00f3digo del concursante (user time).\n\n\nDesempe\u00f1o\n\n\nAl no compilar directamente ambos programas del juez y concursante en un mismo\nproceso, lo que antes era una llamada de funci\u00f3n (0-10 ciclos de CPU si la\nsoluci\u00f3n est\u00e1 escrita en C, depende de si es posible realizar \ninlining\n de la\nfunci\u00f3n o no) ahora requiere realizar dos llamadas de sistema y dos cambios de\nproceso que agrega 7-10 microsegundos al tiempo total de ejecuci\u00f3n (wall time),\ny alrededor de 2-3 microsegundos al tiempo de ejecuci\u00f3n del concursante (user\ntime). Eso quiere decir que si un problema requiere hacer m\u00e1s de ~400,000\nllamadas a funci\u00f3n entre los programas del juez y concursante, los programas\ngenerados por libinteractive van a ocasionar que los env\u00edos excedan los tiempos\nl\u00edmite.\n\n\nLa mayor\u00eda de este tiempo extra es causada por el hecho que hay que copiar\ndatos a buffers compartidos fuera del proceso, y no es posible mejorarlo sin\ncambiar el modelo de programaci\u00f3n, pero eso romper\u00eda el requerimiento de que\ndebe ser posible enlazar ambos subprogramas en un mismo proceso si est\u00e1n\nescritos en el mismo lenguaje, y har\u00eda todo m\u00e1s complicado para los\nconcursantes. El resto del tiempo extra es causado por el sistema operativo al\nmomento de hacer llamadas de sistema y los cambios de proceso, as\u00ed que no hay\nmucho que se pueda hacer al respecto. Experimentos con m\u00e9todos alternativos de\nhacer llamadas entre proceso (memoria compartida + sem\u00e1foros para indicar\ndisponibilidad) demostraron que el tiempo total para evaluar un env\u00edo podr\u00eda\nmejorar en menos del 5%, a cambio de aumentar el tiempo del concursante por\nhasta un 50%.\n\n\nSi el problema no requiere un gran volumen de llamadas, libinteractive es una\nexcelente opci\u00f3n para hacer problemas interactivos.\n\n\nEscenarios soportados\n\n\nOtros escenarios que son bastante eficientes hacerlos bajo libinteractive son:\n\n\n\n\nPasar arreglos gigantes de millones de elementos entre el programa del juez y\n  concursante es bastante m\u00e1s eficiente que leerlo de entrada est\u00e1ndar (solo\n  una llamada de sistema si los datos caben en un buffer de 4096 bytes), as\u00ed\n  que eso disminuir\u00e1 el tiempo del concursante.\n\n\nTener problemas de varias fases (como Parrots en la IOI 2011) era bastante\n  complicado antes pero es un escenario considerado en libinteractive.\n\n\nAutogenerar la entrada del concursante. Por ejemplo, una t\u00e9cnica utilizada\n  com\u00fanmente en el Facebook Hacker Cup es pedirle al concursante que genere la\n  entrada utilizando un \ngenerador de n\u00fameros aleatorios con congruencia linear\n.\n  Esto evita desperdiciar tiempo leyendo archivos gigantes de entrada est\u00e1ndar.\n\n\nAl ser separados los procesos, no es necesario esconder/obfuscar la memoria.\n  Esto permite que el programa del juez a su vez sea el validador y regrese la\n  calificaci\u00f3n.",
            "title": "Detalles de implementaci\u00f3n"
        },
        {
            "location": "/internals/#como-funciona",
            "text": "libinteractive lee un archivo .idl, que es una descripci\u00f3n textual de las\nfunciones implementadas por el programa del juez y del concursante que se\npueden invocar uno desde el otro. A partir de este archivo, se pueden generar\ntodas las reglas necesarias para compilar los archivos y permitir que ambos\nprogramas se comuniquen entre s\u00ed como si hubieran sido compilados en un solo\nprograma.  Una ventaja de libinteractive es que separa los c\u00f3digos del concursante y el\njuez en procesos distintos, as\u00ed que ya no es necesario proteger la memoria\ny la entrada est\u00e1ndar para evitar trampas. Tambi\u00e9n es posible escribir ambas\nimplementaciones en lenguajes de programaci\u00f3n distintos. Eso quiere decir que\nt\u00fa como juez solo necesitas escribir una implementaci\u00f3n y libinteractive se\nencarga del resto.",
            "title": "C\u00f3mo funciona"
        },
        {
            "location": "/internals/#detalles-de-implementacion",
            "text": "Al leer el archivo .idl, libinteractive genera un Makefile (o un archivo .bat\nen Windows) y el c\u00f3digo necesario para que los programas del juez y del\nconcursante puedan invocar las funciones del otro sin problemas. Las funciones\nque genera libinteractive serializan y deserializan los par\u00e1metros de la\nfunci\u00f3n, emite un mensaje dirigido al otro proceso, y espera la respuesta (si\nes que la funci\u00f3n regresa algo) para regresarla como resultado de la funci\u00f3n.  libinteractive utiliza  tuber\u00edas nombradas \n(named pipes) para lograr la comunicaci\u00f3n entre procesos y la sincronizaci\u00f3n.\nLos mensajes se componen de un identificador de funci\u00f3n (autogenerado para cada\nuna de las funciones), los par\u00e1metros de la funci\u00f3n serializados, seguido de un\ncookie de verificaci\u00f3n que se debe regresar tal cual para validar que el\nmensaje fue transmitido correctamente. El formato binario espec\u00edfico que se\nutiliza se muestra a continuaci\u00f3n:  message = function-id *field cookie\nfunction-id = int ; un entero de 32-bits que identifica la funci\u00f3n a llamar\ncookie = int ; un entero de 32-bits que se utiliza como sentinela\nfield = byte | short | int | float | long | double | array\nbyte = UNSIGNED_CHAR\nshort = SHORT\nint = INT\nfloat = INT ; IEEE-754 binary32\ndouble = LONG ; IEEE-754 binary64\nlong = LONG\narray = *byte ; tantos bytes como sea necesario para representar el arreglo  Todos los enteros utilizan la codificaci\u00f3n little-endian (la nativa en x86),\npor lo que la implementaci\u00f3n en C simplemente necesita invocar la llamada de\nsistema  write  con un apuntador al par\u00e1metro a escribir con sizeof(parametro)  como longitud.  Todos los arreglos en el .idl deben ser arreglos v\u00e1lidos en C. Esto es, todas\nlas dimensiones del arreglo, excepto quiz\u00e1s la primera, deben ser constantes\nnum\u00e9ricas en tiempo de compilaci\u00f3n. La primer dimensi\u00f3n puede ser variable, en\ncuyo caso debe pasarse como uno de los par\u00e1metros de tipo  int  a la funci\u00f3n.  Como el orden y el tipo de los par\u00e1metros est\u00e1 determinado en el .idl (y por\nende, en tiempo de compilaci\u00f3n), no es necesario escribir en el mensaje la\nlongitud del mismo, ya que el decodificador est\u00e1 generado de tal manera que\nsolo leer\u00e1 la cantidad correcta de bytes de la tuber\u00eda.  Finalmente, libinteractive tambi\u00e9n genera un Makefile/.bat para que los\nconcursantes puedan compilar el c\u00f3digo sin preocuparse de los detalles, y\nprobar sus implementaciones con casos de ejemplo prove\u00eddos por el juez.\nUno de los archivos que compila el Makefile es un peque\u00f1o programa llamado run , que genera los archivos necesarios para establecer las tuber\u00edas, ejecuta\nlos programas, redirige la entrada est\u00e1ndar al programa del juez (si es\nnecesario), y finalmente imprime la salida/error est\u00e1ndar de todos los\nprogramas de manera ordenada para poder identificar de qu\u00e9 proceso viene.\nPor \u00faltimo, al terminar todos los programas, imprime un resumen con la\ncantidad de memoria residente m\u00e1xima utilizada y el tiempo total consumido\npor el c\u00f3digo del concursante (user time).",
            "title": "Detalles de implementaci\u00f3n"
        },
        {
            "location": "/internals/#desempeno",
            "text": "Al no compilar directamente ambos programas del juez y concursante en un mismo\nproceso, lo que antes era una llamada de funci\u00f3n (0-10 ciclos de CPU si la\nsoluci\u00f3n est\u00e1 escrita en C, depende de si es posible realizar  inlining  de la\nfunci\u00f3n o no) ahora requiere realizar dos llamadas de sistema y dos cambios de\nproceso que agrega 7-10 microsegundos al tiempo total de ejecuci\u00f3n (wall time),\ny alrededor de 2-3 microsegundos al tiempo de ejecuci\u00f3n del concursante (user\ntime). Eso quiere decir que si un problema requiere hacer m\u00e1s de ~400,000\nllamadas a funci\u00f3n entre los programas del juez y concursante, los programas\ngenerados por libinteractive van a ocasionar que los env\u00edos excedan los tiempos\nl\u00edmite.  La mayor\u00eda de este tiempo extra es causada por el hecho que hay que copiar\ndatos a buffers compartidos fuera del proceso, y no es posible mejorarlo sin\ncambiar el modelo de programaci\u00f3n, pero eso romper\u00eda el requerimiento de que\ndebe ser posible enlazar ambos subprogramas en un mismo proceso si est\u00e1n\nescritos en el mismo lenguaje, y har\u00eda todo m\u00e1s complicado para los\nconcursantes. El resto del tiempo extra es causado por el sistema operativo al\nmomento de hacer llamadas de sistema y los cambios de proceso, as\u00ed que no hay\nmucho que se pueda hacer al respecto. Experimentos con m\u00e9todos alternativos de\nhacer llamadas entre proceso (memoria compartida + sem\u00e1foros para indicar\ndisponibilidad) demostraron que el tiempo total para evaluar un env\u00edo podr\u00eda\nmejorar en menos del 5%, a cambio de aumentar el tiempo del concursante por\nhasta un 50%.  Si el problema no requiere un gran volumen de llamadas, libinteractive es una\nexcelente opci\u00f3n para hacer problemas interactivos.",
            "title": "Desempe\u00f1o"
        },
        {
            "location": "/internals/#escenarios-soportados",
            "text": "Otros escenarios que son bastante eficientes hacerlos bajo libinteractive son:   Pasar arreglos gigantes de millones de elementos entre el programa del juez y\n  concursante es bastante m\u00e1s eficiente que leerlo de entrada est\u00e1ndar (solo\n  una llamada de sistema si los datos caben en un buffer de 4096 bytes), as\u00ed\n  que eso disminuir\u00e1 el tiempo del concursante.  Tener problemas de varias fases (como Parrots en la IOI 2011) era bastante\n  complicado antes pero es un escenario considerado en libinteractive.  Autogenerar la entrada del concursante. Por ejemplo, una t\u00e9cnica utilizada\n  com\u00fanmente en el Facebook Hacker Cup es pedirle al concursante que genere la\n  entrada utilizando un  generador de n\u00fameros aleatorios con congruencia linear .\n  Esto evita desperdiciar tiempo leyendo archivos gigantes de entrada est\u00e1ndar.  Al ser separados los procesos, no es necesario esconder/obfuscar la memoria.\n  Esto permite que el programa del juez a su vez sea el validador y regrese la\n  calificaci\u00f3n.",
            "title": "Escenarios soportados"
        },
        {
            "location": "/contest/",
            "text": "Ejecutar programas de libinteractive\n\n\nlibinteractive es una manera sencilla de hacer problemas interactivos. El\nproceso para compilar, ejecutar y probar los programas es ligeramente distinto\nal que est\u00e1s acostumbrado, pero es sencillo. Los pasos espec\u00edficos dependen del\nsistema operativo que est\u00e9s usando.\n\n\nPrimero, elige tu sistema operativo y el lenguaje a utilizar usando\nla herramienta que se encuentra en la descripci\u00f3n del problema. Despu\u00e9s,\nsigue los pasos seg\u00fan tu sistema operativo:\n\n\nWindows\n\n\n\n\nExtrae todos los archivos a una carpeta, abre la consola y dir\u00edgete a la\n  carpeta donde extrajiste los archivos.\n\n\nDebes tener instalado \nCode::Blocks\n\n  (aseg\u00farate de bajar la versi\u00f3n que dice MinGW) y haberlo ejecutado al menos\n  una vez.\n\n\nSi quieres usar C o C++, simplemente abre el archivo de proyecto de Code::Blocks\n  que viene incluido en la carpeta que acabas de extraer. Puedes ignorar el resto\n  de los pasos. Para intentar otros casos de prueba, modifica el archivo \nsample.in\n que\n  se encuentra en el proyecto.\n\n\nSi quieres usar Java, debes tener instalado el\n  \nJDK\n.\n\n\nSi quieres usar Pascal, debes tener instalado\n  \nLazarus\n y\n  haberlo ejecutado al menos una vez.\n\n\nSi quieres usar Python, debes tener instalado \nPython 2.7\n\n\n\n\n\n\nEscribe \nrun\n (o \nrun.bat\n) para compilar todos los programas que necesitas y\n  posteriormente ejecutar tu c\u00f3digo. Recuerda que el validador espera una\n  entrada en la consola, as\u00ed que debes ya sea escribirla o pas\u00e1rsela como\n  archivo (\nrun < entrada.in\n).\n\n\nPara probar tu soluci\u00f3n con un caso de prueba, escribe \ntest\n (o \ntest.bat\n).\n  Esto es equivalente a correr \nrun.bat < examples\\sample.in\n.\n\n\n\n\nLinux/Mac OS X\n\n\n\n\nExtrae todos los archivos a una carpeta y abre la terminal y dir\u00edgete a la\n  carpeta donde extrajiste los archivos.\n\n\nSe recomienda que tengas instalados los siguientes paquetes: \nmake\n, \ngcc\n,\n  \ng++\n, \nfpc\n, \npython\n y \nopenjdk-7-jdk\n.\n\n\nEscribe \nmake\n para compilar todos los programas que necesitas y \nmake run\n\n  para ejecutar tu c\u00f3digo. Recuerda que el validador espera una entrada en la\n  consola, as\u00ed que debes ya sea escribirla o pas\u00e1rsela como archivo (\nmake run\n  < entrada.in\n).\n\n\nPara probar tu soluci\u00f3n con un caso de prueba, escribe \nmake test\n. Esto es\n  equivalente a correr \nmake run < examples/sample.in\n.\n\n\n\n\nNotas generales\n\n\n\n\nPara resolver el problema, debes enviar \u00fanicamente el archivo que te indica\n  la p\u00e1gina. No env\u00edes ning\u00fan otro archivo o resultar\u00e1 en un error de\n  compilaci\u00f3n.\n\n\nAlgunos problemas tendr\u00e1n m\u00e1s casos de ejemplo en la carpeta \nexamples\n adem\u00e1s\n  de \nsample.in\n. Intenta hacer que tu c\u00f3digo pase con todos esos casos. Puedes\n  probarlo corriendo ya sea \nrun < examples/archivo.in\n o \nmake run < examples/archivo.in\n,\n  depende de tu sistema operativo.\n\n\nPara obtener todos los puntos de un problema, tu programa debe poder resolver\n  todos los casos posibles. Intenta pensar en casos de ejemplo adicionales a\n  los que se encuentren en la plantilla, corre tu c\u00f3digo con ellos y verifica\n  que de el resultado correcto. Mucha suerte!",
            "title": "Concursantes"
        },
        {
            "location": "/contest/#ejecutar-programas-de-libinteractive",
            "text": "libinteractive es una manera sencilla de hacer problemas interactivos. El\nproceso para compilar, ejecutar y probar los programas es ligeramente distinto\nal que est\u00e1s acostumbrado, pero es sencillo. Los pasos espec\u00edficos dependen del\nsistema operativo que est\u00e9s usando.  Primero, elige tu sistema operativo y el lenguaje a utilizar usando\nla herramienta que se encuentra en la descripci\u00f3n del problema. Despu\u00e9s,\nsigue los pasos seg\u00fan tu sistema operativo:  Windows   Extrae todos los archivos a una carpeta, abre la consola y dir\u00edgete a la\n  carpeta donde extrajiste los archivos.  Debes tener instalado  Code::Blocks \n  (aseg\u00farate de bajar la versi\u00f3n que dice MinGW) y haberlo ejecutado al menos\n  una vez.  Si quieres usar C o C++, simplemente abre el archivo de proyecto de Code::Blocks\n  que viene incluido en la carpeta que acabas de extraer. Puedes ignorar el resto\n  de los pasos. Para intentar otros casos de prueba, modifica el archivo  sample.in  que\n  se encuentra en el proyecto.  Si quieres usar Java, debes tener instalado el\n   JDK .  Si quieres usar Pascal, debes tener instalado\n   Lazarus  y\n  haberlo ejecutado al menos una vez.  Si quieres usar Python, debes tener instalado  Python 2.7    Escribe  run  (o  run.bat ) para compilar todos los programas que necesitas y\n  posteriormente ejecutar tu c\u00f3digo. Recuerda que el validador espera una\n  entrada en la consola, as\u00ed que debes ya sea escribirla o pas\u00e1rsela como\n  archivo ( run < entrada.in ).  Para probar tu soluci\u00f3n con un caso de prueba, escribe  test  (o  test.bat ).\n  Esto es equivalente a correr  run.bat < examples\\sample.in .   Linux/Mac OS X   Extrae todos los archivos a una carpeta y abre la terminal y dir\u00edgete a la\n  carpeta donde extrajiste los archivos.  Se recomienda que tengas instalados los siguientes paquetes:  make ,  gcc ,\n   g++ ,  fpc ,  python  y  openjdk-7-jdk .  Escribe  make  para compilar todos los programas que necesitas y  make run \n  para ejecutar tu c\u00f3digo. Recuerda que el validador espera una entrada en la\n  consola, as\u00ed que debes ya sea escribirla o pas\u00e1rsela como archivo ( make run\n  < entrada.in ).  Para probar tu soluci\u00f3n con un caso de prueba, escribe  make test . Esto es\n  equivalente a correr  make run < examples/sample.in .",
            "title": "Ejecutar programas de libinteractive"
        },
        {
            "location": "/contest/#notas-generales",
            "text": "Para resolver el problema, debes enviar \u00fanicamente el archivo que te indica\n  la p\u00e1gina. No env\u00edes ning\u00fan otro archivo o resultar\u00e1 en un error de\n  compilaci\u00f3n.  Algunos problemas tendr\u00e1n m\u00e1s casos de ejemplo en la carpeta  examples  adem\u00e1s\n  de  sample.in . Intenta hacer que tu c\u00f3digo pase con todos esos casos. Puedes\n  probarlo corriendo ya sea  run < examples/archivo.in  o  make run < examples/archivo.in ,\n  depende de tu sistema operativo.  Para obtener todos los puntos de un problema, tu programa debe poder resolver\n  todos los casos posibles. Intenta pensar en casos de ejemplo adicionales a\n  los que se encuentren en la plantilla, corre tu c\u00f3digo con ellos y verifica\n  que de el resultado correcto. Mucha suerte!",
            "title": "Notas generales"
        },
        {
            "location": "/license/",
            "text": "Copyright (c) 2014, The omegaUp Contributors\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n\nNeither the name of the omegaUp nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "title": "Licencia"
        }
    ]
}