{
    "docs": [
        {
            "location": "/",
            "text": "libinteractive\n\n\nA tiny IDL translator that creates IPC shims to easily create interactive\nproblems.\n\n\nTo avoid having to write a program in each of the supported languages and\nmaking sure that none of them has bugs or undefined behavior that might\ncause the wrong output/veredict to be emitted, libinteractive allows you\nto have both the problemsetter and contestants' implementations in different\nprocesses and possibly languages.\n\n\nExample\n\n\nLet's say you have a problem called \nsums\n. You, as problemsetter, implement\nyour part of the problem in a file called \nMain.cpp\n and the contestants writes\ntheir solution in a file called \nsums.py\n, so you can do:\n\n\n$ ls\nMain.cpp sums.py sums.idl input\n\n$ cat Main.cpp\n#include <stdio.h>\n#include \"sums.h\"\n\nint main(int argc, char* argv[]) {\n    int a, b;\n    scanf(\"%d %d\\n\", &a, &b);\n    printf(\"%d\\n\", sums(a, b));\n}\n\n$ cat sums.py\ndef sums(a, b):\n    print 'Hello, world!'\n    return a + b\n\n$ cat sums.idl\ninterface Main {\n};\n\ninterface sums {\n    int sums(int a, int b);\n};\n\n$ java -jar libinteractive.jar generate sums.idl cpp py --makefile\n$ make run < input\n[Main] 3\n[ sum] Hello, world!\n\nMemory:   5.023 MB\nTime:     0.011 s\n\n\n\n\nYou can also add a --verbose flag to libinteractive to print a message every\ntime an IPC call is made.\n\n\nDownload\n\n\nYou can grab the latest \n.jar\n from the \nReleases page",
            "title": "Index"
        },
        {
            "location": "/#libinteractive",
            "text": "A tiny IDL translator that creates IPC shims to easily create interactive\nproblems.  To avoid having to write a program in each of the supported languages and\nmaking sure that none of them has bugs or undefined behavior that might\ncause the wrong output/veredict to be emitted, libinteractive allows you\nto have both the problemsetter and contestants' implementations in different\nprocesses and possibly languages.  Example  Let's say you have a problem called  sums . You, as problemsetter, implement\nyour part of the problem in a file called  Main.cpp  and the contestants writes\ntheir solution in a file called  sums.py , so you can do:  $ ls\nMain.cpp sums.py sums.idl input\n\n$ cat Main.cpp\n#include <stdio.h>\n#include \"sums.h\"\n\nint main(int argc, char* argv[]) {\n    int a, b;\n    scanf(\"%d %d\\n\", &a, &b);\n    printf(\"%d\\n\", sums(a, b));\n}\n\n$ cat sums.py\ndef sums(a, b):\n    print 'Hello, world!'\n    return a + b\n\n$ cat sums.idl\ninterface Main {\n};\n\ninterface sums {\n    int sums(int a, int b);\n};\n\n$ java -jar libinteractive.jar generate sums.idl cpp py --makefile\n$ make run < input\n[Main] 3\n[ sum] Hello, world!\n\nMemory:   5.023 MB\nTime:     0.011 s  You can also add a --verbose flag to libinteractive to print a message every\ntime an IPC call is made.",
            "title": "libinteractive"
        },
        {
            "location": "/#download",
            "text": "You can grab the latest  .jar  from the  Releases page",
            "title": "Download"
        },
        {
            "location": "/writing/",
            "text": "How to write problems\n\n\nFirst you need to write an .idl file with the description of the interfaces\n(functions defined in both the problemsetter and contestant code). You must\nalso write a program (if possible in C/C++, for bestperformance) that reads a\ncase from stdin, invokes the functions that the contestant must implement, and\nfinally write either the final output or a number between 0 and 1 (inclusive)\nthat represents the score of the test case to stdout (if you use the \nliteral\n\nvalidator in omegaUp). Once this is done, you need to run libinteractive to\ngenerate all necessary files to be able to test the solution, like so:\n\n\njava -jar libinteractive.jar generate <file.idl> <problemsetter language> <solution language> --makefile\n\n\n\nWhere the languages are one of \nc\n, \ncpp\n, \npas\n, \npy\n, \njava\n. \npas\n is not\nsupported as a problemsetter language, so it will fail if you try.\n\n\nFor Windows users, it's necessary to add the \n--windows\n flag so you it can\ncompile correctly from Code::Blocks.\n\n\nYou must also create a directory called \nexamples\n (in lowercase) and place a\nsample input in a file called \nsample.in\n in that directory. If needed, you can\nadd more test cases in that directory, and they will be automatically copied to\nthe templates that the contestants can download.\n\n\nFinally, the actual solution must be implemented. You can run \nmake test\n to\nverify that everything works correctly. If the problemsetter program contains a\nvalid solution to the problem or enough details can be leaked that would lead\nto a solution, you can write a second implementation that would only be\ndistributed to the contestants in the template files by adding a file with\n\n.distrib\n before the extension. For instance, if the problemsetter program is\nin \nMain.cpp\n, the second, public version can be placed in \nMain.distrib.cpp\n\nand it will be the one that will be copied into the templates.\n\n\nOnce you are happy with the problem, it must be converted to omegaUp format to\nupload it. To do so, the following folders must be present:\n\n\n\n\ncases\n, with the official cases. The inputs must be saved in files with the\n  \n.in\n extension, and the outputs in files with the same name but with \n.out\n\n  extension.\n\n\nstatements\n with the problem statements. The statements must be written in\n  Markdown and there must be one per language. For instance, for a problem that\n  will be in both english and spanish, there must be two files: \nes.markdown\n\n  and \nen.markdown\n. To include the control to download the libinteractive\n  templates, the \n.markdown\n files must include the string\n  \n{{libinteractive:download}}\n in a line of its own, with no extra text.\n\n\ninteractive\n with the interactive problem. This should \nonly\n contain the\n  .idl file, the problemsetter problem (\nMain.cpp\n), and the \nexamples\n folder\n  with \nsample.in\n and any other sample input. Optionally, the\n  \nMain.distrib.cpp\n file may be present if \nMain.cpp\n has implementation\n  details that should not be distributed. In particular, the Makefile, the\n  sample solution and the \nlibinteractive\n generated directory should not be\n  present in the .zip.\n\n\n\n\nThese three folders must be saved in a .zip file, without any intermediate\nfolders. The templates that will be distributed to the contestants will be\nautomatically generated.\n\n\nConventions\n\n\n\n\nThe first interface in the .idl file is the problemsetter program and\n  \nmust\n be called \nMain\n. The problemsetter program must then be placed in a\n  file called \nMain.cpp\n (probably with a different extension, depending of the\n  programming language it is written on).\n\n\nThe contestant's program(s) must be saved in a file with the same name as the\n  .idl file, but with the correct extension for the programming language it is\n  written on. For instance, for the problem \nsums.idl\n, the solution must be\n  placed in the file \nsums.cpp\n.\n\n\nEach interface will be compiled into a different executable, and will be run\n  in separate processes. This means that no variables may be shared, so it will\n  be necessary to communicate any state using functions.\n\n\nAll interfaces may call the functions in the Main interface, and Main may\n  call any function in any other interface. Other interfaces cannot call each\n  other's functions.\n\n\nArrays as parameter types are allowed, but their dimensions must obey the\n  rules for C arrays: all dimensions (except the first one) must be integer\n  constantes.\n\n\nArrays may declare its first dimension as a variable, but this variable\n  must be of type \nint\n, it must be passed as a parameter to the function, and\n  it must come before the array in the parameter list.\n\n\nThe parameters that are used as array dimensions must declare the \nRange\n\n  attribute, with the minimum and maximum values that the parameter might take.\n  This is used to know the maximum size in bytes that the message needs\n  allocated so that the arrays fit in them.\n\n\nIf you expect that a function might legitimately exit the process (because it\n  is the function that is called when the correct answer is reached, or because\n  it might detect an error on the contestant's data), the function must possess\n  the \nNoReturn\n attribute to avoid causing the other process to get confused\n  about exiting when it stops receiving information mid-call.\n\n\nIf you are using the \ntransact\n kernel module to speed up IPC calls, you can\n  add the ShmSize attribute to the interface to explicitly specify the size of\n  the shared memory region if you need a value different from the 64k default.\n\n\n\n\nSample .idl files\n\n\nLas jarras de agua\n\n\ninterface Main {\n void verterAgua(int fuente, int destino);\n};\n\ninterface jarras {\n    void programa(int objetivo, int capacidadJarra1, int capacidadJarra2);\n};\n\n\n\nFactories\n\n\ninterface Main {\n};\n\ninterface factories {\n    void Init([Range(2, 500000)] int N, int[N] A, int[N] B, int[N] D);\n    long Query([Range(1, 499999)] int S, int[S] X, [Range(1, 499999)] int T, int[T] Y);\n};\n\n\n\nParrots\n\n\ninterface Main {\n    void send([Range(0, 65535)] int n);\n    void output([Range(0, 255)] int n);\n};\n\ninterface encoder {\n    void encode([Range(0, 64)] int N, int[N] M);\n};\n\ninterface decoder {\n    void decode([Range(0, 64)] int N, [Range(0, 320)] int L, int[L] X);\n};\n\n\n\nCave\n\n\ninterface Main {\n    [NoReturn] int tryCombination([Range(0, 5000)] int N, int[N] S);\n    [NoReturn] void answer([Range(0, 5000)] int N, int[N] S, int[N] D);\n};\n\ninterface cave {\n    void exploreCave(int N);\n};\n\n\n\nIDL Grammar\n\n\nIDL is almost a subset of \nWebIDL\n,\nbut with some syntax to help programming contests.\n\n\nletter\n    = \"a\" | \"b\" | ... | \"y\" | \"z\"\n    | \"A\" | \"B\" | ... | \"Y\" | \"Z\"\n    ;\n\ndigit\n    = \"0\" | \"1\" | ... | \"8\" | \"9\"\n    ;\n\nident\n    = (letter | \"_\"), { letter | digit | \"_\" }\n    ;\n\nnumber\n    = digit, { digit }\n    ;\n\ninterface-list\n    = interface, { interface }\n    ;\n\ninterface\n    = { interface-attribute }, \"interface\", ident, \"{\", { function }, \"}\", \";\"\n    ;\n\nfunction\n    = { function-attribute }, return-type, ident,\n      \"(\", param-list , \")\", \";\"\n    ;\n\nparam-list\n    = [ param, { \",\", param } ]\n    ;\n\ntype\n    = array | primitive\n    ;\n\nprimitive\n    = \"bool\" | \"int\" | \"short\" | \"float\"\n    | \"char\" | \"string\" | \"long\"\n    ;\n\narray\n    = primitive, \"[\", expr, \"]\", { \"[\", expr, \"]\" }\n    ;\n\nreturn-type\n    = primitive | \"void\"\n    ;\n\nexpr\n    = ident | number\n    ;\n\nparam\n    = { param-attribute }, type, ident\n    ;\n\ninterface-attribute\n    = \"[\", shmsize-attribute, \"]\"\n    ;\n\nshmsize-attribute\n    = \"ShmSize\", \"(\", number, \")\"\n    ;\n\n\nfunction-attribute\n    = \"[\", noreturn-attribute, \"]\"\n    ;\n\nnoreturn-attribute\n    = \"NoReturn\"\n    ;\n\nparam-attribute\n    = \"[\", range-attribute, \"]\"\n    ;\n\nrange-attribute\n    = \"Range\", \"(\", expression, \",\", expression, \")\"\n    ;",
            "title": "Writing problems"
        },
        {
            "location": "/writing/#how-to-write-problems",
            "text": "First you need to write an .idl file with the description of the interfaces\n(functions defined in both the problemsetter and contestant code). You must\nalso write a program (if possible in C/C++, for bestperformance) that reads a\ncase from stdin, invokes the functions that the contestant must implement, and\nfinally write either the final output or a number between 0 and 1 (inclusive)\nthat represents the score of the test case to stdout (if you use the  literal \nvalidator in omegaUp). Once this is done, you need to run libinteractive to\ngenerate all necessary files to be able to test the solution, like so:  java -jar libinteractive.jar generate <file.idl> <problemsetter language> <solution language> --makefile  Where the languages are one of  c ,  cpp ,  pas ,  py ,  java .  pas  is not\nsupported as a problemsetter language, so it will fail if you try.  For Windows users, it's necessary to add the  --windows  flag so you it can\ncompile correctly from Code::Blocks.  You must also create a directory called  examples  (in lowercase) and place a\nsample input in a file called  sample.in  in that directory. If needed, you can\nadd more test cases in that directory, and they will be automatically copied to\nthe templates that the contestants can download.  Finally, the actual solution must be implemented. You can run  make test  to\nverify that everything works correctly. If the problemsetter program contains a\nvalid solution to the problem or enough details can be leaked that would lead\nto a solution, you can write a second implementation that would only be\ndistributed to the contestants in the template files by adding a file with .distrib  before the extension. For instance, if the problemsetter program is\nin  Main.cpp , the second, public version can be placed in  Main.distrib.cpp \nand it will be the one that will be copied into the templates.  Once you are happy with the problem, it must be converted to omegaUp format to\nupload it. To do so, the following folders must be present:   cases , with the official cases. The inputs must be saved in files with the\n   .in  extension, and the outputs in files with the same name but with  .out \n  extension.  statements  with the problem statements. The statements must be written in\n  Markdown and there must be one per language. For instance, for a problem that\n  will be in both english and spanish, there must be two files:  es.markdown \n  and  en.markdown . To include the control to download the libinteractive\n  templates, the  .markdown  files must include the string\n   {{libinteractive:download}}  in a line of its own, with no extra text.  interactive  with the interactive problem. This should  only  contain the\n  .idl file, the problemsetter problem ( Main.cpp ), and the  examples  folder\n  with  sample.in  and any other sample input. Optionally, the\n   Main.distrib.cpp  file may be present if  Main.cpp  has implementation\n  details that should not be distributed. In particular, the Makefile, the\n  sample solution and the  libinteractive  generated directory should not be\n  present in the .zip.   These three folders must be saved in a .zip file, without any intermediate\nfolders. The templates that will be distributed to the contestants will be\nautomatically generated.",
            "title": "How to write problems"
        },
        {
            "location": "/writing/#conventions",
            "text": "The first interface in the .idl file is the problemsetter program and\n   must  be called  Main . The problemsetter program must then be placed in a\n  file called  Main.cpp  (probably with a different extension, depending of the\n  programming language it is written on).  The contestant's program(s) must be saved in a file with the same name as the\n  .idl file, but with the correct extension for the programming language it is\n  written on. For instance, for the problem  sums.idl , the solution must be\n  placed in the file  sums.cpp .  Each interface will be compiled into a different executable, and will be run\n  in separate processes. This means that no variables may be shared, so it will\n  be necessary to communicate any state using functions.  All interfaces may call the functions in the Main interface, and Main may\n  call any function in any other interface. Other interfaces cannot call each\n  other's functions.  Arrays as parameter types are allowed, but their dimensions must obey the\n  rules for C arrays: all dimensions (except the first one) must be integer\n  constantes.  Arrays may declare its first dimension as a variable, but this variable\n  must be of type  int , it must be passed as a parameter to the function, and\n  it must come before the array in the parameter list.  The parameters that are used as array dimensions must declare the  Range \n  attribute, with the minimum and maximum values that the parameter might take.\n  This is used to know the maximum size in bytes that the message needs\n  allocated so that the arrays fit in them.  If you expect that a function might legitimately exit the process (because it\n  is the function that is called when the correct answer is reached, or because\n  it might detect an error on the contestant's data), the function must possess\n  the  NoReturn  attribute to avoid causing the other process to get confused\n  about exiting when it stops receiving information mid-call.  If you are using the  transact  kernel module to speed up IPC calls, you can\n  add the ShmSize attribute to the interface to explicitly specify the size of\n  the shared memory region if you need a value different from the 64k default.",
            "title": "Conventions"
        },
        {
            "location": "/writing/#sample-idl-files",
            "text": "Las jarras de agua  interface Main {\n void verterAgua(int fuente, int destino);\n};\n\ninterface jarras {\n    void programa(int objetivo, int capacidadJarra1, int capacidadJarra2);\n};  Factories  interface Main {\n};\n\ninterface factories {\n    void Init([Range(2, 500000)] int N, int[N] A, int[N] B, int[N] D);\n    long Query([Range(1, 499999)] int S, int[S] X, [Range(1, 499999)] int T, int[T] Y);\n};  Parrots  interface Main {\n    void send([Range(0, 65535)] int n);\n    void output([Range(0, 255)] int n);\n};\n\ninterface encoder {\n    void encode([Range(0, 64)] int N, int[N] M);\n};\n\ninterface decoder {\n    void decode([Range(0, 64)] int N, [Range(0, 320)] int L, int[L] X);\n};  Cave  interface Main {\n    [NoReturn] int tryCombination([Range(0, 5000)] int N, int[N] S);\n    [NoReturn] void answer([Range(0, 5000)] int N, int[N] S, int[N] D);\n};\n\ninterface cave {\n    void exploreCave(int N);\n};",
            "title": "Sample .idl files"
        },
        {
            "location": "/writing/#idl-grammar",
            "text": "IDL is almost a subset of  WebIDL ,\nbut with some syntax to help programming contests.  letter\n    = \"a\" | \"b\" | ... | \"y\" | \"z\"\n    | \"A\" | \"B\" | ... | \"Y\" | \"Z\"\n    ;\n\ndigit\n    = \"0\" | \"1\" | ... | \"8\" | \"9\"\n    ;\n\nident\n    = (letter | \"_\"), { letter | digit | \"_\" }\n    ;\n\nnumber\n    = digit, { digit }\n    ;\n\ninterface-list\n    = interface, { interface }\n    ;\n\ninterface\n    = { interface-attribute }, \"interface\", ident, \"{\", { function }, \"}\", \";\"\n    ;\n\nfunction\n    = { function-attribute }, return-type, ident,\n      \"(\", param-list , \")\", \";\"\n    ;\n\nparam-list\n    = [ param, { \",\", param } ]\n    ;\n\ntype\n    = array | primitive\n    ;\n\nprimitive\n    = \"bool\" | \"int\" | \"short\" | \"float\"\n    | \"char\" | \"string\" | \"long\"\n    ;\n\narray\n    = primitive, \"[\", expr, \"]\", { \"[\", expr, \"]\" }\n    ;\n\nreturn-type\n    = primitive | \"void\"\n    ;\n\nexpr\n    = ident | number\n    ;\n\nparam\n    = { param-attribute }, type, ident\n    ;\n\ninterface-attribute\n    = \"[\", shmsize-attribute, \"]\"\n    ;\n\nshmsize-attribute\n    = \"ShmSize\", \"(\", number, \")\"\n    ;\n\n\nfunction-attribute\n    = \"[\", noreturn-attribute, \"]\"\n    ;\n\nnoreturn-attribute\n    = \"NoReturn\"\n    ;\n\nparam-attribute\n    = \"[\", range-attribute, \"]\"\n    ;\n\nrange-attribute\n    = \"Range\", \"(\", expression, \",\", expression, \")\"\n    ;",
            "title": "IDL Grammar"
        },
        {
            "location": "/internals/",
            "text": "How it works\n\n\nlibinteractive reads an .idl file, which is a textual description of the\nfunctions implemented by the problemsetter's and contestants' programs that can\nbe called from each other's code. From that file, all compilation rules\nand adapters can be generated so that both programs can be compiled and\ncommunicate with each other as if they were both written in the same language\nand compiled as a single program.\n\n\nAn advantage of libinteractive is that the problemsetter's and contestants'\nprograms run in different processes (and potentially in different sandbox\nenvironments), so it is not necessary to protect the memory or the standard\ninput to avoid cheating. It is also possible to write both implementations in\ndifferent programming languages. This means that the problemsetter only needs\nto write one implementation and libinteractive handles the heavy lifting.\n\n\nImplementation details\n\n\nAfter reading the .idl file, libinteractive generates a Makefile (or a .bat\nfile for Windows) and all the needed code for the problemsetter's and\ncontestants' code to be able to invoke each other's functions. The\nautogenerated function shims serialize and deserialize the function parameters,\nsend a message to the appropriate process and blocks until a reply message\nis received, at which point it deserializes the return value (if any) and\nreturns it itself. This makes calling a function totally transparent from\nthe point of view of both coders.\n\n\nlibinteractive uses \nnamed pipes\n\nto achieve inter-process communication and synchronization. The messages sent\nthrough the pipes consist of a function identifier (autogenerated for each\nfunction in the .idl), the serialized function parameters, and a validation\ncookie that must be returned as-is to validate that the message was sent and\nprocessed correctly. The binary format used is as follows:\n\n\nmessage = function-id *field cookie\nfunction-id = int ; a random 32-bits integer that identifies the called function\ncookie = int ; a random 32-bits integer used as sentinel\nfield = byte | short | int | float | long | double | array\nbyte = UNSIGNED_CHAR\nshort = SHORT\nint = INT\nfloat = INT ; IEEE-754 binary32\ndouble = LONG ; IEEE-754 binary64\nlong = LONG\narray = *byte ; as many bytes as needed. explained below\n\n\n\nAll integers use the little-endian encoding (the native in x86 architectures),\nso the C implementation simply needs to invoke the \nwrite\n system call with a\npointer to the parameter using \nsizeof(parameter)\n as the length.\n\n\nAll arrays in the .idl file must comply with the C rules for array sizes. This\nmeans that all array dimensions (except maybe the first) must be integer\nconstants. The first dimension may be a variable, but it needs to be passed in\nas an \nint\n parameter to the function.\n\n\nSince the order and type of the parameters is determined by the .idl file (so\nit is known at compile time), it is not necessary to write the message length\nin the message, because the decoder is generated in a way that it will only\nread the required number of bytes from the pipe.\n\n\nFinally, libinteractive will also generate a Makefile/.bat so that contestants\ncan compile all the code without worrying about details, in order to test their\nimplementations with sample input files provided by the problemsetter. One of\nthe programs built by the Makefile is a tiny C program called \nrun\n, which\ngenerates the named pipes, runs the programs, redirects stdin to the\nproblemsetter's program (if needed), and finally prints all program's\nstdout/stderr with a tag to identify from which process it came from. Finally,\nonce all programs exit, it prints a summary of the memory used (maximum\nresident size) and the total time used by the contestant's code (user time).\n\n\nPerformance\n\n\nSince the problemsetter and contestants' code are not compiled together in a\nsingle binary, what was once a simple function call (0-10 CPU cycles of\noverhead in C, depending if it was possible to perform inlining of the function\nor not) now requires at least two system calls and two process switches, which\nadds 7-10 microseconds to the total execution time (wall time) and around 2-3\nmicroseconds to the contestant time (user time). This means that if a problem\nrequires more than ~400,000 function calls between processes, programs\ngenerated by libinteractive will most likely exceed time limits.\n\n\nPart of this overhead is copying data between buffers and is not possible to\nremove without changing the programming model and thus breaking compatibility\nwith standalone linked programs for easy experimentation. The rest of the\noverhead is caused by the operating system when making system calls and\nswitching processes, so there is not much we can do. Experimentation showed\nthat even when using alternative ways of performing IPC (shared memory +\nsemaphores to indicate readiness), overall runtime improved by less than 5%,\nand user time increased by up to 50%.\n\n\nIf the program does not require a large volume of function calls,\nlibinteractive is an excellent option to write your interactive problems.\n\n\nSupported scenarios\n\n\nSome of the scenarios that will work great with libinteractive are:\n\n\n\n\nPassing giant arrays with millions of elements between the problemsetter and\n  the contestants' code. The serialized binary format is much more efficient to\n  read (just one system call if the data fits on a 4096-byte buffer) than\n  reading them from standard input (which requires parsing the numbers), so\n  this will reduce contestant time significantly.\n\n\nProblems with several phases (like Parrots in IOI 2011) was almost impossible\n  to support before and is now a supported scenario.\n\n\nAutogenerating the contestant's input. For instance, a technique used\n  commonly in Facebook Hacker Cup is to ask the contestant to generate their\n  own input using a \nlinear congruential generator\n\n  to avoid having to read a multi-megabyte input file.\n\n\nSince the processes run in different sandbox, it is now not needed to\n  hide/obfuscate the program memory. This allows the problemsetter program to\n  also fulfill the role of the validator, so it can write the final score\n  obtained by the contestant.",
            "title": "Implementation details"
        },
        {
            "location": "/internals/#how-it-works",
            "text": "libinteractive reads an .idl file, which is a textual description of the\nfunctions implemented by the problemsetter's and contestants' programs that can\nbe called from each other's code. From that file, all compilation rules\nand adapters can be generated so that both programs can be compiled and\ncommunicate with each other as if they were both written in the same language\nand compiled as a single program.  An advantage of libinteractive is that the problemsetter's and contestants'\nprograms run in different processes (and potentially in different sandbox\nenvironments), so it is not necessary to protect the memory or the standard\ninput to avoid cheating. It is also possible to write both implementations in\ndifferent programming languages. This means that the problemsetter only needs\nto write one implementation and libinteractive handles the heavy lifting.",
            "title": "How it works"
        },
        {
            "location": "/internals/#implementation-details",
            "text": "After reading the .idl file, libinteractive generates a Makefile (or a .bat\nfile for Windows) and all the needed code for the problemsetter's and\ncontestants' code to be able to invoke each other's functions. The\nautogenerated function shims serialize and deserialize the function parameters,\nsend a message to the appropriate process and blocks until a reply message\nis received, at which point it deserializes the return value (if any) and\nreturns it itself. This makes calling a function totally transparent from\nthe point of view of both coders.  libinteractive uses  named pipes \nto achieve inter-process communication and synchronization. The messages sent\nthrough the pipes consist of a function identifier (autogenerated for each\nfunction in the .idl), the serialized function parameters, and a validation\ncookie that must be returned as-is to validate that the message was sent and\nprocessed correctly. The binary format used is as follows:  message = function-id *field cookie\nfunction-id = int ; a random 32-bits integer that identifies the called function\ncookie = int ; a random 32-bits integer used as sentinel\nfield = byte | short | int | float | long | double | array\nbyte = UNSIGNED_CHAR\nshort = SHORT\nint = INT\nfloat = INT ; IEEE-754 binary32\ndouble = LONG ; IEEE-754 binary64\nlong = LONG\narray = *byte ; as many bytes as needed. explained below  All integers use the little-endian encoding (the native in x86 architectures),\nso the C implementation simply needs to invoke the  write  system call with a\npointer to the parameter using  sizeof(parameter)  as the length.  All arrays in the .idl file must comply with the C rules for array sizes. This\nmeans that all array dimensions (except maybe the first) must be integer\nconstants. The first dimension may be a variable, but it needs to be passed in\nas an  int  parameter to the function.  Since the order and type of the parameters is determined by the .idl file (so\nit is known at compile time), it is not necessary to write the message length\nin the message, because the decoder is generated in a way that it will only\nread the required number of bytes from the pipe.  Finally, libinteractive will also generate a Makefile/.bat so that contestants\ncan compile all the code without worrying about details, in order to test their\nimplementations with sample input files provided by the problemsetter. One of\nthe programs built by the Makefile is a tiny C program called  run , which\ngenerates the named pipes, runs the programs, redirects stdin to the\nproblemsetter's program (if needed), and finally prints all program's\nstdout/stderr with a tag to identify from which process it came from. Finally,\nonce all programs exit, it prints a summary of the memory used (maximum\nresident size) and the total time used by the contestant's code (user time).",
            "title": "Implementation details"
        },
        {
            "location": "/internals/#performance",
            "text": "Since the problemsetter and contestants' code are not compiled together in a\nsingle binary, what was once a simple function call (0-10 CPU cycles of\noverhead in C, depending if it was possible to perform inlining of the function\nor not) now requires at least two system calls and two process switches, which\nadds 7-10 microseconds to the total execution time (wall time) and around 2-3\nmicroseconds to the contestant time (user time). This means that if a problem\nrequires more than ~400,000 function calls between processes, programs\ngenerated by libinteractive will most likely exceed time limits.  Part of this overhead is copying data between buffers and is not possible to\nremove without changing the programming model and thus breaking compatibility\nwith standalone linked programs for easy experimentation. The rest of the\noverhead is caused by the operating system when making system calls and\nswitching processes, so there is not much we can do. Experimentation showed\nthat even when using alternative ways of performing IPC (shared memory +\nsemaphores to indicate readiness), overall runtime improved by less than 5%,\nand user time increased by up to 50%.  If the program does not require a large volume of function calls,\nlibinteractive is an excellent option to write your interactive problems.",
            "title": "Performance"
        },
        {
            "location": "/internals/#supported-scenarios",
            "text": "Some of the scenarios that will work great with libinteractive are:   Passing giant arrays with millions of elements between the problemsetter and\n  the contestants' code. The serialized binary format is much more efficient to\n  read (just one system call if the data fits on a 4096-byte buffer) than\n  reading them from standard input (which requires parsing the numbers), so\n  this will reduce contestant time significantly.  Problems with several phases (like Parrots in IOI 2011) was almost impossible\n  to support before and is now a supported scenario.  Autogenerating the contestant's input. For instance, a technique used\n  commonly in Facebook Hacker Cup is to ask the contestant to generate their\n  own input using a  linear congruential generator \n  to avoid having to read a multi-megabyte input file.  Since the processes run in different sandbox, it is now not needed to\n  hide/obfuscate the program memory. This allows the problemsetter program to\n  also fulfill the role of the validator, so it can write the final score\n  obtained by the contestant.",
            "title": "Supported scenarios"
        },
        {
            "location": "/contest/",
            "text": "Running libinteractive problems\n\n\nlibinteractive is an easy way to write interactive problems. The process to\ncompile, run, and test programs is slightly different to the one you are used\nto, but it is simple. The specific steps depend on the operating system you are\nusing.\n\n\nFirst, choose your operating system and the language you will be using with the\ndropdown that is shown in the problem statement. Then, follow the steps that\ncorrespond to the operating system you are using:\n\n\nWindows\n\n\n\n\nExtract all files in the template into a folder. Open the Commandline\n  (Windows+R, type \ncmd\n and press Return), and navigate to the folder you just\n  created.\n\n\nYou must have previously installed \nCode::Blocks\n\n  (make sure to install the version that says MinGW) and run it at least once.\n\n\nIf you want to use C or C++, simply open the Code::Blocks project file\n  that is included in the folder you just extracted. You can ignore the\n  rest of the steps. To try other test cases, try modifying the \nsample.in\n\n  file that is included in the project.\n\n\nIf you are using Java, you must install the\n  \nJDK\n.\n\n\nIf you want to use Pascal, you need to install\n  \nLazarus\n and\n  have launched it at least once.\n\n\nIf you want to use Python, you need to install\n  \nPython 2.7\n.\n\n\n\n\n\n\nTo compile all required programs, type \nrun\n (or \nrun.bat\n). This will also\n  run your code. Remember that the problemsetter program expects to read the\n  case from stdin, so you either need to type it on the commandline or redirect\n  stdin (\nrun < input.in\n).\n\n\nTo test your solution with a test case, write \ntest\n (or \ntest.bat\n). This is\n  equivalent to running \nrun.bat < examples\\sample.in\n.\n\n\n\n\nLinux/Mac OS X\n\n\n\n\nExtract all template files to a directory, open the terminal and navigate to\n  the recently created directory.\n\n\nIt is recommended that you have the following packages installed: \nmake\n,\n  \ngcc\n, \ng++\n, \nfpc\n, \npython\n y \nopenjdk-7-jdk\n.\n\n\nWrite \nmake\n to compile all needed programs and \nmake run\n to execute your\n  code. Rembember that the problemsetter program expects to read a test case\n  from stdin, so either type it on the terminal or redirect stdin (\nmake run\n  < input.in\n).\n\n\nTo test your solution against a test case, write \nmake test\n. This is\n  equivalent to running \nmake run < examples/sample.in\n.\n\n\n\n\nGeneral notes\n\n\n\n\nTo correctly solve the problem, you must only submit the file that the\n  website tells you. Don't send any other file or it will result in a\n  compilation error.\n\n\nSome problems will have extra test inputs beside \nsample.in\n. Try to make\n  your code run correctly with all those cases. You can try them out by running\n  either \nrun < examples/file.in\n or \nmake run < examples/file.in\n, depending\n  on your operating system.\n\n\nTo get all possible points in a problem, your program must solve all possible\n  test cases, even some not included in the \nexamples\n folder. Try to think of\n  additional test cases, run your code with them and verify that the result is\n  correct. Good luck!",
            "title": "Contestants"
        },
        {
            "location": "/contest/#running-libinteractive-problems",
            "text": "libinteractive is an easy way to write interactive problems. The process to\ncompile, run, and test programs is slightly different to the one you are used\nto, but it is simple. The specific steps depend on the operating system you are\nusing.  First, choose your operating system and the language you will be using with the\ndropdown that is shown in the problem statement. Then, follow the steps that\ncorrespond to the operating system you are using:  Windows   Extract all files in the template into a folder. Open the Commandline\n  (Windows+R, type  cmd  and press Return), and navigate to the folder you just\n  created.  You must have previously installed  Code::Blocks \n  (make sure to install the version that says MinGW) and run it at least once.  If you want to use C or C++, simply open the Code::Blocks project file\n  that is included in the folder you just extracted. You can ignore the\n  rest of the steps. To try other test cases, try modifying the  sample.in \n  file that is included in the project.  If you are using Java, you must install the\n   JDK .  If you want to use Pascal, you need to install\n   Lazarus  and\n  have launched it at least once.  If you want to use Python, you need to install\n   Python 2.7 .    To compile all required programs, type  run  (or  run.bat ). This will also\n  run your code. Remember that the problemsetter program expects to read the\n  case from stdin, so you either need to type it on the commandline or redirect\n  stdin ( run < input.in ).  To test your solution with a test case, write  test  (or  test.bat ). This is\n  equivalent to running  run.bat < examples\\sample.in .   Linux/Mac OS X   Extract all template files to a directory, open the terminal and navigate to\n  the recently created directory.  It is recommended that you have the following packages installed:  make ,\n   gcc ,  g++ ,  fpc ,  python  y  openjdk-7-jdk .  Write  make  to compile all needed programs and  make run  to execute your\n  code. Rembember that the problemsetter program expects to read a test case\n  from stdin, so either type it on the terminal or redirect stdin ( make run\n  < input.in ).  To test your solution against a test case, write  make test . This is\n  equivalent to running  make run < examples/sample.in .",
            "title": "Running libinteractive problems"
        },
        {
            "location": "/contest/#general-notes",
            "text": "To correctly solve the problem, you must only submit the file that the\n  website tells you. Don't send any other file or it will result in a\n  compilation error.  Some problems will have extra test inputs beside  sample.in . Try to make\n  your code run correctly with all those cases. You can try them out by running\n  either  run < examples/file.in  or  make run < examples/file.in , depending\n  on your operating system.  To get all possible points in a problem, your program must solve all possible\n  test cases, even some not included in the  examples  folder. Try to think of\n  additional test cases, run your code with them and verify that the result is\n  correct. Good luck!",
            "title": "General notes"
        },
        {
            "location": "/license/",
            "text": "Copyright (c) 2014, The omegaUp Contributors\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n\nNeither the name of the omegaUp nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "title": "License"
        }
    ]
}