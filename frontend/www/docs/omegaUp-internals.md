Everything you wanted to know about omegaUp but were afraid to ask

## Frontend

When you make a submission, the first thing that happens is that the code, along with the contest alias, problem, and programming language, is sent using an HTTP POST request to the API endpoint `/api/run/create/`, through the `OmegaUp.submit` method in `frontend/www/js/omegaup.js`. Once it reaches the server, nginx forwards it to HHVM, which invokes `ApiCaller::httpEntryPoint()`. Just before that, the file `frontend/server/bootstrap.php` is loaded; it contains all the configuration, loads the necessary modules, and initializes the database connection, among other things. Then, an object called `Request` is created, which represents all the parameters of the request (such as the authentication cookie). The URL path is tokenized, the `/api` prefix is removed, and the array `['run', 'create']` is obtained. The first element corresponds to the controller name to be invoked (in this case, `RunController`), and the second element corresponds to the method name (`apiCreate`). Any remaining elements are treated as variable–value pairs and are added to the `Request`.

Once `RunController::apiCreate` is called, the authentication token set during login is validated (usually stored as a cookie, though the API can also accept it as a POST parameter). At this point, the system also retrieves the user ID of the requester. The next step is to validate that the user has permission to perform the submission: it verifies that all required elements are present (problem name, contest name, language, and code), that the problem belongs to the contest, and that both are valid. It also checks that the contest time limit has not expired, that the user isn’t exceeding the submission rate limit (one submission per problem every 60 seconds), and that the contest is either public or the user is explicitly listed as someone who can see the contest. When Lockdown mode is enabled, additional checks are performed (currently, it only ensures the submission isn’t made in practice mode). The system then calculates the penalty according to the contest’s policy (from the contest start time, from the first time the problem was opened, or no penalty at all), generates a random GUID, stores everything in the database, and saves the submitted code to a file with that GUID as its name in the filesystem. Finally, it sends an HTTP request to the Grader to process the submission (by ID) and returns the GUID as JSON to the browser.


## Grader, Part 1

The Grader has an embedded HTTPS server that listens for requests to evaluate submissions, register new Runners, unregister them, and broadcast information to all clients connected via WebSockets. The class `omegaup.grader.Manager` handles request dispatching based on the URL. To grade a submission, it calls `omegaup.grader.Manager.grade(req)` (where `req` is the deserialized JSON version used in the submission). It then looks up the submission ID in the database, rehydrates all necessary data about the submission, problem, contest, and user (thanks to `omegaup.grader.GraderData.hydrateRun`), and creates a `omegaup.grader.RunContext` object containing metadata and tracing information for performance monitoring. The submission is then sent to the queue router through `omegaup.grader.RunnerDispatcher.addRun`.

There are eight default queues: urgent, slow urgent, contest, slow contest, normal, slow normal, rejudge, and slow rejudge. By default, nothing goes into the urgent queues, but some contests (such as OMI or CONACUP) can be configured to always go there using the Grader’s configuration file (`omegaup.conf`). If the submission wasn’t made in practice mode, it goes into the contest queue; otherwise, it goes into normal. Rejudge is used only when the “rejudge” button is pressed on the frontend or when problem test cases change. The slow queues are for problems that, in the worst case, could take more than 30 seconds to return a TLE (Time Limit Exceeded). Queues are processed from left to right, but only a certain percentage of Runners can process slow queues simultaneously (currently 50%) to prevent them from being monopolized.

It is chosen which queue to send the submission to—either by explicit configuration (see `omegaup.grader.RoutingDescription` for syntax and behavior)—and it remains there until a Runner becomes available. Once there’s at least one ready submission to evaluate and one free Runner, `omegaup.grader.RunnerDispatcher.dispatchLocked` takes the highest-priority submission from all queues and a free Runner. It logs the dispatch time (to detect dead Runners) and calls `omegaup.grader.RunnerDispatcher.GradeTask.gradeTask` in a thread pool.

`gradeTask` invokes `omegaup.grader.drivers.OmegaUpDriver.run` to communicate directly with the Runners, with a 10-minute deadline. If this deadline is exceeded or an exception occurs during processing, the Runner is considered dead; if the error is not critical, the submission is re-queued wishing the failure was temporary.


## Runner

Runners are deployed in the cloud on virtual machines. Each time a Runner starts, it sends a registration request to the Grader, which adds it to the pool of available Runners. They are dispatched in a round-robin fashion (no affinity, though it existed in the past and could easily be restored). Every minute of inactivity, a Runner re-registers with the Grader to signal that it’s still alive, in case the Grader was restarted or connectivity was lost.

Each Runner also has an embedded HTTPS server, so `omegaup.grader.drivers.OmegaUpDriver.run` communicates with `omegaup.runner.Service` via JSON on HTTPS. Even though the Grader ensures through its queue that each Runner handles only one submission at a time, bad things can happen if a network issues occurs, so the Runner also uses a mutex to ensure single execution.

The process begins with `omegaup.runner.Runner.compile`, which uses calls to `omegaup.runner.Minijail` to encapsulate the logic for setting compiler flags and invoking `minijail`. Depending on which flags and fields were provided in the compile request, it can compile one or multiple files (for interactive problems). There is no explicit configuration for compilation; instead, it follows the convention that the main class is named `Main`, and the produced executable is also named `Main` (or `Main.class` in Java, or its equivalent in other languages). If the compilation request succeeds, the Runner returns a token (the path in the filesystem where temporary files are stored) to the Grader. This token must be used in future requests referring to the compiled program. If compilation fails, all temporary files are deleted, and the compiler’s stderr output is returned as a compilation error. If the problem has a validator, it is also included in this step and compiled as part of the same process.

To run a submission against a predefined input set, the Grader sends the compilation token along with the SHA-1 hash of the input cases in a `.zip` file as JSON to the Runner. The Runner checks whether the input set is cached in the file system; if not, it returns an error, prompting the Grader to send the `.zip` in another request. Once the input files are validated and available locally, the Runner executes the compiled program against each `.in` file. The execution message can also include standalone input cases as plain text, which are treated as if they were part of the `.zip` file. The message may also reference a validator if the problem defines one. For each case (whether from the `.zip` or inline), the Runner stores the `.out` file and its metadata, compresses them using bzip2, and sends them back to the Grader immediately.

If a validator exists, it is also run against the user’s `.out` and the original `.in`, and those results (`.out` and metadata) are sent to the Grader. stderr and other information are only sent when performing a debug-rejudge from the frontend.

After all cases are evaluated, temporary files are deleted, and the Runner proceeds to the next message.


## Grader, Part 2

Once all outputs for a submission are collected, the Runner is released back into the pool to handle other submissions. In parallel, the Grader invokes `omegaup.grader.Grader`, which contains the logic for all validator types. All validators tokenize the stream using spaces as delimiters. Some validators (such as token and token-caseless) compare tokens one by one and stop at the first difference, or when one stream ends while the other still produces tokens. Other validators (like token-numeric) ignore non-numeric tokens, interpret all numbers as floating-point values, and compare them with a tolerance threshold.

This produces a verdict for each case. Once all cases have verdicts, if the problem includes a `/testplan` file, it is parsed and normalized weights are assigned (their sum must equal 1). Otherwise, each case is weighted equally as 1 divided by the total number of cases.

With the weights determined, the cases are grouped: everything before the first `.` in the filename is treated as the group name (meaning if no explicit group is given, the portion before `.in` becomes the implicit group name). A group grants points only if all its cases have an AC or PA verdict. The total score is the sum of all group scores multiplied by the problem’s point value for that contest (or 100% in practice mode). The final verdict is stored in the database, and the `RunContext` is enqueued in the Broadcaster.


## Broadcaster

The Broadcaster is responsible for maintaining contest scoreboards and notifying contestants in near real-time to all participants who activated WebSockets mode. Each submission placed in the Broadcaster queue that belongs to a contest triggers a call to `/api/scoreboard/refresh` in the frontend, which updates the scoreboard according to the contest’s policies.

Once the scoreboard has been refreshed and cached on the server, the Broadcaster notifies all contest participants that the scoreboard has changed and the verdict author. At this point, the `RunContext` records timing data: how long the submission spent in each queue, how long the Runner took to respond, and additional debugging information, and then the `RunContext`gets destroyed.