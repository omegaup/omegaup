Todo lo que quisiste saber de omegaUp y te dio miedo preguntar

## Frontend
Cuando haces un envío, lo primero que ocurre es que el código, junto con el alias del concurso, el problema, y el lenguaje del código, se envían usando HTTP POST al endpoint del API `/api/run/create/`, mediante el método `OmegaUp.submit`, en `frontend/www/js/omegaup.js`. Una vez que llega al servidor, nginx lo redirige a HHVM que invoca `ApiCaller::httpEntryPoint()`. Justo antes de eso, se carga el archivo `frontend/server/bootstrap.php`, que contiene toda la configuración, carga los módulos necesarios, inicializa la conexión a la base de datos, etc. Después, se crea un objeto llamado `Request`, que contiene la representación de todos los parámetros de la petición (como la cookie de autenticación). Además, se tokeniza el path del url, se le quita el `/api`, y se obtiene el arreglo `['run', 'create']`. El primer elemento del arreglo es el nombre del controlador que se va a invocar (en este caso sería `RunController`), y el segundo parámetros sería el nombre del método (`apiCreate`). Todos los elementos posteriores se tratan como una serie de nombres de variable-valores, y se agregan al `Request`.

Una vez que se llama a `RunController::apiCreate`, se valida el token de autenticación que se estableció al hacer login (usualmente se guarda como un cookie, pero el API puede aceptar este token como parte de los parámetros enviados por POST). En este punto, también se obtiene el ID del usuario que hace la petición. Después, se valida que el usuario de verdad tenga permiso para realizar ese envío: se verifica que todos los elementos requeridos (nombre del problema y concurso, lenguaje y código), que el problema esté en el concurso y que ambos sean válidos, se verifica que el tiempo límite para dicho concurso no haya expirado, que el usuario no esté excediendo la tasa máxima de envíos (1 envío por problema cada 60 segundos) y por último que el concurso sea público o que el usuario haya sido explícitamente agregado a la lista de personas que pueden ver el concurso. Cuando se está en modo Lockdown, se hacen más verificaciones (por ahora solo se verifica que el envío no se haya realizado en modo de práctica). Se calcula el penalty de acuerdo a la política del concurso (desde el inicio del concurso, desde que se abre el problema por primera vez, o se omite el penalty por completo), se calcula un GUID aleatorio, se agrega todo a la base de datos y se guarda el código del envío en un archivo con ese mismo GUID en el filesystem. Finalmente, se envía una petición por HTTP al grader para que corra el envío (por ID), y se envía el GUID como JSON al navegador.

## Grader, parte 1
Grader tiene un servidor embebido HTTPS donde escucha peticiones de evaluar un envío, registrar un nuevo runner, darlo de baja, y de hacer broadcast de alguna información a todos los clientes que se hayan conectado usando WebSockets. La clase `omegaup.grader.Manager` es la que hace el despachamiento de las peticiones dependiendo del URL. Para calificar los envíos, se invoca `omegaup.grader.Manager.grade(req)` (donde `req` es la versión des-serializada del JSON que se usó para hacer el envío) donde se busca el ID del envío en la base de datos, se rehidrata toda la información necesaria del envío, problema, concurso y usuario (cortesía de `omegaup.grader.GraderData.hydrateRun`), se crea un `omegaup.grader.RunContext` que va a tener toda la metadata del envío, junto con información de tracing para poder medir performance, y finalmente se envía al enrutador de colas mediante `omegaup.grader.RunnerDispatcher.addRun`.

Hay 8 colas default: urgente, urgente lento, concurso, concurso lento, normal, normal lento, rejudge, rejudge lento. Por default, nada va a las colas urgentes, pero se puede configurar que ciertos concursos (como la OMI o el CONACUP) vayan siempre a la cola urgente, mediante el archivo de configuración del grader (`omegaup.conf`). Si el envío no se hizo en modo de práctica va a concurso, de otro modo irá a normal. Rejudge únicamente se utiliza si se utilizó el botón de "rejudge" en el frontend o se hizo un cambio en los casos de un problema. Por último, las colas lentas se llenan de problemas que, en el peor de los casos, tardarían más de 30s en regresar un TLE. Las colas se procesan de izquierda a derecha, pero solo un cierto porcentaje de runners pueden estar atendiendo colas lentas simultáneamente (actualmente es 50%) para evitar que las monopolicen.

Se elige a qué cola se va a mandar el envío, ya sea por configuración explícita (la sintaxis y los detalles de cómo operan están en `omegaup.grader.RoutingDescription`), y ahí esperará hasta que haya un runner libre. Una vez que hay al menos un envío listo para evaluarse y al menos un Runner libre, el método `omegaup.grader.RunnerDispatcher.dispatchLocked` saca el envío de más alta prioridad posible de todas las colas y un Runner disponible, se toma nota del tiempo en el que se sacaron de las colas (para detectar Runners muertos), y se manda llamar `omegaup.grader.RunnerDispatcher.GradeTask.gradeTask` en un threadpool. `gradeTask` invoca a `omegaup.grader.drivers.OmegaUpDriver.run` para comunicarse directamente con los Runners con un deadline de 10 minutos: si se excede o hay una excepción en el procesamiento, se considera muerto el Runner y si el error no fue grave, se vuelve a encolar el envío esperando que haya sido un error temporal.

## Runner
Los Runners están en la nube, en máquinas virtuales. Cada que uno se prende, envía una petición de registrarse al Grader, y lo agrega al pool de Runner disponibles, donde se despachan round-robin (no hay afinidad, pero había en algún punto en el tiempo y no sería complicado volverla a agregar). Después de cada minuto de inactividad, envía una nueva petición de registro al Grader para avisarle que sigue vivo por si hay alguna complicación o se reinició el Grader o lo que sea. Cada Runner también tiene un servidor HTTPS embebido, así que `omegaup.grader.drivers.OmegaUpDriver.run` se comunica con `omegaup.runner.Service` mediante JSON sobre HTTPS. A pesar que Grader tiene una cola para garantizar que cada Runner está siendo usado por a lo más un envío, cosas malas pueden pasar si hay problemas en la red, así que el Runner también tiene un mutex para asegurarse que solo hay un envío a la vez.

Todo el proceso empieza con `omegaup.runner.Runner.compile` que utiliza llamadas a `omegaup.runner.Minijail` para encapsular la lógica de pasarle las banderas adecuadas al compilador y a `minijail`. Depende de qué banderas y campos hayan llenado para hacer la petición de compilación, puede compilar uno o varios archivos (para el caso de los problemas interactivos). No hay una configuración explícita de cómo se deben compilar las cosas, así que se utiliza únicamente la convención de que la clase principal se llama `Main`, y el archivo ejecutable que se produce se llama `Main` (o `Main.class` en Java o su equivalente en otros lenguajes). Si esta petición fue exitosa, se le regresa al Grader un token (que es la ruta en el sistema de archivos donde se almacenan los archivos temporales), que se tiene que enviar en peticiones futuras para referirse al mismo archivo compilado. Si la compilación falló, se borran todos los archivos temporales y se regresa el stderr del compilador como error de compilación. Si el problema tiene un validador registrado, el validador también se envía en el mensaje y se compila en este paso.

Para correr un envío contra un input pre-establecido, el Grader envía el token de compilación junto con el hash SHA-1 de los casos de entrada en un .zip mediante un JSON al Runner. Se valida que el input esté cacheado en el sistema de archivos, y si no, se envía un error para que el Grader mande el .zip en otra petición. Una vez que se valida que el conjunto de archivos de entrada están en el sistema de archivos local, se corre el ejecutable con cada archivo `.in`. El mensaje de ejecutar además de casos pre-establecidos puede enviar casos standalone en la misma petición (como texto plano), y esos casos también se evaluarían como si hubieran venido en el .zip con todos los `.in`. El mensaje de ejecución también puede tener referencia a un validador (en caso que el problema tenga uno presente), Por cada caso (ya sea del .zip o del mensaje), se guardan el `.out` junto con la metadata, se comprimen usando bzip2 y se envían de vuelta al Grader inmediatamente. Si hay un validador, también se corre el validador contra el `.out` del usuario y el `.in` original, y también se envían los resultados (`.out` y metadata) al Grader. stderr y otras cosas únicamente se envían usando debug-rejudge en el frontend.

Una vez terminada la evaluación de todos los casos, se borran los archivos temporales y se procesa el siguiente mensaje.

## Grader, parte 2
Una vez que todo se tienen todas las salidas para un envío, se libera el Runner y se regresa al pool donde puede correr el siguiente envío. En paralelo, se invoca `omegaup.grader.Grader` que tiene toda la lógica de los distintos tipos de validadores: todos los validadores tokenizan el stream usando espacios como separadores. Algunos validadores (como token y token-caseless), verifican cada uno de los tokens y se rinden a la primer diferencia, o si uno de los streams dejó de producir tokens y el otro stream aún tiene. Otros validadores (como token-numeric) ignoran todos los tokens que no tengan formato numérico, e interpretan todos los números como flotantes, y hacen comparaciones con tolerancia. Esto produce un veredicto final por caso. Una vez que todos los casos tienen veredicto, si el problema tiene un archivo `/testplan`, se parsea ese archivo y se asignan pesos normalizados (al final la suma de todos los pesos debe ser igual a 1), caso contrario, cada caso vale 1 / número de casos. Ya con los pesos, se procede a agrupar los casos: todo lo que esté antes del primer '.', en el nombre del archivo se considera como el nombre del grupo (eso quiere decir que si no tiene un grupo explícito, todo lo que esté antes del `.in` será el nombre implícito del grupo). Un grupo se considera que otorga puntos solo si todos los casos del grupo tuvieron veredicto de AC o PA. Al final, se suman todos los puntos de los grupos y se multiplica por el número de puntos que ese problema da para ese concurso (o 100% en caso del modo de práctica). Se guarda el veredicto final en la base de datos y se encola el `RunContext` en el Broadcaster.

## Broadcaster
Broadcaster se encarga de mantener el scoreboard de los concursos y de notificar en casi-tiempo-real a todos los concursantes que hayan activado el modo de WebSockets. Cada envío que se ponga en la cola del Broadcaster que haya sido de un concurso, se manda llamar a `/api/scoreboard/refresh` en el Frontend, que se encarga de actualizar el scoreboard de acuerdo a las políticas del concurso. Una vez que el scoreboard fue actualizado y está en el cache del servidor, Broadcaster notifica a todos los participantes de ese concurso de que el scoreboard ha cambiado, y al autor del envío del veredicto. Una vez que llega ese punto, el `RunContext` guarda la información de cuánto tiempo pasó en cada una de las colas y cuánto tiempo tardó el Runner en contestar, junto con un poco más de información de debugging, y se destruye.